{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["\"use strict\";\nif (process.env.NEXT_RUNTIME === 'edge') {\n    module.exports = require('next/dist/server/route-modules/app-page/module.js');\n} else {\n    if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n        if (process.env.NODE_ENV === 'development') {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js');\n            }\n        } else {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js');\n            }\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js');\n            }\n        } else {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js');\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map"],"names":[],"mappings":"AACA;;KAEO;IACH;;SAcO;QACH,wCAA4C;YACxC,wCAA2B;gBACvB,OAAO,OAAO;YAClB;;QAGJ;;IAOJ;AACJ,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['react-ssr'].ReactJsxDevRuntime;\n\n//# sourceMappingURL=react-jsx-dev-runtime.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,YAAY,CAAC,kBAAkB,EAE1F,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['react-ssr'].React;\n\n//# sourceMappingURL=react.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,YAAY,CAAC,KAAK,EAE7E,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/shared/src/utils.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/shared/src/utils.ts"],"sourcesContent":["import { CamelToPascal } from './utility-types';\n\n/**\n * Converts string to kebab case\n *\n * @param {string} string\n * @returns {string} A kebabized string\n */\nexport const toKebabCase = (string: string) =>\n  string.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n\n/**\n * Converts string to pascal case\n *\n * @param {string} string\n * @returns {string} A pascalized string\n */\nexport const toPascalCase = <T extends string>(string: T): CamelToPascal<T> => {\n  const camelCase = string.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2) =>\n    p2 ? p2.toUpperCase() : p1.toLowerCase(),\n  );\n\n  return (camelCase.charAt(0).toUpperCase() + camelCase.slice(1)) as CamelToPascal<T>;\n};\n\n/**\n * Merges classes into a single string\n *\n * @param {array} classes\n * @returns {string} A string of classes\n */\nexport const mergeClasses = <ClassType = string | undefined | null>(...classes: ClassType[]) =>\n  classes\n    .filter((className, index, array) => {\n      return Boolean(className) && array.indexOf(className) === index;\n    })\n    .join(' ');\n"],"names":[],"mappings":";;;;;;;;;;;AAQa,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAc,CAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAC1B,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAO,OAAA,CAAQ,oBAAsB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAO,EAAE,WAAY,CAAA,CAAA,CAAA;AAsB/C,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,YAAA,CAAe,CAAA,CAAA,CAAA,CAA2C,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CACrE,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CACG,MAAA,CAAO,CAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAW,OAAO,KAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACnC,CAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAS,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAS,CAAM,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA;IAC5D,CAAC,CAAA,CACA,IAAA,CAAK,CAAG,CAAA,CAAA,CAAA,CAAA"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/defaultAttributes.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/defaultAttributes.ts"],"sourcesContent":["export default {\n  xmlns: 'http://www.w3.org/2000/svg',\n  width: 24,\n  height: 24,\n  viewBox: '0 0 24 24',\n  fill: 'none',\n  stroke: 'currentColor',\n  strokeWidth: 2,\n  strokeLinecap: 'round',\n  strokeLinejoin: 'round',\n};\n"],"names":[],"mappings":";;;;;;;;;AAAA,CAAe,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACb,CAAA,CAAA,CAAA,CAAA,CAAO,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACP,CAAA,CAAA,CAAA,CAAA,CAAO,EAAA,CAAA,CAAA,CAAA;IACP,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,EAAA,CAAA,CAAA,CAAA;IACR,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAS,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACT,CAAA,CAAA,CAAA,CAAM,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACN,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACR,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAa,EAAA,CAAA,CAAA;IACb,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAe,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACf,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAgB,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;AAClB,CAAA,CAAA"}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/Icon.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/Icon.ts"],"sourcesContent":["import { createElement, forwardRef } from 'react';\nimport defaultAttributes from './defaultAttributes';\nimport { IconNode, LucideProps } from './types';\nimport { mergeClasses } from '@lucide/shared';\n\ninterface IconComponentProps extends LucideProps {\n  iconNode: IconNode;\n}\n\n/**\n * Lucide icon component\n *\n * @component Icon\n * @param {object} props\n * @param {string} props.color - The color of the icon\n * @param {number} props.size - The size of the icon\n * @param {number} props.strokeWidth - The stroke width of the icon\n * @param {boolean} props.absoluteStrokeWidth - Whether to use absolute stroke width\n * @param {string} props.className - The class name of the icon\n * @param {IconNode} props.children - The children of the icon\n * @param {IconNode} props.iconNode - The icon node of the icon\n *\n * @returns {ForwardRefExoticComponent} LucideIcon\n */\nconst Icon = forwardRef<SVGSVGElement, IconComponentProps>(\n  (\n    {\n      color = 'currentColor',\n      size = 24,\n      strokeWidth = 2,\n      absoluteStrokeWidth,\n      className = '',\n      children,\n      iconNode,\n      ...rest\n    },\n    ref,\n  ) => {\n    return createElement(\n      'svg',\n      {\n        ref,\n        ...defaultAttributes,\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? (Number(strokeWidth) * 24) / Number(size) : strokeWidth,\n        className: mergeClasses('lucide', className),\n        ...rest,\n      },\n      [\n        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n        ...(Array.isArray(children) ? children : [children]),\n      ],\n    );\n  },\n);\n\nexport default Icon;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/createLucideIcon.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/createLucideIcon.ts"],"sourcesContent":["import { createElement, forwardRef } from 'react';\nimport { mergeClasses, toKebabCase } from '@lucide/shared';\nimport { IconNode, LucideProps } from './types';\nimport Icon from './Icon';\n\n/**\n * Create a Lucide icon component\n * @param {string} iconName\n * @param {array} iconNode\n * @returns {ForwardRefExoticComponent} LucideIcon\n */\nconst createLucideIcon = (iconName: string, iconNode: IconNode) => {\n  const Component = forwardRef<SVGSVGElement, LucideProps>(({ className, ...props }, ref) =>\n    createElement(Icon, {\n      ref,\n      iconNode,\n      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),\n      ...props,\n    }),\n  );\n\n  Component.displayName = `${iconName}`;\n\n  return Component;\n};\n\nexport default createLucideIcon;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAWM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,gBAAA,CAAmB,CAAA,CAAA,CAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAkB,QAAuB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;IACjE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,CAAY,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,gOAAA,CAAA,CAAuC,CAAC,CAAA,CAAE,CAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GACjF,4OAAA,EAAc,uLAAM,CAAA,CAAA,CAAA;YAClB,CAAA,CAAA,CAAA,CAAA;YACA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACA,eAAW,CAAa,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,mMAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAU,6MAAA,EAAY,QAAQ,CAAC,EAAA,EAAI,SAAS,CAAA,CAAA;YACpE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CACJ,CAAA;IAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAc,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA,CAAA,CAAA;IAE5B,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA;AACT,CAAA,CAAA"}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/phone.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/phone.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Phone\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjIgMTYuOTJ2M2EyIDIgMCAwIDEtMi4xOCAyIDE5Ljc5IDE5Ljc5IDAgMCAxLTguNjMtMy4wNyAxOS41IDE5LjUgMCAwIDEtNi02IDE5Ljc5IDE5Ljc5IDAgMCAxLTMuMDctOC42N0EyIDIgMCAwIDEgNC4xMSAyaDNhMiAyIDAgMCAxIDIgMS43MiAxMi44NCAxMi44NCAwIDAgMCAuNyAyLjgxIDIgMiAwIDAgMS0uNDUgMi4xMUw4LjA5IDkuOTFhMTYgMTYgMCAwIDAgNiA2bDEuMjctMS4yN2EyIDIgMCAwIDEgMi4xMS0uNDUgMTIuODQgMTIuODQgMCAwIDAgMi44MS43QTIgMiAwIDAgMSAyMiAxNi45MnoiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/phone\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Phone = createLucideIcon('Phone', [\n  [\n    'path',\n    {\n      d: 'M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z',\n      key: 'foiqr5',\n    },\n  ],\n]);\n\nexport default Phone;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAQ,mMAAA,EAAiB,OAAS,CAAA,CAAA,CAAA;IACtC,CAAA;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA,CAAA;YACE,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,CAAA,CAAA,CAAK,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACP,CAAA;KACF;CACD,CAAA,CAAA"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/shopping-cart.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/shopping-cart.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ShoppingCart\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSI4IiBjeT0iMjEiIHI9IjEiIC8+CiAgPGNpcmNsZSBjeD0iMTkiIGN5PSIyMSIgcj0iMSIgLz4KICA8cGF0aCBkPSJNMi4wNSAyLjA1aDJsMi42NiAxMi40MmEyIDIgMCAwIDAgMiAxLjU4aDkuNzhhMiAyIDAgMCAwIDEuOTUtMS41N2wxLjY1LTcuNDNINS4xMiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/shopping-cart\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ShoppingCart = createLucideIcon('ShoppingCart', [\n  ['circle', { cx: '8', cy: '21', r: '1', key: 'jimo8o' }],\n  ['circle', { cx: '19', cy: '21', r: '1', key: '13723u' }],\n  [\n    'path',\n    {\n      d: 'M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12',\n      key: '9zh506',\n    },\n  ],\n]);\n\nexport default ShoppingCart;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAe,mMAAA,EAAiB,cAAgB,CAAA,CAAA,CAAA;IACpD;QAAC,QAAU,CAAA;QAAA,CAAA;YAAE,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA;YAAK,CAAI,CAAA,CAAA,CAAA,IAAA,CAAM;YAAA,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA;YAAK,GAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA,CAAA;IACvD;QAAC,QAAU,CAAA;QAAA,CAAA;YAAE,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAI,CAAA,CAAA,CAAA,IAAA,CAAM;YAAA,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA;YAAK,GAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA,CAAA;IACxD,CAAA;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA,CAAA;YACE,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,CAAA,CAAA,CAAK,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACP,CAAA;KACF;CACD,CAAA,CAAA"}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/user.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/user.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name User\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTkgMjF2LTJhNCA0IDAgMCAwLTQtNEg5YTQgNCAwIDAgMC00IDR2MiIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjciIHI9IjQiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/user\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst User = createLucideIcon('User', [\n  ['path', { d: 'M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2', key: '975kel' }],\n  ['circle', { cx: '12', cy: '7', r: '4', key: '17ys0d' }],\n]);\n\nexport default User;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAO,mMAAA,EAAiB,MAAQ,CAAA,CAAA,CAAA;IACpC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAA6C,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC1E;QAAC,QAAU,CAAA;QAAA,CAAA;YAAE,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAI,CAAA,CAAA,CAAA,GAAA,CAAK;YAAA,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA;YAAK,GAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CACxD,CAAA,CAAA"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/search.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/search.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Search\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4IiAvPgogIDxwYXRoIGQ9Im0yMSAyMS00LjMtNC4zIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/search\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Search = createLucideIcon('Search', [\n  ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],\n  ['path', { d: 'm21 21-4.3-4.3', key: '1qie3q' }],\n]);\n\nexport default Search;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAS,mMAAA,EAAiB,QAAU,CAAA,CAAA,CAAA;IACxC;QAAC,QAAU,CAAA;QAAA,CAAA;YAAE,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAI,CAAA,CAAA,CAAA,IAAA,CAAM;YAAA,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA;YAAK,GAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA,CAAA;IACxD;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAkB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAChD,CAAA,CAAA"}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/menu.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/menu.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Menu\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8bGluZSB4MT0iNCIgeDI9IjIwIiB5MT0iMTIiIHkyPSIxMiIgLz4KICA8bGluZSB4MT0iNCIgeDI9IjIwIiB5MT0iNiIgeTI9IjYiIC8+CiAgPGxpbmUgeDE9IjQiIHgyPSIyMCIgeTE9IjE4IiB5Mj0iMTgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/menu\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Menu = createLucideIcon('Menu', [\n  ['line', { x1: '4', x2: '20', y1: '12', y2: '12', key: '1e0a9i' }],\n  ['line', { x1: '4', x2: '20', y1: '6', y2: '6', key: '1owob3' }],\n  ['line', { x1: '4', x2: '20', y1: '18', y2: '18', key: 'yk5zj1' }],\n]);\n\nexport default Menu;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAO,mMAAA,EAAiB,MAAQ,CAAA,CAAA,CAAA;IACpC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAK,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IACjE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAK,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAK,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAK;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC/D;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAK,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAClE,CAAA,CAAA"}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/x.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/x.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name X\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTggNiA2IDE4IiAvPgogIDxwYXRoIGQ9Im02IDYgMTIgMTIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/x\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst X = createLucideIcon('X', [\n  ['path', { d: 'M18 6 6 18', key: '1bl5f8' }],\n  ['path', { d: 'm6 6 12 12', key: 'd8bk6v' }],\n]);\n\nexport default X;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAI,mMAAA,EAAiB,GAAK,CAAA,CAAA,CAAA;IAC9B;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAc,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC3C;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAc,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAC5C,CAAA,CAAA"}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/log-in.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/log-in.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name LogIn\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTUgM2g0YTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMmgtNCIgLz4KICA8cG9seWxpbmUgcG9pbnRzPSIxMCAxNyAxNSAxMiAxMCA3IiAvPgogIDxsaW5lIHgxPSIxNSIgeDI9IjMiIHkxPSIxMiIgeTI9IjEyIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/log-in\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LogIn = createLucideIcon('LogIn', [\n  ['path', { d: 'M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4', key: 'u53s6r' }],\n  ['polyline', { points: '10 17 15 12 10 7', key: '1ail0h' }],\n  ['line', { x1: '15', x2: '3', y1: '12', y2: '12', key: 'v6grx8' }],\n]);\n\nexport default LogIn;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAQ,mMAAA,EAAiB,OAAS,CAAA,CAAA,CAAA;IACtC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAA6C,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC1E;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAY,CAAA;QAAA,CAAA;YAAE,QAAQ,CAAoB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC1D;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAK,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAClE,CAAA,CAAA"}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/log-out.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/log-out.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name LogOut\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDQiIC8+CiAgPHBvbHlsaW5lIHBvaW50cz0iMTYgMTcgMjEgMTIgMTYgNyIgLz4KICA8bGluZSB4MT0iMjEiIHgyPSI5IiB5MT0iMTIiIHkyPSIxMiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/log-out\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LogOut = createLucideIcon('LogOut', [\n  ['path', { d: 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4', key: '1uf3rs' }],\n  ['polyline', { points: '16 17 21 12 16 7', key: '1gabdz' }],\n  ['line', { x1: '21', x2: '9', y1: '12', y2: '12', key: '1uyos4' }],\n]);\n\nexport default LogOut;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAS,mMAAA,EAAiB,QAAU,CAAA,CAAA,CAAA;IACxC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAA2C,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IACxE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAY,CAAA;QAAA,CAAA;YAAE,QAAQ,CAAoB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC1D;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAK,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAClE,CAAA,CAAA"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/circle-user.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/circle-user.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name CircleUser\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEwIiByPSIzIiAvPgogIDxwYXRoIGQ9Ik03IDIwLjY2MlYxOWEyIDIgMCAwIDEgMi0yaDZhMiAyIDAgMCAxIDIgMnYxLjY2MiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/circle-user\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst CircleUser = createLucideIcon('CircleUser', [\n  ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],\n  ['circle', { cx: '12', cy: '10', r: '3', key: 'ilqhr7' }],\n  ['path', { d: 'M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662', key: '154egf' }],\n]);\n\nexport default CircleUser;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAa,mMAAA,EAAiB,YAAc,CAAA,CAAA,CAAA;IAChD;QAAC,QAAU,CAAA;QAAA,CAAA;YAAE,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAI,CAAA,CAAA,CAAA,IAAA,CAAM;YAAA,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,GAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA,CAAA;IACzD;QAAC,QAAU,CAAA;QAAA,CAAA;YAAE,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAI,CAAA,CAAA,CAAA,IAAA,CAAM;YAAA,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA;YAAK,GAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA,CAAA;IACxD;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAoD,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAClF,CAAA,CAAA"}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/%40swc/helpers/cjs/_interop_require_wildcard.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) return obj;\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return { default: obj };\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n\n    if (cache && cache.has(obj)) return cache.get(obj);\n\n    var newObj = { __proto__: null };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n            else newObj[key] = obj[key];\n        }\n    }\n\n    newObj.default = obj;\n\n    if (cache) cache.set(obj, newObj);\n\n    return newObj;\n}\nexports._ = _interop_require_wildcard;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,WAAW;IACzC,IAAI,OAAO,YAAY,YAAY,OAAO;IAE1C,IAAI,oBAAoB,IAAI;IAC5B,IAAI,mBAAmB,IAAI;IAE3B,OAAO,CAAC,2BAA2B,SAAS,WAAW;QACnD,OAAO,cAAc,mBAAmB;IAC5C,CAAC,EAAE;AACP;AACA,SAAS,0BAA0B,GAAG,EAAE,WAAW;IAC/C,IAAI,CAAC,eAAe,OAAO,IAAI,UAAU,EAAE,OAAO;IAClD,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY,OAAO;QAAE,SAAS;IAAI;IAEhG,IAAI,QAAQ,yBAAyB;IAErC,IAAI,SAAS,MAAM,GAAG,CAAC,MAAM,OAAO,MAAM,GAAG,CAAC;IAE9C,IAAI,SAAS;QAAE,WAAW;IAAK;IAC/B,IAAI,wBAAwB,OAAO,cAAc,IAAI,OAAO,wBAAwB;IAEpF,IAAK,IAAI,OAAO,IAAK;QACjB,IAAI,QAAQ,aAAa,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,MAAM;YACrE,IAAI,OAAO,wBAAwB,OAAO,wBAAwB,CAAC,KAAK,OAAO;YAC/E,IAAI,QAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG,OAAO,cAAc,CAAC,QAAQ,KAAK;iBAClE,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI;QAC/B;IACJ;IAEA,OAAO,OAAO,GAAG;IAEjB,IAAI,OAAO,MAAM,GAAG,CAAC,KAAK;IAE1B,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['react-ssr'].ReactJsxRuntime;\n\n//# sourceMappingURL=react-jsx-runtime.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,YAAY,CAAC,eAAe,EAEvF,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/querystring.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    assign: null,\n    searchParamsToUrlQuery: null,\n    urlQueryToSearchParams: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    for (const [key, value] of searchParams.entries()){\n        const existing = query[key];\n        if (typeof existing === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            query[key] = [\n                existing,\n                value\n            ];\n        }\n    }\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(query) {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const item of value){\n                searchParams.append(key, stringifyUrlQueryParam(item));\n            }\n        } else {\n            searchParams.set(key, stringifyUrlQueryParam(value));\n        }\n    }\n    return searchParams;\n}\nfunction assign(target, ...searchParamsList) {\n    for (const searchParams of searchParamsList){\n        for (const key of searchParams.keys()){\n            target.delete(key);\n        }\n        for (const [key, value] of searchParams.entries()){\n            target.append(key, value);\n        }\n    }\n    return target;\n}\n\n//# sourceMappingURL=querystring.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,QAAQ;IACR,wBAAwB;IACxB,wBAAwB;AAC5B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,QAAQ;QACJ,OAAO;IACX;IACA,wBAAwB;QACpB,OAAO;IACX;IACA,wBAAwB;QACpB,OAAO;IACX;AACJ;AACA,SAAS,uBAAuB,YAAY;IACxC,MAAM,QAAQ,CAAC;IACf,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,aAAa,OAAO,GAAG;QAC9C,MAAM,WAAW,KAAK,CAAC,IAAI;QAC3B,IAAI,OAAO,aAAa,aAAa;YACjC,KAAK,CAAC,IAAI,GAAG;QACjB,OAAO,IAAI,MAAM,OAAO,CAAC,WAAW;YAChC,SAAS,IAAI,CAAC;QAClB,OAAO;YACH,KAAK,CAAC,IAAI,GAAG;gBACT;gBACA;aACH;QACL;IACJ;IACA,OAAO;AACX;AACA,SAAS,uBAAuB,KAAK;IACjC,IAAI,OAAO,UAAU,UAAU;QAC3B,OAAO;IACX;IACA,IAAI,OAAO,UAAU,YAAY,CAAC,MAAM,UAAU,OAAO,UAAU,WAAW;QAC1E,OAAO,OAAO;IAClB,OAAO;QACH,OAAO;IACX;AACJ;AACA,SAAS,uBAAuB,KAAK;IACjC,MAAM,eAAe,IAAI;IACzB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,OAAO;QAC7C,IAAI,MAAM,OAAO,CAAC,QAAQ;YACtB,KAAK,MAAM,QAAQ,MAAM;gBACrB,aAAa,MAAM,CAAC,KAAK,uBAAuB;YACpD;QACJ,OAAO;YACH,aAAa,GAAG,CAAC,KAAK,uBAAuB;QACjD;IACJ;IACA,OAAO;AACX;AACA,SAAS,OAAO,MAAM,EAAE,GAAG,gBAAgB;IACvC,KAAK,MAAM,gBAAgB,iBAAiB;QACxC,KAAK,MAAM,OAAO,aAAa,IAAI,GAAG;YAClC,OAAO,MAAM,CAAC;QAClB;QACA,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,aAAa,OAAO,GAAG;YAC9C,OAAO,MAAM,CAAC,KAAK;QACvB;IACJ;IACA,OAAO;AACX,EAEA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 702, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/format-url.js"],"sourcesContent":["// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    formatUrl: null,\n    formatWithValidation: null,\n    urlObjectKeys: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(require(\"./querystring\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && `?${query}` || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return `${protocol}${host}${pathname}${search}${hash}`;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (process.env.NODE_ENV === 'development') {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n}\n\n//# sourceMappingURL=format-url.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['contexts'].AppRouterContext;\n\n//# sourceMappingURL=app-router-context.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,WAAW,CAAC,gBAAgB,EAEvF,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/parse-path.js"],"sourcesContent":["/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"parsePath\", {\n    enumerable: true,\n    get: function() {\n        return parsePath;\n    }\n});\nfunction parsePath(path) {\n    const hashIndex = path.indexOf('#');\n    const queryIndex = path.indexOf('?');\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\n            hash: hashIndex > -1 ? path.slice(hashIndex) : ''\n        };\n    }\n    return {\n        pathname: path,\n        query: '',\n        hash: ''\n    };\n}\n\n//# sourceMappingURL=parse-path.js.map"],"names":[],"mappings":"AAAA;;;;CAIC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,aAAa;IACxC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,UAAU,IAAI;IACnB,MAAM,YAAY,KAAK,OAAO,CAAC;IAC/B,MAAM,aAAa,KAAK,OAAO,CAAC;IAChC,MAAM,WAAW,aAAa,CAAC,KAAK,CAAC,YAAY,KAAK,aAAa,SAAS;IAC5E,IAAI,YAAY,YAAY,CAAC,GAAG;QAC5B,OAAO;YACH,UAAU,KAAK,SAAS,CAAC,GAAG,WAAW,aAAa;YACpD,OAAO,WAAW,KAAK,SAAS,CAAC,YAAY,YAAY,CAAC,IAAI,YAAY,aAAa;YACvF,MAAM,YAAY,CAAC,IAAI,KAAK,KAAK,CAAC,aAAa;QACnD;IACJ;IACA,OAAO;QACH,UAAU;QACV,OAAO;QACP,MAAM;IACV;AACJ,EAEA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 853, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"addPathPrefix\", {\n    enumerable: true,\n    get: function() {\n        return addPathPrefix;\n    }\n});\nconst _parsepath = require(\"./parse-path\");\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    return `${prefix}${pathname}${query}${hash}`;\n}\n\n//# sourceMappingURL=add-path-prefix.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,iBAAiB;IAC5C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,cAAc,IAAI,EAAE,MAAM;IAC/B,IAAI,CAAC,KAAK,UAAU,CAAC,QAAQ,CAAC,QAAQ;QAClC,OAAO;IACX;IACA,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,GAAG,WAAW,SAAS,EAAE;IAC5D,OAAO,GAAG,SAAS,WAAW,QAAQ,MAAM;AAChD,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 874, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js"],"sourcesContent":["/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"removeTrailingSlash\", {\n    enumerable: true,\n    get: function() {\n        return removeTrailingSlash;\n    }\n});\nfunction removeTrailingSlash(route) {\n    return route.replace(/\\/$/, '') || '/';\n}\n\n//# sourceMappingURL=remove-trailing-slash.js.map"],"names":[],"mappings":"AAAA;;;;;;CAMC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,uBAAuB;IAClD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,oBAAoB,KAAK;IAC9B,OAAO,MAAM,OAAO,CAAC,OAAO,OAAO;AACvC,EAEA,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 896, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/normalize-trailing-slash.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"normalizePathTrailingSlash\", {\n    enumerable: true,\n    get: function() {\n        return normalizePathTrailingSlash;\n    }\n});\nconst _removetrailingslash = require(\"../shared/lib/router/utils/remove-trailing-slash\");\nconst _parsepath = require(\"../shared/lib/router/utils/parse-path\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    if (process.env.__NEXT_TRAILING_SLASH) {\n        if (/\\.[^/]+\\/?$/.test(pathname)) {\n            return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n        } else if (pathname.endsWith('/')) {\n            return `${pathname}${query}${hash}`;\n        } else {\n            return `${pathname}/${query}${hash}`;\n        }\n    }\n    return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=normalize-trailing-slash.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,8BAA8B;IACzD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,6BAA6B,CAAC;IAChC,IAAI,CAAC,KAAK,UAAU,CAAC,kDAAkD;QACnE,OAAO;IACX;IACA,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,GAAG,WAAW,SAAS,EAAE;IAC5D;;IASA,OAAO,GAAG,CAAC,GAAG,qBAAqB,mBAAmB,EAAE,YAAY,QAAQ,MAAM;AACtF;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 927, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/add-base-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"addBasePath\", {\n    enumerable: true,\n    get: function() {\n        return addBasePath;\n    }\n});\nconst _addpathprefix = require(\"../shared/lib/router/utils/add-path-prefix\");\nconst _normalizetrailingslash = require(\"./normalize-trailing-slash\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction addBasePath(path, required) {\n    return (0, _normalizetrailingslash.normalizePathTrailingSlash)(process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required ? path : (0, _addpathprefix.addPathPrefix)(path, basePath));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=add-base-path.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,eAAe;IAC1C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,WAAW,wCAAsC;AACvD,SAAS,YAAY,IAAI,EAAE,QAAQ;IAC/B,OAAO,CAAC,GAAG,wBAAwB,0BAA0B,EAAE,sCAA0D,0BAAO,CAAC,GAAG,eAAe,aAAa,EAAE,MAAM;AAC5K;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 953, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/types.js"],"sourcesContent":["/**\n * Shared types and constants for the Segment Cache.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    FetchStrategy: null,\n    NavigationResultTag: null,\n    PrefetchPriority: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    FetchStrategy: function() {\n        return FetchStrategy;\n    },\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    }\n});\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\nvar FetchStrategy = /*#__PURE__*/ function(FetchStrategy) {\n    // Deliberately ordered so we can easily compare two segments\n    // and determine if one segment is \"more specific\" than another\n    // (i.e. if it's likely that it contains more data)\n    FetchStrategy[FetchStrategy[\"LoadingBoundary\"] = 0] = \"LoadingBoundary\";\n    FetchStrategy[FetchStrategy[\"PPR\"] = 1] = \"PPR\";\n    FetchStrategy[FetchStrategy[\"PPRRuntime\"] = 2] = \"PPRRuntime\";\n    FetchStrategy[FetchStrategy[\"Full\"] = 3] = \"Full\";\n    return FetchStrategy;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=types.js.map"],"names":[],"mappings":"AAAA;;CAEC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,qBAAqB;IACrB,kBAAkB;AACtB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;IACA,kBAAkB;QACd,OAAO;IACX;AACJ;AACA,IAAI,sBAAsB,WAAW,GAAG,SAAS,mBAAmB;IAChE,mBAAmB,CAAC,mBAAmB,CAAC,MAAM,GAAG,EAAE,GAAG;IACtD,mBAAmB,CAAC,mBAAmB,CAAC,UAAU,GAAG,EAAE,GAAG;IAC1D,mBAAmB,CAAC,mBAAmB,CAAC,OAAO,GAAG,EAAE,GAAG;IACvD,mBAAmB,CAAC,mBAAmB,CAAC,QAAQ,GAAG,EAAE,GAAG;IACxD,OAAO;AACX,EAAE,CAAC;AACH,IAAI,mBAAmB,WAAW,GAAG,SAAS,gBAAgB;IAC1D;;;;;GAKD,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,SAAS,GAAG,EAAE,GAAG;IACrD;;GAED,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,UAAU,GAAG,EAAE,GAAG;IACtD;;;GAGD,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,aAAa,GAAG,EAAE,GAAG;IACzD,OAAO;AACX,EAAE,CAAC;AACH,IAAI,gBAAgB,WAAW,GAAG,SAAS,aAAa;IACpD,6DAA6D;IAC7D,+DAA+D;IAC/D,mDAAmD;IACnD,aAAa,CAAC,aAAa,CAAC,kBAAkB,GAAG,EAAE,GAAG;IACtD,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,EAAE,GAAG;IAC1C,aAAa,CAAC,aAAa,CAAC,aAAa,GAAG,EAAE,GAAG;IACjD,aAAa,CAAC,aAAa,CAAC,OAAO,GAAG,EAAE,GAAG;IAC3C,OAAO;AACX,EAAE,CAAC;AAEH,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1024, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/cache-key.js"],"sourcesContent":["// TypeScript trick to simulate opaque types, like in Flow.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createCacheKey\", {\n    enumerable: true,\n    get: function() {\n        return createCacheKey;\n    }\n});\nfunction createCacheKey(originalHref, nextUrl) {\n    const originalUrl = new URL(originalHref);\n    const cacheKey = {\n        pathname: originalUrl.pathname,\n        search: originalUrl.search,\n        nextUrl: nextUrl\n    };\n    return cacheKey;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=cache-key.js.map"],"names":[],"mappings":"AAAA,2DAA2D;AAE3D,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,eAAe,YAAY,EAAE,OAAO;IACzC,MAAM,cAAc,IAAI,IAAI;IAC5B,MAAM,WAAW;QACb,UAAU,YAAY,QAAQ;QAC9B,QAAQ,YAAY,MAAM;QAC1B,SAAS;IACb;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/app-router-types.js"],"sourcesContent":["/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"HasLoadingBoundary\", {\n    enumerable: true,\n    get: function() {\n        return HasLoadingBoundary;\n    }\n});\nvar HasLoadingBoundary = /*#__PURE__*/ function(HasLoadingBoundary) {\n    // There is a loading boundary in this particular segment\n    HasLoadingBoundary[HasLoadingBoundary[\"SegmentHasLoadingBoundary\"] = 1] = \"SegmentHasLoadingBoundary\";\n    // There is a loading boundary somewhere in the subtree (but not in\n    // this segment)\n    HasLoadingBoundary[HasLoadingBoundary[\"SubtreeHasLoadingBoundary\"] = 2] = \"SubtreeHasLoadingBoundary\";\n    // There is no loading boundary in this segment or any of its descendants\n    HasLoadingBoundary[HasLoadingBoundary[\"SubtreeHasNoLoadingBoundary\"] = 3] = \"SubtreeHasNoLoadingBoundary\";\n    return HasLoadingBoundary;\n}({});\n\n//# sourceMappingURL=app-router-types.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,IAAI,qBAAqB,WAAW,GAAG,SAAS,kBAAkB;IAC9D,yDAAyD;IACzD,kBAAkB,CAAC,kBAAkB,CAAC,4BAA4B,GAAG,EAAE,GAAG;IAC1E,mEAAmE;IACnE,gBAAgB;IAChB,kBAAkB,CAAC,kBAAkB,CAAC,4BAA4B,GAAG,EAAE,GAAG;IAC1E,yEAAyE;IACzE,kBAAkB,CAAC,kBAAkB,CAAC,8BAA8B,GAAG,EAAE,GAAG;IAC5E,OAAO;AACX,EAAE,CAAC,IAEH,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 1082, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/match-segments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"matchSegment\", {\n    enumerable: true,\n    get: function() {\n        return matchSegment;\n    }\n});\nconst matchSegment = (existingSegment, segment)=>{\n    // segment is either Array or string\n    if (typeof existingSegment === 'string') {\n        if (typeof segment === 'string') {\n            // Common case: segment is just a string\n            return existingSegment === segment;\n        }\n        return false;\n    }\n    if (typeof segment === 'string') {\n        return false;\n    }\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=match-segments.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,gBAAgB;IAC3C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,eAAe,CAAC,iBAAiB;IACnC,oCAAoC;IACpC,IAAI,OAAO,oBAAoB,UAAU;QACrC,IAAI,OAAO,YAAY,UAAU;YAC7B,wCAAwC;YACxC,OAAO,oBAAoB;QAC/B;QACA,OAAO;IACX;IACA,IAAI,OAAO,YAAY,UAAU;QAC7B,OAAO;IACX;IACA,OAAO,eAAe,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE,IAAI,eAAe,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE;AACjF;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 1116, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/app-router-headers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HEADER: null,\n    FLIGHT_HEADERS: null,\n    NEXT_ACTION_NOT_FOUND_HEADER: null,\n    NEXT_DID_POSTPONE_HEADER: null,\n    NEXT_HMR_REFRESH_HASH_COOKIE: null,\n    NEXT_HMR_REFRESH_HEADER: null,\n    NEXT_HTML_REQUEST_ID_HEADER: null,\n    NEXT_IS_PRERENDER_HEADER: null,\n    NEXT_REQUEST_ID_HEADER: null,\n    NEXT_REWRITTEN_PATH_HEADER: null,\n    NEXT_REWRITTEN_QUERY_HEADER: null,\n    NEXT_ROUTER_PREFETCH_HEADER: null,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: null,\n    NEXT_ROUTER_STALE_TIME_HEADER: null,\n    NEXT_ROUTER_STATE_TREE_HEADER: null,\n    NEXT_RSC_UNION_QUERY: null,\n    NEXT_URL: null,\n    RSC_CONTENT_TYPE_HEADER: null,\n    RSC_HEADER: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HEADER: function() {\n        return ACTION_HEADER;\n    },\n    FLIGHT_HEADERS: function() {\n        return FLIGHT_HEADERS;\n    },\n    NEXT_ACTION_NOT_FOUND_HEADER: function() {\n        return NEXT_ACTION_NOT_FOUND_HEADER;\n    },\n    NEXT_DID_POSTPONE_HEADER: function() {\n        return NEXT_DID_POSTPONE_HEADER;\n    },\n    NEXT_HMR_REFRESH_HASH_COOKIE: function() {\n        return NEXT_HMR_REFRESH_HASH_COOKIE;\n    },\n    NEXT_HMR_REFRESH_HEADER: function() {\n        return NEXT_HMR_REFRESH_HEADER;\n    },\n    NEXT_HTML_REQUEST_ID_HEADER: function() {\n        return NEXT_HTML_REQUEST_ID_HEADER;\n    },\n    NEXT_IS_PRERENDER_HEADER: function() {\n        return NEXT_IS_PRERENDER_HEADER;\n    },\n    NEXT_REQUEST_ID_HEADER: function() {\n        return NEXT_REQUEST_ID_HEADER;\n    },\n    NEXT_REWRITTEN_PATH_HEADER: function() {\n        return NEXT_REWRITTEN_PATH_HEADER;\n    },\n    NEXT_REWRITTEN_QUERY_HEADER: function() {\n        return NEXT_REWRITTEN_QUERY_HEADER;\n    },\n    NEXT_ROUTER_PREFETCH_HEADER: function() {\n        return NEXT_ROUTER_PREFETCH_HEADER;\n    },\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {\n        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;\n    },\n    NEXT_ROUTER_STALE_TIME_HEADER: function() {\n        return NEXT_ROUTER_STALE_TIME_HEADER;\n    },\n    NEXT_ROUTER_STATE_TREE_HEADER: function() {\n        return NEXT_ROUTER_STATE_TREE_HEADER;\n    },\n    NEXT_RSC_UNION_QUERY: function() {\n        return NEXT_RSC_UNION_QUERY;\n    },\n    NEXT_URL: function() {\n        return NEXT_URL;\n    },\n    RSC_CONTENT_TYPE_HEADER: function() {\n        return RSC_CONTENT_TYPE_HEADER;\n    },\n    RSC_HEADER: function() {\n        return RSC_HEADER;\n    }\n});\nconst RSC_HEADER = 'rsc';\nconst ACTION_HEADER = 'next-action';\nconst NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\nconst NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\nconst NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\nconst NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\nconst NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\nconst NEXT_URL = 'next-url';\nconst RSC_CONTENT_TYPE_HEADER = 'text/x-component';\nconst FLIGHT_HEADERS = [\n    RSC_HEADER,\n    NEXT_ROUTER_STATE_TREE_HEADER,\n    NEXT_ROUTER_PREFETCH_HEADER,\n    NEXT_HMR_REFRESH_HEADER,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n];\nconst NEXT_RSC_UNION_QUERY = '_rsc';\nconst NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\nconst NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\nconst NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\nconst NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\nconst NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\nconst NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\nconst NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id';\nconst NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id';\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-router-headers.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,gBAAgB;IAChB,8BAA8B;IAC9B,0BAA0B;IAC1B,8BAA8B;IAC9B,yBAAyB;IACzB,6BAA6B;IAC7B,0BAA0B;IAC1B,wBAAwB;IACxB,4BAA4B;IAC5B,6BAA6B;IAC7B,6BAA6B;IAC7B,qCAAqC;IACrC,+BAA+B;IAC/B,+BAA+B;IAC/B,sBAAsB;IACtB,UAAU;IACV,yBAAyB;IACzB,YAAY;AAChB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,0BAA0B;QACtB,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,0BAA0B;QACtB,OAAO;IACX;IACA,wBAAwB;QACpB,OAAO;IACX;IACA,4BAA4B;QACxB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,qCAAqC;QACjC,OAAO;IACX;IACA,+BAA+B;QAC3B,OAAO;IACX;IACA,+BAA+B;QAC3B,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;IACA,UAAU;QACN,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;IACA,YAAY;QACR,OAAO;IACX;AACJ;AACA,MAAM,aAAa;AACnB,MAAM,gBAAgB;AACtB,MAAM,gCAAgC;AACtC,MAAM,8BAA8B;AACpC,MAAM,sCAAsC;AAC5C,MAAM,0BAA0B;AAChC,MAAM,+BAA+B;AACrC,MAAM,WAAW;AACjB,MAAM,0BAA0B;AAChC,MAAM,iBAAiB;IACnB;IACA;IACA;IACA;IACA;CACH;AACD,MAAM,uBAAuB;AAC7B,MAAM,gCAAgC;AACtC,MAAM,2BAA2B;AACjC,MAAM,6BAA6B;AACnC,MAAM,8BAA8B;AACpC,MAAM,2BAA2B;AACjC,MAAM,+BAA+B;AACrC,MAAM,yBAAyB;AAC/B,MAAM,8BAA8B;AAEpC,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 1241, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['react-ssr'].ReactServerDOMTurbopackClient;\n\n//# sourceMappingURL=react-server-dom-turbopack-client.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,YAAY,CAAC,6BAA6B,EAErG,6DAA6D","ignoreList":[0]}},
    {"offset": {"line": 1246, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HMR_REFRESH: null,\n    ACTION_NAVIGATE: null,\n    ACTION_REFRESH: null,\n    ACTION_RESTORE: null,\n    ACTION_SERVER_ACTION: null,\n    ACTION_SERVER_PATCH: null,\n    PrefetchKind: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n    return PrefetchKind;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=router-reducer-types.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,iBAAiB;IACjB,gBAAgB;IAChB,gBAAgB;IAChB,sBAAsB;IACtB,qBAAqB;IACrB,cAAc;AAClB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;IACA,cAAc;QACV,OAAO;IACX;AACJ;AACA,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB,MAAM,iBAAiB;AACvB,MAAM,sBAAsB;AAC5B,MAAM,qBAAqB;AAC3B,MAAM,uBAAuB;AAC7B,IAAI,eAAe,WAAW,GAAG,SAAS,YAAY;IAClD,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,YAAY,GAAG;IAC5B,OAAO;AACX,EAAE,CAAC;AAEH,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-call-server.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"callServer\", {\n    enumerable: true,\n    get: function() {\n        return callServer;\n    }\n});\nconst _react = require(\"react\");\nconst _routerreducertypes = require(\"./components/router-reducer/router-reducer-types\");\nconst _useactionqueue = require(\"./components/use-action-queue\");\nasync function callServer(actionId, actionArgs) {\n    return new Promise((resolve, reject)=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_SERVER_ACTION,\n                actionId,\n                actionArgs,\n                resolve,\n                reject\n            });\n        });\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-call-server.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;;;;;AACN,eAAe,WAAW,QAAQ,EAAE,UAAU;IAC1C,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB,CAAC,GAAG,OAAO,eAAe,EAAE;YACxB,CAAC,GAAG,gBAAgB,uBAAuB,EAAE;gBACzC,MAAM,oBAAoB,oBAAoB;gBAC9C;gBACA;gBACA;gBACA;YACJ;QACJ;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 1350, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-find-source-map-url.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"findSourceMapURL\", {\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n});\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nconst pathname = `${basePath}/__nextjs_source-map`;\nconst findSourceMapURL = process.env.NODE_ENV === 'development' ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return `${filename}.map`;\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : undefined;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-find-source-map-url.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,oBAAoB;IAC/C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,WAAW,wCAAsC;AACvD,MAAM,WAAW,GAAG,SAAS,oBAAoB,CAAC;AAClD,MAAM,mBAAmB,uCAAyC,SAAS,iBAAiB,QAAQ;IAChG,IAAI,aAAa,IAAI;QACjB,OAAO;IACX;IACA,IAAI,SAAS,UAAU,CAAC,SAAS,QAAQ,CAAC,MAAM,KAAK,SAAS,QAAQ,CAAC,kBAAkB;QACrF,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAO,GAAG,SAAS,IAAI,CAAC;IAC5B;IACA,MAAM,MAAM,IAAI,IAAI,UAAU,SAAS,QAAQ,CAAC,MAAM;IACtD,IAAI,YAAY,CAAC,GAAG,CAAC,YAAY;IACjC,OAAO,IAAI,IAAI;AACnB,IAAI;AAEJ,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 1390, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/segment.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DEFAULT_SEGMENT_KEY: null,\n    PAGE_SEGMENT_KEY: null,\n    addSearchParamsIfPageSegment: null,\n    computeSelectedLayoutSegment: null,\n    getSegmentValue: null,\n    getSelectedLayoutSegmentPath: null,\n    isGroupSegment: null,\n    isParallelRouteSegment: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DEFAULT_SEGMENT_KEY: function() {\n        return DEFAULT_SEGMENT_KEY;\n    },\n    PAGE_SEGMENT_KEY: function() {\n        return PAGE_SEGMENT_KEY;\n    },\n    addSearchParamsIfPageSegment: function() {\n        return addSearchParamsIfPageSegment;\n    },\n    computeSelectedLayoutSegment: function() {\n        return computeSelectedLayoutSegment;\n    },\n    getSegmentValue: function() {\n        return getSegmentValue;\n    },\n    getSelectedLayoutSegmentPath: function() {\n        return getSelectedLayoutSegmentPath;\n    },\n    isGroupSegment: function() {\n        return isGroupSegment;\n    },\n    isParallelRouteSegment: function() {\n        return isParallelRouteSegment;\n    }\n});\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nfunction isGroupSegment(segment) {\n    // Use array[0] for performant purpose\n    return segment[0] === '(' && segment.endsWith(')');\n}\nfunction isParallelRouteSegment(segment) {\n    return segment.startsWith('@') && segment !== '@children';\n}\nfunction addSearchParamsIfPageSegment(segment, searchParams) {\n    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);\n    if (isPageSegment) {\n        const stringifiedQuery = JSON.stringify(searchParams);\n        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\nfunction computeSelectedLayoutSegment(segments, parallelRouteKey) {\n    if (!segments || segments.length === 0) {\n        return null;\n    }\n    // For 'children', use first segment; for other parallel routes, use last segment\n    const rawSegment = parallelRouteKey === 'children' ? segments[0] : segments[segments.length - 1];\n    // If the default slot is showing, return null since it's not technically \"selected\" (it's a fallback)\n    // Returning an internal value like `__DEFAULT__` would be confusing\n    return rawSegment === DEFAULT_SEGMENT_KEY ? null : rawSegment;\n}\nfunction getSelectedLayoutSegmentPath(tree, parallelRouteKey, first = true, segmentPath = []) {\n    let node;\n    if (first) {\n        // Use the provided parallel route key on the first parallel route\n        node = tree[1][parallelRouteKey];\n    } else {\n        // After first parallel route prefer children, if there's no children pick the first parallel route.\n        const parallelRoutes = tree[1];\n        node = parallelRoutes.children ?? Object.values(parallelRoutes)[0];\n    }\n    if (!node) return segmentPath;\n    const segment = node[0];\n    let segmentValue = getSegmentValue(segment);\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\n        return segmentPath;\n    }\n    segmentPath.push(segmentValue);\n    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);\n}\nconst PAGE_SEGMENT_KEY = '__PAGE__';\nconst DEFAULT_SEGMENT_KEY = '__DEFAULT__';\n\n//# sourceMappingURL=segment.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,qBAAqB;IACrB,kBAAkB;IAClB,8BAA8B;IAC9B,8BAA8B;IAC9B,iBAAiB;IACjB,8BAA8B;IAC9B,gBAAgB;IAChB,wBAAwB;AAC5B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,qBAAqB;QACjB,OAAO;IACX;IACA,kBAAkB;QACd,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,wBAAwB;QACpB,OAAO;IACX;AACJ;AACA,SAAS,gBAAgB,OAAO;IAC5B,OAAO,MAAM,OAAO,CAAC,WAAW,OAAO,CAAC,EAAE,GAAG;AACjD;AACA,SAAS,eAAe,OAAO;IAC3B,sCAAsC;IACtC,OAAO,OAAO,CAAC,EAAE,KAAK,OAAO,QAAQ,QAAQ,CAAC;AAClD;AACA,SAAS,uBAAuB,OAAO;IACnC,OAAO,QAAQ,UAAU,CAAC,QAAQ,YAAY;AAClD;AACA,SAAS,6BAA6B,OAAO,EAAE,YAAY;IACvD,MAAM,gBAAgB,QAAQ,QAAQ,CAAC;IACvC,IAAI,eAAe;QACf,MAAM,mBAAmB,KAAK,SAAS,CAAC;QACxC,OAAO,qBAAqB,OAAO,mBAAmB,MAAM,mBAAmB;IACnF;IACA,OAAO;AACX;AACA,SAAS,6BAA6B,QAAQ,EAAE,gBAAgB;IAC5D,IAAI,CAAC,YAAY,SAAS,MAAM,KAAK,GAAG;QACpC,OAAO;IACX;IACA,iFAAiF;IACjF,MAAM,aAAa,qBAAqB,aAAa,QAAQ,CAAC,EAAE,GAAG,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE;IAChG,sGAAsG;IACtG,oEAAoE;IACpE,OAAO,eAAe,sBAAsB,OAAO;AACvD;AACA,SAAS,6BAA6B,IAAI,EAAE,gBAAgB,EAAE,QAAQ,IAAI,EAAE,cAAc,EAAE;IACxF,IAAI;IACJ,IAAI,OAAO;QACP,kEAAkE;QAClE,OAAO,IAAI,CAAC,EAAE,CAAC,iBAAiB;IACpC,OAAO;QACH,oGAAoG;QACpG,MAAM,iBAAiB,IAAI,CAAC,EAAE;QAC9B,OAAO,eAAe,QAAQ,IAAI,OAAO,MAAM,CAAC,eAAe,CAAC,EAAE;IACtE;IACA,IAAI,CAAC,MAAM,OAAO;IAClB,MAAM,UAAU,IAAI,CAAC,EAAE;IACvB,IAAI,eAAe,gBAAgB;IACnC,IAAI,CAAC,gBAAgB,aAAa,UAAU,CAAC,mBAAmB;QAC5D,OAAO;IACX;IACA,YAAY,IAAI,CAAC;IACjB,OAAO,6BAA6B,MAAM,kBAAkB,OAAO;AACvE;AACA,MAAM,mBAAmB;AACzB,MAAM,sBAAsB,eAE5B,mCAAmC","ignoreList":[0]}},
    {"offset": {"line": 1488, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    HEAD_REQUEST_KEY: null,\n    ROOT_SEGMENT_REQUEST_KEY: null,\n    appendSegmentRequestKeyPart: null,\n    convertSegmentPathToStaticExportFilename: null,\n    createSegmentRequestKeyPart: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    HEAD_REQUEST_KEY: function() {\n        return HEAD_REQUEST_KEY;\n    },\n    ROOT_SEGMENT_REQUEST_KEY: function() {\n        return ROOT_SEGMENT_REQUEST_KEY;\n    },\n    appendSegmentRequestKeyPart: function() {\n        return appendSegmentRequestKeyPart;\n    },\n    convertSegmentPathToStaticExportFilename: function() {\n        return convertSegmentPathToStaticExportFilename;\n    },\n    createSegmentRequestKeyPart: function() {\n        return createSegmentRequestKeyPart;\n    }\n});\nconst _segment = require(\"../segment\");\nconst ROOT_SEGMENT_REQUEST_KEY = '';\nconst HEAD_REQUEST_KEY = '/_head';\nfunction createSegmentRequestKeyPart(segment) {\n    if (typeof segment === 'string') {\n        if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // The Flight Router State type sometimes includes the search params in\n            // the page segment. However, the Segment Cache tracks this as a separate\n            // key. So, we strip the search params here, and then add them back when\n            // the cache entry is turned back into a FlightRouterState. This is an\n            // unfortunate consequence of the FlightRouteState being used both as a\n            // transport type and as a cache key; we'll address this once more of the\n            // Segment Cache implementation has settled.\n            // TODO: We should hoist the search params out of the FlightRouterState\n            // type entirely, This is our plan for dynamic route params, too.\n            return _segment.PAGE_SEGMENT_KEY;\n        }\n        const safeName = // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n        // But params typically don't include the leading slash. We should use\n        // a different encoding to avoid this special case.\n        segment === '/_not-found' ? '_not-found' : encodeToFilesystemAndURLSafeString(segment);\n        // Since this is not a dynamic segment, it's fully encoded. It does not\n        // need to be \"hydrated\" with a param value.\n        return safeName;\n    }\n    const name = segment[0];\n    const paramType = segment[2];\n    const safeName = encodeToFilesystemAndURLSafeString(name);\n    const encodedName = '$' + paramType + '$' + safeName;\n    return encodedName;\n}\nfunction appendSegmentRequestKeyPart(parentRequestKey, parallelRouteKey, childRequestKeyPart) {\n    // Aside from being filesystem safe, segment keys are also designed so that\n    // each segment and parallel route creates its own subdirectory. Roughly in\n    // the same shape as the source app directory. This is mostly just for easier\n    // debugging (you can open up the build folder and navigate the output); if\n    // we wanted to do we could just use a flat structure.\n    // Omit the parallel route key for children, since this is the most\n    // common case. Saves some bytes (and it's what the app directory does).\n    const slotKey = parallelRouteKey === 'children' ? childRequestKeyPart : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`;\n    return parentRequestKey + '/' + slotKey;\n}\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/;\nfunction encodeToFilesystemAndURLSafeString(value) {\n    if (simpleParamValueRegex.test(value)) {\n        return value;\n    }\n    // If there are any unsafe characters, base64url-encode the entire value.\n    // We also add a ! prefix so it doesn't collide with the simple case.\n    const base64url = btoa(value).replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n    ;\n    return '!' + base64url;\n}\nfunction convertSegmentPathToStaticExportFilename(segmentPath) {\n    return `__next${segmentPath.replace(/\\//g, '.')}.txt`;\n}\n\n//# sourceMappingURL=segment-value-encoding.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,kBAAkB;IAClB,0BAA0B;IAC1B,6BAA6B;IAC7B,0CAA0C;IAC1C,6BAA6B;AACjC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,kBAAkB;QACd,OAAO;IACX;IACA,0BAA0B;QACtB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,0CAA0C;QACtC,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,2BAA2B;AACjC,MAAM,mBAAmB;AACzB,SAAS,4BAA4B,OAAO;IACxC,IAAI,OAAO,YAAY,UAAU;QAC7B,IAAI,QAAQ,UAAU,CAAC,SAAS,gBAAgB,GAAG;YAC/C,uEAAuE;YACvE,yEAAyE;YACzE,wEAAwE;YACxE,sEAAsE;YACtE,uEAAuE;YACvE,yEAAyE;YACzE,4CAA4C;YAC5C,uEAAuE;YACvE,iEAAiE;YACjE,OAAO,SAAS,gBAAgB;QACpC;QACA,MAAM,WACN,sEAAsE;QACtE,mDAAmD;QACnD,YAAY,gBAAgB,eAAe,mCAAmC;QAC9E,uEAAuE;QACvE,4CAA4C;QAC5C,OAAO;IACX;IACA,MAAM,OAAO,OAAO,CAAC,EAAE;IACvB,MAAM,YAAY,OAAO,CAAC,EAAE;IAC5B,MAAM,WAAW,mCAAmC;IACpD,MAAM,cAAc,MAAM,YAAY,MAAM;IAC5C,OAAO;AACX;AACA,SAAS,4BAA4B,gBAAgB,EAAE,gBAAgB,EAAE,mBAAmB;IACxF,2EAA2E;IAC3E,2EAA2E;IAC3E,6EAA6E;IAC7E,2EAA2E;IAC3E,sDAAsD;IACtD,mEAAmE;IACnE,wEAAwE;IACxE,MAAM,UAAU,qBAAqB,aAAa,sBAAsB,CAAC,CAAC,EAAE,mCAAmC,kBAAkB,CAAC,EAAE,qBAAqB;IACzJ,OAAO,mBAAmB,MAAM;AACpC;AACA,8EAA8E;AAC9E,0EAA0E;AAC1E,gFAAgF;AAChF,gFAAgF;AAChF,wDAAwD;AACxD,MAAM,wBAAwB;AAC9B,SAAS,mCAAmC,KAAK;IAC7C,IAAI,sBAAsB,IAAI,CAAC,QAAQ;QACnC,OAAO;IACX;IACA,yEAAyE;IACzE,qEAAqE;IACrE,MAAM,YAAY,KAAK,OAAO,OAAO,CAAC,OAAO,KAAK,uBAAuB;KACxE,OAAO,CAAC,OAAO,KAAK,uBAAuB;KAC3C,OAAO,CAAC,OAAO,IAAI,sBAAsB;;IAE1C,OAAO,MAAM;AACjB;AACA,SAAS,yCAAyC,WAAW;IACzD,OAAO,CAAC,MAAM,EAAE,YAAY,OAAO,CAAC,OAAO,KAAK,IAAI,CAAC;AACzD,EAEA,kDAAkD","ignoreList":[0]}},
    {"offset": {"line": 1587, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/route-params.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    doesStaticSegmentAppearInURL: null,\n    getCacheKeyForDynamicParam: null,\n    getParamValueFromCacheKey: null,\n    getRenderedPathname: null,\n    getRenderedSearch: null,\n    parseDynamicParamFromURLPart: null,\n    urlSearchParamsToParsedUrlQuery: null,\n    urlToUrlWithoutFlightMarker: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlSearchParamsToParsedUrlQuery: function() {\n        return urlSearchParamsToParsedUrlQuery;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = require(\"../shared/lib/segment\");\nconst _segmentvalueencoding = require(\"../shared/lib/segment-cache/segment-value-encoding\");\nconst _approuterheaders = require(\"./components/app-router-headers\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (process.env.NODE_ENV === 'production') {\n        if (process.env.__NEXT_CONFIG_OUTPUT === 'export' && urlWithoutFlightParameters.pathname.endsWith('.txt')) {\n            const { pathname } = urlWithoutFlightParameters;\n            const length = pathname.endsWith('/index.txt') ? 10 : 4;\n            // Slice off `/index.txt` or `.txt` from the end of the pathname\n            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);\n        }\n    }\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nfunction urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=route-params.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1813, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createHrefFromUrl\", {\n    enumerable: true,\n    get: function() {\n        return createHrefFromUrl;\n    }\n});\nfunction createHrefFromUrl(url, includeHash = true) {\n    return url.pathname + url.search + (includeHash ? url.hash : '');\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=create-href-from-url.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,qBAAqB;IAChD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,kBAAkB,GAAG,EAAE,cAAc,IAAI;IAC9C,OAAO,IAAI,QAAQ,GAAG,IAAI,MAAM,GAAG,CAAC,cAAc,IAAI,IAAI,GAAG,EAAE;AACnE;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 1836, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/flight-data-helpers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createInitialRSCPayloadFromFallbackPrerender: null,\n    getFlightDataPartsFromPath: null,\n    getNextFlightSegmentPath: null,\n    normalizeFlightData: null,\n    prepareFlightRouterStateForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createInitialRSCPayloadFromFallbackPrerender: function() {\n        return createInitialRSCPayloadFromFallbackPrerender;\n    },\n    getFlightDataPartsFromPath: function() {\n        return getFlightDataPartsFromPath;\n    },\n    getNextFlightSegmentPath: function() {\n        return getNextFlightSegmentPath;\n    },\n    normalizeFlightData: function() {\n        return normalizeFlightData;\n    },\n    prepareFlightRouterStateForRequest: function() {\n        return prepareFlightRouterStateForRequest;\n    }\n});\nconst _segment = require(\"../shared/lib/segment\");\nconst _routeparams = require(\"./route-params\");\nconst _createhreffromurl = require(\"./components/router-reducer/create-href-from-url\");\nfunction getFlightDataPartsFromPath(flightDataPath) {\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n    const flightDataPathLength = 4;\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\n    return {\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\n        pathToSegment: segmentPath.slice(0, -1),\n        segmentPath,\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n        // in which case we default to ''.\n        segment: segmentPath[segmentPath.length - 1] ?? '',\n        tree,\n        seedData,\n        head,\n        isHeadPartial,\n        isRootRender: flightDataPath.length === flightDataPathLength\n    };\n}\nfunction createInitialRSCPayloadFromFallbackPrerender(response, fallbackInitialRSCPayload) {\n    // This is a static fallback page. In order to hydrate the page, we need to\n    // parse the client params from the URL, but to account for the possibility\n    // that the page was rewritten, we need to check the response headers\n    // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n    // we can't access the headers of the initial document response, the client\n    // performs a fetch request to the current location. Since it's possible that\n    // the fetch request will be dynamically rewritten to a different path than\n    // the initial document, this fetch request delivers _all_ the hydration data\n    // for the page; it was not inlined into the document, like it normally\n    // would be.\n    //\n    // TODO: Consider treating the case where fetch is rewritten to a different\n    // path from the document as a special deopt case. We should optimistically\n    // assume this won't happen, inline the data into the document, and perform\n    // a minimal request (like a HEAD or range request) to verify that the\n    // response matches. Tricky to get right because we need to account for\n    // all the different deployment environments we support, like output:\n    // \"export\" mode, where we currently don't assume that custom response\n    // headers are present.\n    // Patch the Flight data sent by the server with the correct params parsed\n    // from the URL + response object.\n    const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(new URL(location.href));\n    const originalFlightDataPath = fallbackInitialRSCPayload.f[0];\n    const originalFlightRouterState = originalFlightDataPath[0];\n    return {\n        b: fallbackInitialRSCPayload.b,\n        c: canonicalUrl.split('/'),\n        q: renderedSearch,\n        i: fallbackInitialRSCPayload.i,\n        f: [\n            [\n                fillInFallbackFlightRouterState(originalFlightRouterState, renderedPathname, renderedSearch),\n                originalFlightDataPath[1],\n                originalFlightDataPath[2],\n                originalFlightDataPath[2]\n            ]\n        ],\n        m: fallbackInitialRSCPayload.m,\n        G: fallbackInitialRSCPayload.G,\n        S: fallbackInitialRSCPayload.S\n    };\n}\nfunction fillInFallbackFlightRouterState(flightRouterState, renderedPathname, renderedSearch) {\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    return fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, index);\n}\nfunction fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, pathnamePartsIndex) {\n    const originalSegment = flightRouterState[0];\n    let newSegment;\n    let doesAppearInURL;\n    if (typeof originalSegment === 'string') {\n        newSegment = originalSegment;\n        doesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(originalSegment);\n    } else {\n        const paramName = originalSegment[0];\n        const paramType = originalSegment[2];\n        const paramValue = (0, _routeparams.parseDynamicParamFromURLPart)(paramType, pathnameParts, pathnamePartsIndex);\n        const cacheKey = (0, _routeparams.getCacheKeyForDynamicParam)(paramValue, renderedSearch);\n        newSegment = [\n            paramName,\n            cacheKey,\n            paramType\n        ];\n        doesAppearInURL = true;\n    }\n    // Only increment the index if the segment appears in the URL. If it's a\n    // \"virtual\" segment, like a route group, it remains the same.\n    const childPathnamePartsIndex = doesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n    const children = flightRouterState[1];\n    const newChildren = {};\n    for(let key in children){\n        const childFlightRouterState = children[key];\n        newChildren[key] = fillInFallbackFlightRouterStateImpl(childFlightRouterState, renderedSearch, pathnameParts, childPathnamePartsIndex);\n    }\n    const newState = [\n        newSegment,\n        newChildren,\n        null,\n        flightRouterState[3],\n        flightRouterState[4]\n    ];\n    return newState;\n}\nfunction getNextFlightSegmentPath(flightSegmentPath) {\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n    // to get the next segment path.\n    return flightSegmentPath.slice(2);\n}\nfunction normalizeFlightData(flightData) {\n    // FlightData can be a string when the server didn't respond with a proper flight response,\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n    if (typeof flightData === 'string') {\n        return flightData;\n    }\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\n}\nfunction prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\n    // HMR requests need the complete, unmodified state for proper functionality\n    if (isHmrRefresh) {\n        return encodeURIComponent(JSON.stringify(flightRouterState));\n    }\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\n}\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\n    // __PAGE__ segments are always fetched from the server, so there's\n    // no need to send them up\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\n    // Recursively process parallel routes\n    const cleanedParallelRoutes = {};\n    for (const [key, childState] of Object.entries(parallelRoutes)){\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\n    }\n    const result = [\n        cleanedSegment,\n        cleanedParallelRoutes,\n        null,\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\n    ];\n    // Append optional fields if present\n    if (isRootLayout !== undefined) {\n        result[4] = isRootLayout;\n    }\n    if (hasLoadingBoundary !== undefined) {\n        result[5] = hasLoadingBoundary;\n    }\n    return result;\n}\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */ function stripSearchParamsFromPageSegment(segment) {\n    if (typeof segment === 'string' && segment.startsWith(_segment.PAGE_SEGMENT_KEY + '?')) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */ function shouldPreserveRefreshMarker(refreshMarker) {\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=flight-data-helpers.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2057, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-build-id.js"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getAppBuildId: null,\n    setAppBuildId: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getAppBuildId: function() {\n        return getAppBuildId;\n    },\n    setAppBuildId: function() {\n        return setAppBuildId;\n    }\n});\nlet globalBuildId = '';\nfunction setAppBuildId(buildId) {\n    globalBuildId = buildId;\n}\nfunction getAppBuildId() {\n    return globalBuildId;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-build-id.js.map"],"names":[],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AACtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;AAE7E,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,eAAe;AACnB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,eAAe;QACX,OAAO;IACX;AACJ;AACA,IAAI,gBAAgB;AACpB,SAAS,cAAc,OAAO;IAC1B,gBAAgB;AACpB;AACA,SAAS;IACL,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 2108, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/hash.js"],"sourcesContent":["// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    djb2Hash: null,\n    hexHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    djb2Hash: function() {\n        return djb2Hash;\n    },\n    hexHash: function() {\n        return hexHash;\n    }\n});\nfunction djb2Hash(str) {\n    let hash = 5381;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) + hash + char & 0xffffffff;\n    }\n    return hash >>> 0;\n}\nfunction hexHash(str) {\n    return djb2Hash(str).toString(36).slice(0, 5);\n}\n\n//# sourceMappingURL=hash.js.map"],"names":[],"mappings":"AAAA,wCAAwC;AACxC,4CAA4C;AAC5C,iHAAiH;AACjH,wFAAwF;AACxF,gGAAgG;AAChG,wHAAwH;AACxH,wDAAwD;AAExD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,UAAU;IACV,SAAS;AACb,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,UAAU;QACN,OAAO;IACX;IACA,SAAS;QACL,OAAO;IACX;AACJ;AACA,SAAS,SAAS,GAAG;IACjB,IAAI,OAAO;IACX,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAI;QAC/B,MAAM,OAAO,IAAI,UAAU,CAAC;QAC5B,OAAO,CAAC,QAAQ,CAAC,IAAI,OAAO,OAAO;IACvC;IACA,OAAO,SAAS;AACpB;AACA,SAAS,QAAQ,GAAG;IAChB,OAAO,SAAS,KAAK,QAAQ,CAAC,IAAI,KAAK,CAAC,GAAG;AAC/C,EAEA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 2151, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"computeCacheBustingSearchParam\", {\n    enumerable: true,\n    get: function() {\n        return computeCacheBustingSearchParam;\n    }\n});\nconst _hash = require(\"../../hash\");\nfunction computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {\n    if ((prefetchHeader === undefined || prefetchHeader === '0') && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {\n        return '';\n    }\n    return (0, _hash.hexHash)([\n        prefetchHeader || '0',\n        segmentPrefetchHeader || '0',\n        stateTreeHeader || '0',\n        nextUrlHeader || '0'\n    ].join(','));\n}\n\n//# sourceMappingURL=cache-busting-search-param.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kCAAkC;IAC7D,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,+BAA+B,cAAc,EAAE,qBAAqB,EAAE,eAAe,EAAE,aAAa;IACzG,IAAI,CAAC,mBAAmB,aAAa,mBAAmB,GAAG,KAAK,0BAA0B,aAAa,oBAAoB,aAAa,kBAAkB,WAAW;QACjK,OAAO;IACX;IACA,OAAO,CAAC,GAAG,MAAM,OAAO,EAAE;QACtB,kBAAkB;QAClB,yBAAyB;QACzB,mBAAmB;QACnB,iBAAiB;KACpB,CAAC,IAAI,CAAC;AACX,EAEA,sDAAsD","ignoreList":[0]}},
    {"offset": {"line": 2176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    setCacheBustingSearchParam: null,\n    setCacheBustingSearchParamWithHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    setCacheBustingSearchParam: function() {\n        return setCacheBustingSearchParam;\n    },\n    setCacheBustingSearchParamWithHash: function() {\n        return setCacheBustingSearchParamWithHash;\n    }\n});\nconst _cachebustingsearchparam = require(\"../../../shared/lib/router/utils/cache-busting-search-param\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);\n    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);\n};\nconst setCacheBustingSearchParamWithHash = (url, hash)=>{\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    // Always remove any existing cache busting param and add a fresh one to ensure\n    // we have the correct value based on current request headers\n    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=`));\n    if (hash.length > 0) {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=${hash}`);\n    } else {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}`);\n    }\n    url.search = pairs.length ? `?${pairs.join('&')}` : '';\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=set-cache-busting-search-param.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,4BAA4B;IAC5B,oCAAoC;AACxC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,4BAA4B;QACxB,OAAO;IACX;IACA,oCAAoC;QAChC,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,6BAA6B,CAAC,KAAK;IACrC,MAAM,iBAAiB,CAAC,GAAG,yBAAyB,8BAA8B,EAAE,OAAO,CAAC,kBAAkB,2BAA2B,CAAC,EAAE,OAAO,CAAC,kBAAkB,mCAAmC,CAAC,EAAE,OAAO,CAAC,kBAAkB,6BAA6B,CAAC,EAAE,OAAO,CAAC,kBAAkB,QAAQ,CAAC;IACzS,mCAAmC,KAAK;AAC5C;AACA,MAAM,qCAAqC,CAAC,KAAK;IAC7C;;;;;;;;;;GAUD,GAAG,MAAM,iBAAiB,IAAI,MAAM;IACnC,MAAM,WAAW,eAAe,UAAU,CAAC,OAAO,eAAe,KAAK,CAAC,KAAK;IAC5E,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAM,QAAQ,SAAS,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,OAAO,QAAQ,CAAC,KAAK,UAAU,CAAC,GAAG,kBAAkB,oBAAoB,CAAC,CAAC,CAAC;IACtH,IAAI,KAAK,MAAM,GAAG,GAAG;QACjB,MAAM,IAAI,CAAC,GAAG,kBAAkB,oBAAoB,CAAC,CAAC,EAAE,MAAM;IAClE,OAAO;QACH,MAAM,IAAI,CAAC,GAAG,kBAAkB,oBAAoB,EAAE;IAC1D;IACA,IAAI,MAAM,GAAG,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC,MAAM,GAAG;AACxD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0DAA0D","ignoreList":[0]}},
    {"offset": {"line": 2237, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createFetch: null,\n    createFromNextReadableStream: null,\n    fetchServerResponse: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = require(\"react-server-dom-webpack/client\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst _appcallserver = require(\"../../app-call-server\");\nconst _appfindsourcemapurl = require(\"../../app-find-source-map-url\");\nconst _routerreducertypes = require(\"./router-reducer-types\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nconst _appbuildid = require(\"../../app-build-id\");\nconst _setcachebustingsearchparam = require(\"./set-cache-busting-search-param\");\nconst _routeparams = require(\"../../route-params\");\nconst createFromReadableStream = _client.createFromReadableStream;\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL) {\n    createDebugChannel = require('../../dev/debug-channel').createDebugChannel;\n}\nfunction doMpaNavigation(url) {\n    return (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString();\n}\nlet isPageUnloading = false;\nif (typeof window !== 'undefined') {\n    // Track when the page is unloading, e.g. due to reloading the page or\n    // performing hard navigations. This allows us to suppress error logging when\n    // the browser cancels in-flight requests during page unload.\n    window.addEventListener('pagehide', ()=>{\n        isPageUnloading = true;\n    });\n    // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n    // execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        isPageUnloading = false;\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    // In static export mode, we need to modify the URL to request the .txt file,\n    // but we should preserve the original URL for the canonical URL and error handling.\n    const originalUrl = url;\n    try {\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                // In \"output: export\" mode, we can't rely on headers to distinguish\n                // between HTML and RSC requests. Instead, we append an extra prefix\n                // to the request.\n                url = new URL(url);\n                if (url.pathname.endsWith('/')) {\n                    url.pathname += 'index.txt';\n                } else {\n                    url.pathname += '.txt';\n                }\n            }\n        }\n        // Typically, during a navigation, we decode the response using Flight's\n        // `createFromFetch` API, which accepts a `fetch` promise.\n        // TODO: Remove this check once the old PPR flag is removed\n        const isLegacyPPR = process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS;\n        const shouldImmediatelyDecode = !isLegacyPPR;\n        const res = await createFetch(url, headers, fetchPriority, shouldImmediatelyDecode);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!res.headers.get('vary')?.includes(_approuterheaders.NEXT_URL);\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                if (!isFlightResponse) {\n                    isFlightResponse = contentType.startsWith('text/plain');\n                }\n            }\n        }\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        // TODO: This needs to happen in the Flight Client.\n        // Or Webpack needs to include the runtime update in the Flight response as\n        // a blocking script.\n        if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n            await require('../../dev/hot-reloader/app/hot-reloader-app').waitForWebpackRuntimeHotUpdate();\n        }\n        let flightResponsePromise = res.flightResponse;\n        if (flightResponsePromise === null) {\n            // Typically, `createFetch` would have already started decoding the\n            // Flight response. If it hasn't, though, we need to decode it now.\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n            // without Cache Components). Remove this branch once legacy PPR\n            // is deleted.\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\n        }\n        const flightResponse = await flightResponsePromise;\n        if ((0, _appbuildid.getAppBuildId)() !== flightResponse.b) {\n            return doMpaNavigation(res.url);\n        }\n        const normalizedFlightData = (0, _flightdatahelpers.normalizeFlightData)(flightResponse.f);\n        if (typeof normalizedFlightData === 'string') {\n            return doMpaNavigation(normalizedFlightData);\n        }\n        return {\n            flightData: normalizedFlightData,\n            canonicalUrl: canonicalUrl,\n            renderedSearch: (0, _routeparams.getRenderedSearch)(res),\n            couldBeIntercepted: interception,\n            prerendered: flightResponse.S,\n            postponed,\n            staleTime,\n            debugInfo: flightResponsePromise._debugInfo ?? null\n        };\n    } catch (err) {\n        if (!isPageUnloading) {\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return originalUrl.toString();\n    }\n}\nasync function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n        headers['Next-Test-Fetch-Priority'] = fetchPriority;\n    }\n    if (process.env.NEXT_DEPLOYMENT_ID) {\n        headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\n    // Immediately pass the fetch promise to the Flight client so that the debug\n    // info includes the latency from the client to the server. The internal timer\n    // in React starts as soon as `createFromFetch` is called.\n    //\n    // The only case where we don't do this is during a prefetch, because we have\n    // to do some extra processing of the response stream (see\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n    // prefetch response never blocks a navigation; if it hasn't already been\n    // written into the cache by the time the navigation happens, the router will\n    // go straight to a dynamic request.\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n    let browserResponse = await fetchPromise;\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid  when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n        // This is to prevent a redirect loop. Same limit used by Chrome.\n        const MAX_REDIRECTS = 20;\n        for(let n = 0; n < MAX_REDIRECTS; n++){\n            if (!browserResponse.redirected) {\n                break;\n            }\n            const responseUrl = new URL(browserResponse.url, fetchUrl);\n            if (responseUrl.origin !== fetchUrl.origin) {\n                break;\n            }\n            if (responseUrl.searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY) === fetchUrl.searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY)) {\n                break;\n            }\n            // The RSC request was redirected. Assume the response is invalid.\n            //\n            // Append the cache busting search param to the redirected URL and\n            // fetch again.\n            // TODO: We should abort the previous request.\n            fetchUrl = new URL(responseUrl);\n            (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n            fetchPromise = fetch(fetchUrl, fetchOptions);\n            flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n            browserResponse = await fetchPromise;\n            // We just performed a manual redirect, so this is now true.\n            redirected = true;\n        }\n    }\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status,\n        // This is the exact promise returned by `createFromFetch`. It contains\n        // debug information that we need to transfer to any derived promises that\n        // are later rendered by React.\n        flightResponse: flightResponsePromise\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream, requestHeaders) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\n    return createFromFetch(promiseForResponse, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=fetch-server-response.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,aAAa;IACb,8BAA8B;IAC9B,qBAAqB;AACzB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,aAAa;QACT,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,2BAA2B,QAAQ,wBAAwB;AACjE,MAAM,kBAAkB,QAAQ,eAAe;AAC/C,IAAI;AACJ;;AAGA,SAAS,gBAAgB,GAAG;IACxB,OAAO,CAAC,GAAG,aAAa,2BAA2B,EAAE,IAAI,IAAI,KAAK,SAAS,MAAM,GAAG,QAAQ;AAChG;AACA,IAAI,kBAAkB;AACtB;;AAaA,eAAe,oBAAoB,GAAG,EAAE,OAAO;IAC3C,MAAM,EAAE,iBAAiB,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG;IACrD,MAAM,UAAU;QACZ,yBAAyB;QACzB,CAAC,kBAAkB,UAAU,CAAC,EAAE;QAChC,mCAAmC;QACnC,CAAC,kBAAkB,6BAA6B,CAAC,EAAE,CAAC,GAAG,mBAAmB,kCAAkC,EAAE,mBAAmB,QAAQ,YAAY;IACzJ;IACA;;;;;GAKD,GAAG,IAAI,iBAAiB,oBAAoB,YAAY,CAAC,IAAI,EAAE;QAC1D,OAAO,CAAC,kBAAkB,2BAA2B,CAAC,GAAG;IAC7D;IACA,IAAI,oDAAyB,iBAAiB,QAAQ,YAAY,EAAE;QAChE,OAAO,CAAC,kBAAkB,uBAAuB,CAAC,GAAG;IACzD;IACA,IAAI,SAAS;QACT,OAAO,CAAC,kBAAkB,QAAQ,CAAC,GAAG;IAC1C;IACA,6EAA6E;IAC7E,oFAAoF;IACpF,MAAM,cAAc;IACpB,IAAI;QACA,wHAAwH;QACxH,4HAA4H;QAC5H,kEAAkE;QAClE,yHAAyH;QACzH,MAAM,gBAAgB,eAAe,iBAAiB,oBAAoB,YAAY,CAAC,SAAS,GAAG,SAAS,QAAQ;QACpH;;QAaA,wEAAwE;QACxE,0DAA0D;QAC1D,2DAA2D;QAC3D,MAAM,cAAc,2CAA0B;QAC9C,MAAM,0BAA0B,CAAC;QACjC,MAAM,MAAM,MAAM,YAAY,KAAK,SAAS,eAAe;QAC3D,MAAM,cAAc,CAAC,GAAG,aAAa,2BAA2B,EAAE,IAAI,IAAI,IAAI,GAAG;QACjF,MAAM,eAAe,IAAI,UAAU,GAAG,cAAc;QACpD,MAAM,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC,mBAAmB;QACvD,MAAM,eAAe,CAAC,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,SAAS,SAAS,kBAAkB,QAAQ;QACnF,MAAM,YAAY,CAAC,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,kBAAkB,wBAAwB;QAC9E,MAAM,yBAAyB,IAAI,OAAO,CAAC,GAAG,CAAC,kBAAkB,6BAA6B;QAC9F,MAAM,YAAY,2BAA2B,OAAO,SAAS,wBAAwB,MAAM,OAAO,CAAC;QACnG,IAAI,mBAAmB,YAAY,UAAU,CAAC,kBAAkB,uBAAuB;QACvF;;QAOA,4FAA4F;QAC5F,oEAAoE;QACpE,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,EAAE;YAC3C,2FAA2F;YAC3F,IAAI,IAAI,IAAI,EAAE;gBACV,YAAY,IAAI,GAAG,IAAI,IAAI;YAC/B;YACA,OAAO,gBAAgB,YAAY,QAAQ;QAC/C;QACA,uEAAuE;QACvE,0DAA0D;QAC1D,wDAAwD;QACxD,oGAAoG;QACpG,mDAAmD;QACnD,2EAA2E;QAC3E,qBAAqB;QACrB;;QAGA,IAAI,wBAAwB,IAAI,cAAc;QAC9C,IAAI,0BAA0B,MAAM;YAChC,mEAAmE;YACnE,mEAAmE;YACnE,yEAAyE;YACzE,gEAAgE;YAChE,cAAc;YACd,MAAM,eAAe,YAAY,8BAA8B,IAAI,IAAI,IAAI,IAAI,IAAI;YACnF,wBAAwB,6BAA6B,cAAc;QACvE;QACA,MAAM,iBAAiB,MAAM;QAC7B,IAAI,CAAC,GAAG,YAAY,aAAa,QAAQ,eAAe,CAAC,EAAE;YACvD,OAAO,gBAAgB,IAAI,GAAG;QAClC;QACA,MAAM,uBAAuB,CAAC,GAAG,mBAAmB,mBAAmB,EAAE,eAAe,CAAC;QACzF,IAAI,OAAO,yBAAyB,UAAU;YAC1C,OAAO,gBAAgB;QAC3B;QACA,OAAO;YACH,YAAY;YACZ,cAAc;YACd,gBAAgB,CAAC,GAAG,aAAa,iBAAiB,EAAE;YACpD,oBAAoB;YACpB,aAAa,eAAe,CAAC;YAC7B;YACA;YACA,WAAW,sBAAsB,UAAU,IAAI;QACnD;IACJ,EAAE,OAAO,KAAK;QACV,IAAI,CAAC,iBAAiB;YAClB,QAAQ,KAAK,CAAC,CAAC,gCAAgC,EAAE,YAAY,qCAAqC,CAAC,EAAE;QACzG;QACA,iDAAiD;QACjD,qHAAqH;QACrH,iGAAiG;QACjG,OAAO,YAAY,QAAQ;IAC/B;AACJ;AACA,eAAe,YAAY,GAAG,EAAE,OAAO,EAAE,aAAa,EAAE,uBAAuB,EAAE,MAAM;IACnF,6EAA6E;IAC7E,0DAA0D;IAC1D,uBAAuB;IACvB;;IAGA;;IAGA,wCAA2C;QACvC,IAAI,KAAK,QAAQ,EAAE;YACf,OAAO,CAAC,kBAAkB,2BAA2B,CAAC,GAAG,KAAK,QAAQ;QAC1E;QACA,yEAAyE;QACzE,wEAAwE;QACxE,yEAAyE;QACzE,OAAO,CAAC,kBAAkB,sBAAsB,CAAC,GAAG,OAAO,eAAe,CAAC,IAAI,YAAY,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAC;IAC/G;IACA,MAAM,eAAe;QACjB,wFAAwF;QACxF,aAAa;QACb;QACA,UAAU,iBAAiB;QAC3B;IACJ;IACA,6EAA6E;IAC7E,2EAA2E;IAC3E,yBAAyB;IACzB,IAAI,WAAW,IAAI,IAAI;IACvB,CAAC,GAAG,4BAA4B,0BAA0B,EAAE,UAAU;IACtE,IAAI,eAAe,MAAM,UAAU;IACnC,4EAA4E;IAC5E,8EAA8E;IAC9E,0DAA0D;IAC1D,EAAE;IACF,6EAA6E;IAC7E,0DAA0D;IAC1D,0EAA0E;IAC1E,yEAAyE;IACzE,6EAA6E;IAC7E,oCAAoC;IACpC,IAAI,wBAAwB,0BAA0B,oBAAoB,cAAc,WAAW;IACnG,IAAI,kBAAkB,MAAM;IAC5B,wEAAwE;IACxE,sEAAsE;IACtE,wEAAwE;IACxE,0EAA0E;IAC1E,6EAA6E;IAC7E,cAAc;IACd,EAAE;IACF,8EAA8E;IAC9E,6EAA6E;IAC7E,mCAAmC;IACnC,EAAE;IACF,yEAAyE;IACzE,8EAA8E;IAC9E,cAAc;IACd,EAAE;IACF,0EAA0E;IAC1E,8EAA8E;IAC9E,EAAE;IACF,wEAAwE;IACxE,0EAA0E;IAC1E,gDAAgD;IAChD,IAAI,aAAa,gBAAgB,UAAU;IAC3C;;IA4BA,6EAA6E;IAC7E,yCAAyC;IACzC,MAAM,cAAc,IAAI,IAAI,gBAAgB,GAAG,EAAE;IACjD,YAAY,YAAY,CAAC,MAAM,CAAC,kBAAkB,oBAAoB;IACtE,MAAM,cAAc;QAChB,KAAK,YAAY,IAAI;QACrB,sEAAsE;QACtE,qDAAqD;QACrD,wEAAwE;QACxE,oEAAoE;QACpE;QACA,qEAAqE;QACrE,wEAAwE;QACxE,6BAA6B;QAC7B,IAAI,gBAAgB,EAAE;QACtB,SAAS,gBAAgB,OAAO;QAChC,MAAM,gBAAgB,IAAI;QAC1B,QAAQ,gBAAgB,MAAM;QAC9B,uEAAuE;QACvE,0EAA0E;QAC1E,+BAA+B;QAC/B,gBAAgB;IACpB;IACA,OAAO;AACX;AACA,SAAS,6BAA6B,YAAY,EAAE,cAAc;IAC9D,OAAO,yBAAyB,cAAc;QAC1C,YAAY,eAAe,UAAU;QACrC,kBAAkB,qBAAqB,gBAAgB;QACvD,cAAc,sBAAsB,mBAAmB;IAC3D;AACJ;AACA,SAAS,oBAAoB,kBAAkB,EAAE,cAAc;IAC3D,OAAO,gBAAgB,oBAAoB;QACvC,YAAY,eAAe,UAAU;QACrC,kBAAkB,qBAAqB,gBAAgB;QACvD,cAAc,sBAAsB,mBAAmB;IAC3D;AACJ;AACA,SAAS,8BAA8B,oBAAoB;IACvD,0EAA0E;IAC1E,4EAA4E;IAC5E,uEAAuE;IACvE,0EAA0E;IAC1E,8DAA8D;IAC9D,2CAA2C;IAC3C,EAAE;IACF,2EAA2E;IAC3E,0EAA0E;IAC1E,8EAA8E;IAC9E,+BAA+B;IAC/B,MAAM,SAAS,qBAAqB,SAAS;IAC7C,OAAO,IAAI,eAAe;QACtB,MAAM,MAAM,UAAU;YAClB,MAAM,KAAK;gBACP,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO,IAAI;gBACzC,IAAI,CAAC,MAAM;oBACP,mEAAmE;oBACnE,mBAAmB;oBACnB,WAAW,OAAO,CAAC;oBACnB;gBACJ;gBACA,qEAAqE;gBACrE,qBAAqB;gBACrB;YACJ;QACJ;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 2533, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/lru.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    deleteFromLru: null,\n    lruPut: null,\n    updateLruSize: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    deleteFromLru: function() {\n        return deleteFromLru;\n    },\n    lruPut: function() {\n        return lruPut;\n    },\n    updateLruSize: function() {\n        return updateLruSize;\n    }\n});\nconst _cachemap = require(\"./cache-map\");\nlet head = null;\nlet didScheduleCleanup = false;\nlet lruSize = 0;\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n;\nfunction lruPut(node) {\n    if (head === node) {\n        // Already at the head\n        return;\n    }\n    const prev = node.prev;\n    const next = node.next;\n    if (next === null || prev === null) {\n        // This is an insertion\n        lruSize += node.size;\n        // Whenever we add an entry, we need to check if we've exceeded the\n        // max size. We don't evict entries immediately; they're evicted later in\n        // an asynchronous task.\n        ensureCleanupIsScheduled();\n    } else {\n        // This is a move. Remove from its current position.\n        prev.next = next;\n        next.prev = prev;\n    }\n    // Move to the front of the list\n    if (head === null) {\n        // This is the first entry\n        node.prev = node;\n        node.next = node;\n    } else {\n        // Add to the front of the list\n        const tail = head.prev;\n        node.prev = tail;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            tail.next = node;\n        }\n        node.next = head;\n        head.prev = node;\n    }\n    head = node;\n}\nfunction updateLruSize(node, newNodeSize) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size;\n    node.size = newNodeSize;\n    if (node.next === null) {\n        // This entry is not currently being tracked by the LRU.\n        return;\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize;\n    ensureCleanupIsScheduled();\n}\nfunction deleteFromLru(deleted) {\n    const next = deleted.next;\n    const prev = deleted.prev;\n    if (next !== null && prev !== null) {\n        lruSize -= deleted.size;\n        deleted.next = null;\n        deleted.prev = null;\n        // Remove from the list\n        if (head === deleted) {\n            // Update the head\n            if (next === head) {\n                // This was the last entry\n                head = null;\n            } else {\n                head = next;\n            }\n        } else {\n            prev.next = next;\n            next.prev = prev;\n        }\n    } else {\n    // Already deleted\n    }\n}\nfunction ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n        return;\n    }\n    didScheduleCleanup = true;\n    requestCleanupCallback(cleanup);\n}\nfunction cleanup() {\n    didScheduleCleanup = false;\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteFromLru` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9;\n    while(lruSize > ninetyPercentMax && head !== null){\n        const tail = head.prev;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            // Delete the entry from the map. In turn, this will remove it from\n            // the LRU.\n            (0, _cachemap.deleteFromCacheMap)(tail.value);\n        }\n    }\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=lru.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2676, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/cache-map.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    Fallback: null,\n    createCacheMap: null,\n    deleteFromCacheMap: null,\n    getFromCacheMap: null,\n    isValueExpired: null,\n    setInCacheMap: null,\n    setSizeInCacheMap: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Fallback: function() {\n        return Fallback;\n    },\n    createCacheMap: function() {\n        return createCacheMap;\n    },\n    deleteFromCacheMap: function() {\n        return deleteFromCacheMap;\n    },\n    getFromCacheMap: function() {\n        return getFromCacheMap;\n    },\n    isValueExpired: function() {\n        return isValueExpired;\n    },\n    setInCacheMap: function() {\n        return setInCacheMap;\n    },\n    setSizeInCacheMap: function() {\n        return setSizeInCacheMap;\n    }\n});\nconst _lru = require(\"./lru\");\nconst Fallback = {};\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {};\nfunction createCacheMap() {\n    const cacheMap = {\n        parent: null,\n        key: null,\n        value: null,\n        map: null,\n        // LRU-related fields\n        prev: null,\n        next: null,\n        size: 0\n    };\n    return cacheMap;\n}\nfunction getOrInitialize(cacheMap, keys, isRevalidation) {\n    // Go through each level of keys until we find the entry that matches, or\n    // create a new entry if one doesn't exist.\n    //\n    // This function will only return entries that match the keypath _exactly_.\n    // Unlike getWithFallback, it will not access fallback entries unless it's\n    // explicitly part of the keypath.\n    let entry = cacheMap;\n    let remainingKeys = keys;\n    let key = null;\n    while(true){\n        const previousKey = key;\n        if (remainingKeys !== null) {\n            key = remainingKeys.value;\n            remainingKeys = remainingKeys.parent;\n        } else if (isRevalidation && previousKey !== Revalidation) {\n            // During a revalidation, we append an internal \"Revalidation\" key to\n            // the end of the keypath. The \"normal\" entry is its parent.\n            // However, if the parent entry is currently empty, we don't need to store\n            // this as a revalidation entry. Just insert the revalidation into the\n            // normal slot.\n            if (entry.value === null) {\n                return entry;\n            }\n            // Otheriwse, create a child entry.\n            key = Revalidation;\n        } else {\n            break;\n        }\n        let map = entry.map;\n        if (map !== null) {\n            const existingEntry = map.get(key);\n            if (existingEntry !== undefined) {\n                // Found a match. Keep going.\n                entry = existingEntry;\n                continue;\n            }\n        } else {\n            map = new Map();\n            entry.map = map;\n        }\n        // No entry exists yet at this level. Create a new one.\n        const newEntry = {\n            parent: entry,\n            key,\n            value: null,\n            map: null,\n            // LRU-related fields\n            prev: null,\n            next: null,\n            size: 0\n        };\n        map.set(key, newEntry);\n        entry = newEntry;\n    }\n    return entry;\n}\nfunction getFromCacheMap(now, currentCacheVersion, rootEntry, keys, isRevalidation) {\n    const entry = getEntryWithFallbackImpl(now, currentCacheVersion, rootEntry, keys, isRevalidation, 0);\n    if (entry === null || entry.value === null) {\n        return null;\n    }\n    // This is an LRU access. Move the entry to the front of the list.\n    (0, _lru.lruPut)(entry);\n    return entry.value;\n}\nfunction isValueExpired(now, currentCacheVersion, value) {\n    return value.staleAt <= now || value.version < currentCacheVersion;\n}\nfunction lazilyEvictIfNeeded(now, currentCacheVersion, entry) {\n    // We have a matching entry, but before we can return it, we need to check if\n    // it's still fresh. Otherwise it should be treated the same as a cache miss.\n    if (entry.value === null) {\n        // This entry has no value, so there's nothing to evict.\n        return entry;\n    }\n    const value = entry.value;\n    if (isValueExpired(now, currentCacheVersion, value)) {\n        // The value expired. Lazily evict it from the cache, and return null. This\n        // is conceptually the same as a cache miss.\n        deleteMapEntry(entry);\n        return null;\n    }\n    // The matched entry has not expired. Return it.\n    return entry;\n}\nfunction getEntryWithFallbackImpl(now, currentCacheVersion, entry, keys, isRevalidation, previousKey) {\n    // This is similar to getExactEntry, but if an exact match is not found for\n    // a key, it will return the fallback entry instead. This is recursive at\n    // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n    // valid match for [a, b, c, d].\n    //\n    // It will return the most specific match available.\n    let key;\n    let remainingKeys;\n    if (keys !== null) {\n        key = keys.value;\n        remainingKeys = keys.parent;\n    } else if (isRevalidation && previousKey !== Revalidation) {\n        // During a revalidation, we append an internal \"Revalidation\" key to\n        // the end of the keypath.\n        key = Revalidation;\n        remainingKeys = null;\n    } else {\n        // There are no more keys. This is the terminal entry.\n        // TODO: When performing a lookup during a navigation, as opposed to a\n        // prefetch, we may want to skip entries that are Pending if there's also\n        // a Fulfilled fallback entry. Tricky to say, though, since if it's\n        // already pending, it's likely to stream in soon. Maybe we could do this\n        // just on slow connections and offline mode.\n        return lazilyEvictIfNeeded(now, currentCacheVersion, entry);\n    }\n    const map = entry.map;\n    if (map !== null) {\n        const existingEntry = map.get(key);\n        if (existingEntry !== undefined) {\n            // Found an exact match for this key. Keep searching.\n            const result = getEntryWithFallbackImpl(now, currentCacheVersion, existingEntry, remainingKeys, isRevalidation, key);\n            if (result !== null) {\n                return result;\n            }\n        }\n        // No match found for this key. Check if there's a fallback.\n        const fallbackEntry = map.get(Fallback);\n        if (fallbackEntry !== undefined) {\n            // Found a fallback for this key. Keep searching.\n            return getEntryWithFallbackImpl(now, currentCacheVersion, fallbackEntry, remainingKeys, isRevalidation, key);\n        }\n    }\n    return null;\n}\nfunction setInCacheMap(cacheMap, keys, value, isRevalidation) {\n    // Add a value to the map at the given keypath. If the value is already\n    // part of the map, it's removed from its previous keypath. (NOTE: This is\n    // unlike a regular JS map, but the behavior is intentional.)\n    const entry = getOrInitialize(cacheMap, keys, isRevalidation);\n    setMapEntryValue(entry, value);\n    // This is an LRU access. Move the entry to the front of the list.\n    (0, _lru.lruPut)(entry);\n    (0, _lru.updateLruSize)(entry, value.size);\n}\nfunction setMapEntryValue(entry, value) {\n    if (entry.value !== null) {\n        // There's already a value at the given keypath. Disconnect the old value\n        // from the map. We're not calling `deleteMapEntry` here because the\n        // entry itself is still in the map. We just want to overwrite its value.\n        dropRef(entry.value);\n        // Fill the entry with the updated value.\n        const emptyEntry = entry;\n        emptyEntry.value = null;\n        fillEmptyReference(emptyEntry, value);\n    } else {\n        fillEmptyReference(entry, value);\n    }\n}\nfunction fillEmptyReference(entry, value) {\n    // This value may already be in the map at a different keypath.\n    // Grab a reference before we overwrite it.\n    const oldEntry = value.ref;\n    const fullEntry = entry;\n    fullEntry.value = value;\n    value.ref = fullEntry;\n    (0, _lru.updateLruSize)(fullEntry, value.size);\n    if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n        // This value is already in the map at a different keypath in the map.\n        // Values only exist at a single keypath at a time. Remove it from the\n        // previous keypath.\n        //\n        // Note that only the internal map entry is garbage collected; we don't\n        // call `dropRef` here because it's still in the map, just\n        // at a new keypath (the one we just set, above).\n        deleteMapEntry(oldEntry);\n    }\n}\nfunction deleteFromCacheMap(value) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    dropRef(value);\n    deleteMapEntry(entry);\n}\nfunction dropRef(value) {\n    // Drop the value from the map by setting its `ref` backpointer to\n    // null. This is a separate operation from `deleteMapEntry` because when\n    // re-keying a value we need to be able to delete the old, internal map\n    // entry without garbage collecting the value itself.\n    value.ref = null;\n}\nfunction deleteMapEntry(entry) {\n    // Delete the entry from the cache.\n    const emptyEntry = entry;\n    emptyEntry.value = null;\n    (0, _lru.deleteFromLru)(entry);\n    // Check if we can garbage collect the entry.\n    const map = emptyEntry.map;\n    if (map === null) {\n        // Since this entry has no value, and also no child entries, we can\n        // garbage collect it. Remove it from its parent, and keep garbage\n        // collecting the parents until we reach a non-empty entry.\n        let parent = emptyEntry.parent;\n        let key = emptyEntry.key;\n        while(parent !== null){\n            const parentMap = parent.map;\n            if (parentMap !== null) {\n                parentMap.delete(key);\n                if (parentMap.size === 0) {\n                    // We just removed the last entry in the parent map.\n                    parent.map = null;\n                    if (parent.value === null) {\n                        // The parent node has no child entries, nor does it have a value\n                        // on itself. It can be garbage collected. Keep going.\n                        key = parent.key;\n                        parent = parent.parent;\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n    } else {\n        // Check if there's a revalidating entry. If so, promote it to a\n        // \"normal\" entry, since the normal one was just deleted.\n        const revalidatingEntry = map.get(Revalidation);\n        if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n            setMapEntryValue(emptyEntry, revalidatingEntry.value);\n        }\n    }\n}\nfunction setSizeInCacheMap(value, size) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    // Except during initialization (when the size is set to 0), this is the only\n    // place the `size` field should be updated, to ensure it's in sync with the\n    // the LRU.\n    value.size = size;\n    (0, _lru.updateLruSize)(entry, size);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=cache-map.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2988, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js"],"sourcesContent":["/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ensureLeadingSlash\", {\n    enumerable: true,\n    get: function() {\n        return ensureLeadingSlash;\n    }\n});\nfunction ensureLeadingSlash(path) {\n    return path.startsWith('/') ? path : `/${path}`;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map"],"names":[],"mappings":"AAAA;;;CAGC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,mBAAmB,IAAI;IAC5B,OAAO,KAAK,UAAU,CAAC,OAAO,OAAO,CAAC,CAAC,EAAE,MAAM;AACnD,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 3007, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/app-paths.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    normalizeAppPath: null,\n    normalizeRscURL: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    normalizeAppPath: function() {\n        return normalizeAppPath;\n    },\n    normalizeRscURL: function() {\n        return normalizeRscURL;\n    }\n});\nconst _ensureleadingslash = require(\"../../page-path/ensure-leading-slash\");\nconst _segment = require(\"../../segment\");\nfunction normalizeAppPath(route) {\n    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split('/').reduce((pathname, segment, index, segments)=>{\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if ((0, _segment.isGroupSegment)(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === '@') {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\n            return pathname;\n        }\n        return `${pathname}/${segment}`;\n    }, ''));\n}\nfunction normalizeRscURL(url) {\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\n    '$1');\n}\n\n//# sourceMappingURL=app-paths.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,kBAAkB;IAClB,iBAAiB;AACrB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,kBAAkB;QACd,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,iBAAiB,KAAK;IAC3B,OAAO,CAAC,GAAG,oBAAoB,kBAAkB,EAAE,MAAM,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,UAAU,SAAS,OAAO;QAClG,8BAA8B;QAC9B,IAAI,CAAC,SAAS;YACV,OAAO;QACX;QACA,sBAAsB;QACtB,IAAI,CAAC,GAAG,SAAS,cAAc,EAAE,UAAU;YACvC,OAAO;QACX;QACA,iCAAiC;QACjC,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK;YACpB,OAAO;QACX;QACA,uDAAuD;QACvD,IAAI,CAAC,YAAY,UAAU,YAAY,OAAO,KAAK,UAAU,SAAS,MAAM,GAAG,GAAG;YAC9E,OAAO;QACX;QACA,OAAO,GAAG,SAAS,CAAC,EAAE,SAAS;IACnC,GAAG;AACP;AACA,SAAS,gBAAgB,GAAG;IACxB,OAAO,IAAI,OAAO,CAAC,eACnB;AACJ,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 3058, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/interception-routes.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    INTERCEPTION_ROUTE_MARKERS: null,\n    extractInterceptionRouteInformation: null,\n    isInterceptionRouteAppPath: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERCEPTION_ROUTE_MARKERS: function() {\n        return INTERCEPTION_ROUTE_MARKERS;\n    },\n    extractInterceptionRouteInformation: function() {\n        return extractInterceptionRouteInformation;\n    },\n    isInterceptionRouteAppPath: function() {\n        return isInterceptionRouteAppPath;\n    }\n});\nconst _apppaths = require(\"./app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\n    '(..)(..)',\n    '(.)',\n    '(..)',\n    '(...)'\n];\nfunction isInterceptionRouteAppPath(path) {\n    // TODO-APP: add more serious validation\n    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n    let interceptingRoute;\n    let marker;\n    let interceptedRoute;\n    for (const segment of path.split('/')){\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n        if (marker) {\n            ;\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n            break;\n        }\n    }\n    if (!interceptingRoute || !marker || !interceptedRoute) {\n        throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`), \"__NEXT_ERROR_CODE\", {\n            value: \"E269\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n    ;\n    switch(marker){\n        case '(.)':\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n            if (interceptingRoute === '/') {\n                interceptedRoute = `/${interceptedRoute}`;\n            } else {\n                interceptedRoute = interceptingRoute + '/' + interceptedRoute;\n            }\n            break;\n        case '(..)':\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n            if (interceptingRoute === '/') {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E207\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\n            break;\n        case '(...)':\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n            interceptedRoute = '/' + interceptedRoute;\n            break;\n        case '(..)(..)':\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n            const splitInterceptingRoute = interceptingRoute.split('/');\n            if (splitInterceptingRoute.length <= 2) {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E486\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\n            break;\n        default:\n            throw Object.defineProperty(new Error('Invariant: unexpected marker'), \"__NEXT_ERROR_CODE\", {\n                value: \"E112\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n    return {\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n//# sourceMappingURL=interception-routes.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,4BAA4B;IAC5B,qCAAqC;IACrC,4BAA4B;AAChC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,4BAA4B;QACxB,OAAO;IACX;IACA,qCAAqC;QACjC,OAAO;IACX;IACA,4BAA4B;QACxB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,6BAA6B;IAC/B;IACA;IACA;IACA;CACH;AACD,SAAS,2BAA2B,IAAI;IACpC,wCAAwC;IACxC,OAAO,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,UAAU,2BAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC,SAAS;AAC5G;AACA,SAAS,oCAAoC,IAAI;IAC7C,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,WAAW,KAAK,KAAK,CAAC,KAAK;QAClC,SAAS,2BAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC;QACjE,IAAI,QAAQ;;YAER,CAAC,mBAAmB,iBAAiB,GAAG,KAAK,KAAK,CAAC,QAAQ;YAC3D;QACJ;IACJ;IACA,IAAI,CAAC,qBAAqB,CAAC,UAAU,CAAC,kBAAkB;QACpD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,iFAAiF,CAAC,GAAG,qBAAqB;YAChL,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,oBAAoB,CAAC,GAAG,UAAU,gBAAgB,EAAE,mBAAmB,iDAAiD;;IAExH,OAAO;QACH,KAAK;YACD,oIAAoI;YACpI,IAAI,sBAAsB,KAAK;gBAC3B,mBAAmB,CAAC,CAAC,EAAE,kBAAkB;YAC7C,OAAO;gBACH,mBAAmB,oBAAoB,MAAM;YACjD;YACA;QACJ,KAAK;YACD,uHAAuH;YACvH,IAAI,sBAAsB,KAAK;gBAC3B,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,4DAA4D,CAAC,GAAG,qBAAqB;oBAC3J,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;YACA,mBAAmB,kBAAkB,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,kBAAkB,IAAI,CAAC;YAC3F;QACJ,KAAK;YACD,kIAAkI;YAClI,mBAAmB,MAAM;YACzB;QACJ,KAAK;YACD,iIAAiI;YACjI,MAAM,yBAAyB,kBAAkB,KAAK,CAAC;YACvD,IAAI,uBAAuB,MAAM,IAAI,GAAG;gBACpC,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,+DAA+D,CAAC,GAAG,qBAAqB;oBAC9J,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;YACA,mBAAmB,uBAAuB,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,kBAAkB,IAAI,CAAC;YACrF;QACJ;YACI,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,iCAAiC,qBAAqB;gBACxF,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;IACR;IACA,OAAO;QACH;QACA;IACJ;AACJ,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 3167, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    computeChangedPath: null,\n    extractPathFromFlightRouterState: null,\n    getSelectedParams: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    computeChangedPath: function() {\n        return computeChangedPath;\n    },\n    extractPathFromFlightRouterState: function() {\n        return extractPathFromFlightRouterState;\n    },\n    getSelectedParams: function() {\n        return getSelectedParams;\n    }\n});\nconst _interceptionroutes = require(\"../../../shared/lib/router/utils/interception-routes\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _matchsegments = require(\"../match-segments\");\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === '/' ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === 'string') {\n        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n        if (segment === 'children') return '';\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === '' || (0, _segment.isGroupSegment)(segment)) {\n            return acc;\n        }\n        return `${acc}/${segment}`;\n    }, '') || '/';\n}\nfunction extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return '';\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    const parallelRoutes = flightRouterState[1] ?? {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === 'children') continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return '';\n    }\n    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return extractPathFromFlightRouterState(treeB) ?? '';\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return `${segmentToPathname(segmentB)}/${changedPath}`;\n            }\n        }\n    }\n    return null;\n}\nfunction computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === '/') {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split('/'));\n}\nfunction getSelectedParams(currentTree, params = {}) {\n    const parallelRoutes = currentTree[1];\n    for (const parallelRoute of Object.values(parallelRoutes)){\n        const segment = parallelRoute[0];\n        const isDynamicParameter = Array.isArray(segment);\n        const segmentValue = isDynamicParameter ? segment[1] : segment;\n        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;\n        // Ensure catchAll and optional catchall are turned into an array\n        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');\n        if (isCatchAll) {\n            params[segment[0]] = segment[1].split('/');\n        } else if (isDynamicParameter) {\n            params[segment[0]] = segment[1];\n        }\n        params = getSelectedParams(parallelRoute, params);\n    }\n    return params;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=compute-changed-path.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3297, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/handle-mutable.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"handleMutable\", {\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n});\nconst _computechangedpath = require(\"./compute-changed-path\");\nfunction isNotUndefined(value) {\n    return typeof value !== 'undefined';\n}\nfunction handleMutable(state, mutable) {\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = mutable.shouldScroll ?? true;\n    let previousNextUrl = state.previousNextUrl;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            previousNextUrl = nextUrl;\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    return {\n        // Set href.\n        canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n        renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable?.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: mutable.onlyHashChange || false,\n            hashFragment: shouldScroll ? // #top is handled in layout-router.\n            mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl,\n        previousNextUrl: previousNextUrl,\n        debugInfo: mutable.collectedDebugInfo ?? null\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=handle-mutable.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,iBAAiB;IAC5C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,eAAe,KAAK;IACzB,OAAO,OAAO,UAAU;AAC5B;AACA,SAAS,cAAc,KAAK,EAAE,OAAO;IACjC,0DAA0D;IAC1D,MAAM,eAAe,QAAQ,YAAY,IAAI;IAC7C,IAAI,kBAAkB,MAAM,eAAe;IAC3C,IAAI,UAAU,MAAM,OAAO;IAC3B,IAAI,eAAe,QAAQ,WAAW,GAAG;QACrC,sEAAsE;QACtE,MAAM,cAAc,CAAC,GAAG,oBAAoB,kBAAkB,EAAE,MAAM,IAAI,EAAE,QAAQ,WAAW;QAC/F,IAAI,aAAa;YACb,qDAAqD;YACrD,kBAAkB;YAClB,UAAU;QACd,OAAO,IAAI,CAAC,SAAS;YACjB,6HAA6H;YAC7H,UAAU,MAAM,YAAY;QAChC;IACJ,0EAA0E;IAC1E;IACA,OAAO;QACH,YAAY;QACZ,cAAc,QAAQ,YAAY,IAAI,MAAM,YAAY;QACxD,gBAAgB,QAAQ,cAAc,IAAI,MAAM,cAAc;QAC9D,SAAS;YACL,aAAa,eAAe,QAAQ,WAAW,IAAI,QAAQ,WAAW,GAAG,MAAM,OAAO,CAAC,WAAW;YAClG,eAAe,eAAe,QAAQ,aAAa,IAAI,QAAQ,aAAa,GAAG,MAAM,OAAO,CAAC,aAAa;YAC1G,4BAA4B,eAAe,QAAQ,0BAA0B,IAAI,QAAQ,0BAA0B,GAAG,MAAM,OAAO,CAAC,0BAA0B;QAClK;QACA,kEAAkE;QAClE,mBAAmB;YACf,OAAO,eAAe,eAAe,SAAS,sBAAsB,OAAO,MAAM,iBAAiB,CAAC,KAAK,GAAG;YAC3G,gBAAgB,QAAQ,cAAc,IAAI;YAC1C,cAAc,eACd,QAAQ,YAAY,IAAI,QAAQ,YAAY,KAAK,KAAK,mBAAmB,QAAQ,YAAY,CAAC,KAAK,CAAC,MAAM,MAAM,iBAAiB,CAAC,YAAY,GAAG;YACjJ,cAAc,eAAe,SAAS,sBAAsB,MAAM,iBAAiB,CAAC,YAAY,GAAG,EAAE;QACzG;QACA,eAAe;QACf,OAAO,QAAQ,KAAK,GAAG,QAAQ,KAAK,GAAG,MAAM,KAAK;QAClD,8BAA8B;QAC9B,MAAM,eAAe,QAAQ,WAAW,IAAI,QAAQ,WAAW,GAAG,MAAM,IAAI;QAC5E;QACA,iBAAiB;QACjB,WAAW,QAAQ,kBAAkB,IAAI;IAC7C;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 3364, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createRouterCacheKey\", {\n    enumerable: true,\n    get: function() {\n        return createRouterCacheKey;\n    }\n});\nconst _segment = require(\"../../../shared/lib/segment\");\nfunction createRouterCacheKey(segment, withoutSearchParameters = false) {\n    // if the segment is an array, it means it's a dynamic segment\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n    if (Array.isArray(segment)) {\n        return `${segment[0]}|${segment[1]}|${segment[2]}`;\n    }\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\n    // When `withoutSearchParameters` is true, we only want to return the page segment\n    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=create-router-cache-key.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,wBAAwB;IACnD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,qBAAqB,OAAO,EAAE,0BAA0B,KAAK;IAClE,8DAA8D;IAC9D,uGAAuG;IACvG,IAAI,MAAM,OAAO,CAAC,UAAU;QACxB,OAAO,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE;IACtD;IACA,kEAAkE;IAClE,kFAAkF;IAClF,IAAI,2BAA2B,QAAQ,UAAU,CAAC,SAAS,gBAAgB,GAAG;QAC1E,OAAO,SAAS,gBAAgB;IACpC;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 3398, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isNavigatingToNewRootLayout\", {\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n});\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=is-navigating-to-new-root-layout.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,+BAA+B;IAC1D,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,4BAA4B,WAAW,EAAE,QAAQ;IACtD,mBAAmB;IACnB,MAAM,qBAAqB,WAAW,CAAC,EAAE;IACzC,MAAM,kBAAkB,QAAQ,CAAC,EAAE;IACnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAI,MAAM,OAAO,CAAC,uBAAuB,MAAM,OAAO,CAAC,kBAAkB;QACrE,sHAAsH;QACtH,uGAAuG;QACvG,IAAI,kBAAkB,CAAC,EAAE,KAAK,eAAe,CAAC,EAAE,IAAI,kBAAkB,CAAC,EAAE,KAAK,eAAe,CAAC,EAAE,EAAE;YAC9F,OAAO;QACX;IACJ,OAAO,IAAI,uBAAuB,iBAAiB;QAC/C,OAAO;IACX;IACA,iCAAiC;IACjC,IAAI,WAAW,CAAC,EAAE,EAAE;QAChB,4EAA4E;QAC5E,OAAO,CAAC,QAAQ,CAAC,EAAE;IACvB;IACA,oEAAoE;IACpE,IAAI,QAAQ,CAAC,EAAE,EAAE;QACb,OAAO;IACX;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAM,mBAAmB,OAAO,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAM,gBAAgB,OAAO,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAAC,oBAAoB,CAAC,eAAe,OAAO;IAChD,OAAO,4BAA4B,kBAAkB;AACzD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4DAA4D","ignoreList":[0]}},
    {"offset": {"line": 3451, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    abortTask: null,\n    listenForDynamicRequest: null,\n    startPPRNavigation: null,\n    updateCacheNodeOnPopstateRestoration: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _matchsegments = require(\"../match-segments\");\nconst _createhreffromurl = require(\"./create-href-from-url\");\nconst _createroutercachekey = require(\"./create-router-cache-key\");\nconst _isnavigatingtonewrootlayout = require(\"./is-navigating-to-new-root-layout\");\nconst _navigatereducer = require(\"./reducers/navigate-reducer\");\nconst MPA_NAVIGATION_TASK = {\n    route: null,\n    node: null,\n    dynamicRequestTree: null,\n    children: null\n};\nfunction startPPRNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {\n    const segmentPath = [];\n    return updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);\n}\nfunction updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    if (!didFindRootLayout) {\n        // We're currently traversing the part of the tree that was also part of\n        // the previous route. If we discover a root layout, then we don't need to\n        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n        const isRootLayout = newRouterState[4] === true;\n        if (isRootLayout) {\n            // Found a matching root layout.\n            didFindRootLayout = true;\n        }\n    }\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server  for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let needsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n    // end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            newSegmentChild\n        ]);\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment  a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation  but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else if (isSamePageNavigation && // Check if this is a page segment.\n        // TODO: We're not consistent about how we do this check. Some places\n        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n        // check if there any any children, which is why I'm doing it here. We\n        // should probably encode an empty children set as `null` though. Either\n        // way, we should update all the checks to be consistent.\n        Object.keys(newRouterStateChild[1]).length === 0) {\n            // We special case navigations to the exact same URL as the current\n            // location. It's a common UI pattern for apps to refresh when you click a\n            // link to the current page. So when this happens, we refresh the dynamic\n            // data in the page segments.\n            //\n            // Note that this does not apply if the any part of the hash or search\n            // query has changed. This might feel a bit weird but it makes more sense\n            // when you consider that the way to trigger this behavior is to click\n            // the same link multiple times.\n            //\n            // TODO: We should probably refresh the *entire* route when this case\n            // occurs, not just the page segments. Essentially treating it the same as\n            // a refresh() triggered by an action, which is the more explicit way of\n            // modeling the UI pattern described above.\n            //\n            // Also note that this only refreshes the dynamic data, not static/\n            // cached data. If the page segment is fully static and prefetched, the\n            // request is skipped. (This is also how refresh() works.)\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees. Recursively update\n                // the children.\n                taskChild = updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);\n            } else {\n                // There's no existing Cache Node for this segment. Switch to the\n                // \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        }\n        if (taskChild !== null) {\n            // Recursively propagate up the child tasks.\n            if (taskChild.route === null) {\n                // One of the child tasks discovered a change to the root layout.\n                // Immediately unwind from this recursive traversal.\n                return MPA_NAVIGATION_TASK;\n            }\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            const taskChildRoute = taskChild.route;\n            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n            }\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        navigatedAt\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    if (!didFindRootLayout) {\n        // The route tree changed before we reached a layout. (The highest-level\n        // layout in a route tree is referred to as the \"root\" layout.) This could\n        // mean that we're navigating between two different root layouts. When this\n        // happens, we perform a full-page (MPA-style) navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just because\n        // we're re-rendering a segment outside of the root layout does not mean we\n        // should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments are\n        // considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is unchanged.\n        // In the common case, this branch is skipped completely.\n        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {\n            // The root layout changed. Perform a full-page navigation.\n            return MPA_NAVIGATION_TASK;\n        }\n    }\n    return createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n}\nfunction createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Same traversal as updateCacheNodeNavigation, but we switch to this path\n    // once we reach the part of the tree that was not in the previous route. We\n    // don't need to diff against the old tree, we just need to create a new one.\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const routerStateChildren = routerState[1];\n    const isLeafSegment = Object.keys(routerStateChildren).length === 0;\n    // Even we're rendering inside the \"new\" part of the target tree, we may have\n    // a locally cached segment that we can reuse. This may come from either 1)\n    // the CacheNode tree, which lives in React state and is populated by previous\n    // navigations; or 2) the prefetch cache, which is a separate cache that is\n    // populated by prefetches.\n    let rsc;\n    let loading;\n    let head;\n    let cacheNodeNavigatedAt;\n    if (existingCacheNode !== undefined && // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + _navigatereducer.DYNAMIC_STALETIME_MS > navigatedAt) {\n        // We have an existing CacheNode for this segment, and it's not stale. We\n        // should reuse it rather than request a new one.\n        rsc = existingCacheNode.rsc;\n        loading = existingCacheNode.loading;\n        head = existingCacheNode.head;\n        // Don't update the navigatedAt timestamp, since we're reusing stale data.\n        cacheNodeNavigatedAt = existingCacheNode.navigatedAt;\n    } else if (prefetchData !== null) {\n        // There's no existing CacheNode for this segment, but we do have prefetch\n        // data. If the prefetch data is fully static (i.e. does not contain any\n        // dynamic holes), we don't need to request it from the server.\n        rsc = prefetchData[0];\n        loading = prefetchData[2];\n        head = isLeafSegment ? possiblyPartialPrefetchHead : null;\n        // Even though we're accessing the data from the prefetch cache, this is\n        // conceptually a new segment, not a reused one. So we should update the\n        // navigatedAt timestamp.\n        cacheNodeNavigatedAt = navigatedAt;\n        const isPrefetchRscPartial = prefetchData[3];\n        if (// Check if the segment data is partial\n        isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)\n        isPrefetchHeadPartial && isLeafSegment) {\n            // We only have partial data from this segment. Like missing segments, we\n            // must request the full data from the server.\n            return spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n        } else {\n        // The prefetch data is fully static, so we can omit it from the\n        // navigation request.\n        }\n    } else {\n        // There's no prefetch for this segment. Everything from this point will be\n        // requested from the server, even if there are static children below it.\n        // Create a terminal task node that will later be fulfilled by\n        // server response.\n        return spawnPendingTask(navigatedAt, routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    // We already have a full segment we can render, so we don't need to request a\n    // new one from the server. Keep traversing down the tree until we reach\n    // something that requires a dynamic request.\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const taskChildren = new Map();\n    const existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null;\n    const cacheNodeChildren = new Map(existingCacheNodeChildren);\n    let dynamicRequestTreeChildren = {};\n    let needsDynamicRequest = false;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    } else {\n        for(let parallelRouteKey in routerStateChildren){\n            const routerStateChild = routerStateChildren[parallelRouteKey];\n            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n            const existingSegmentMapChild = existingCacheNodeChildren !== null ? existingCacheNodeChildren.get(parallelRouteKey) : undefined;\n            const segmentChild = routerStateChild[0];\n            const segmentPathChild = segmentPath.concat([\n                parallelRouteKey,\n                segmentChild\n            ]);\n            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n            const existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;\n            const taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n            taskChildren.set(parallelRouteKey, taskChild);\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;\n            }\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map();\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    return {\n        // Since we're inside a new route tree, unlike the\n        // `updateCacheNodeOnNavigation` path, the router state on the children\n        // tasks is always the same as the router state we pass in. So we don't need\n        // to clone/modify it.\n        route: routerState,\n        node: {\n            lazyData: null,\n            // Since this segment is already full, we don't need to use the\n            // `prefetchRsc` field.\n            rsc,\n            prefetchRsc: null,\n            head,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: cacheNodeChildren,\n            navigatedAt: cacheNodeNavigatedAt\n        },\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Create a task that will later be fulfilled by data from the server.\n    // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n    // this to the server so it knows where to start rendering.\n    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);\n    dynamicRequestTree[3] = 'refetch';\n    const newTask = {\n        route: routerState,\n        // Corresponds to the part of the route that will be rendered on the server.\n        node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),\n        // Because this is non-null, and it gets propagated up through the parent\n        // tasks, the root task will know that it needs to perform a server request.\n        dynamicRequestTree,\n        children: null\n    };\n    return newTask;\n}\nfunction reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterState) {\n    // This is a \"default\" segment. These are never sent by the server during a\n    // soft navigation; instead, the client reuses whatever segment was already\n    // active in that slot on the previous route. This means if we later need to\n    // refresh the segment, it will have to be refetched from the previous route's\n    // URL. We store it in the Flight Router State.\n    //\n    // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n    // get rid of that eventually by making sure we only add URLs to page segments\n    // that are reused. Then the presence of the URL alone is enough.\n    let reusedRouterState;\n    const oldRefreshMarker = oldRouterState[3];\n    if (oldRefreshMarker === 'refresh') {\n        // This segment was already reused from an even older route. Keep its\n        // existing URL and refresh marker.\n        reusedRouterState = oldRouterState;\n    } else {\n        // This segment was not previously reused, and it's not on the new route.\n        // So it must have been delivered in the old route.\n        reusedRouterState = patchRouterStateWithNewChildren(oldRouterState, oldRouterState[1]);\n        reusedRouterState[2] = (0, _createhreffromurl.createHrefFromUrl)(oldUrl);\n        reusedRouterState[3] = 'refresh';\n    }\n    return {\n        route: reusedRouterState,\n        node: null,\n        dynamicRequestTree: null,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((result)=>{\n        if (typeof result === 'string') {\n            // Happens when navigating to page in `pages` from `app`. We shouldn't\n            // get here because should have already handled this during\n            // the prefetch.\n            return;\n        }\n        const { flightData, debugInfo } = result;\n        for (const normalizedFlightData of flightData){\n            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;\n            if (!dynamicData) {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead, debugInfo);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null, debugInfo);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error, null);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead, debugInfo) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead, debugInfo);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead, debugInfo) {\n    if (task.dynamicRequestTree === null) {\n        // Everything in this subtree is already complete. Bail out.\n        return;\n    }\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead, debugInfo);\n            // Set this to null to indicate that this task is now complete.\n            task.dynamicRequestTree = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[1];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead, debugInfo);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            segmentChild\n        ]);\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    }\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : [\n            null,\n            null\n        ],\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        // TODO: Technically, a loading boundary could contain dynamic data. We must\n        // have separate `loading` and `prefetchLoading` fields to handle this, like\n        // we do for the segment data and head.\n        loading: prefetchData !== null ? prefetchData[2] ?? null : // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n        createDeferredRsc(),\n        navigatedAt\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead, debugInfo) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety  it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[1];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead, debugInfo);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[0];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData, debugInfo);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n    // Fulfill it using the dynamic response so that we can display the loading boundary.\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        const dynamicLoading = dynamicData[2];\n        loading.resolve(dynamicLoading, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead, debugInfo);\n    }\n}\nfunction abortTask(task, error, debugInfo) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error, debugInfo);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error, debugInfo);\n        }\n    }\n    // Set this to null to indicate that this task is now complete.\n    task.dynamicRequestTree = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error, debugInfo) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null, debugInfo);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error, debugInfo);\n        }\n    }\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        loading.resolve(null, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null, debugInfo);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [\n            null,\n            null\n        ],\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: oldCacheNode.loading,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        navigatedAt: oldCacheNode.navigatedAt\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && typeof value === 'object' && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    // Create an unresolved promise that represents data derived from a Flight\n    // response. The promise will be resolved later as soon as we start receiving\n    // data from the server, i.e. as soon as the Flight client decodes and returns\n    // the top-level response object.\n    // The `_debugInfo` field contains profiling information. Promises that are\n    // created by Flight already have this info added by React; for any derived\n    // promise created by the router, we need to transfer the Flight debug info\n    // onto the derived promise.\n    //\n    // The debug info represents the latency between the start of the navigation\n    // and the start of rendering. (It does not represent the time it takes for\n    // whole stream to finish.)\n    const debugInfo = [];\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    pendingRsc._debugInfo = debugInfo;\n    return pendingRsc;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=ppr-navigations.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4326, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/navigation.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"navigate\", {\n    enumerable: true,\n    get: function() {\n        return navigate;\n    }\n});\nconst _fetchserverresponse = require(\"../router-reducer/fetch-server-response\");\nconst _pprnavigations = require(\"../router-reducer/ppr-navigations\");\nconst _createhreffromurl = require(\"../router-reducer/create-href-from-url\");\nconst _cache = require(\"./cache\");\nconst _cachekey = require(\"./cache-key\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _types = require(\"./types\");\nfunction navigate(url, currentUrl, currentCacheNode, currentFlightRouterState, nextUrl, shouldScroll, accumulation) {\n    const now = Date.now();\n    const href = url.href;\n    // We special case navigations to the exact same URL as the current location.\n    // It's a common UI pattern for apps to refresh when you click a link to the\n    // current page. So when this happens, we refresh the dynamic data in the page\n    // segments.\n    //\n    // Note that this does not apply if the any part of the hash or search query\n    // has changed. This might feel a bit weird but it makes more sense when you\n    // consider that the way to trigger this behavior is to click the same link\n    // multiple times.\n    //\n    // TODO: We should probably refresh the *entire* route when this case occurs,\n    // not just the page segments. Essentially treating it the same as a refresh()\n    // triggered by an action, which is the more explicit way of modeling the UI\n    // pattern described above.\n    //\n    // Also note that this only refreshes the dynamic data, not static/ cached\n    // data. If the page segment is fully static and prefetched, the request is\n    // skipped. (This is also how refresh() works.)\n    const isSamePageNavigation = // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href;\n    const cacheKey = (0, _cachekey.createCacheKey)(href, nextUrl);\n    const route = (0, _cache.readRouteCacheEntry)(now, cacheKey);\n    if (route !== null && route.status === _cache.EntryStatus.Fulfilled) {\n        // We have a matching prefetch.\n        const snapshot = readRenderSnapshotFromCache(now, route, route.tree);\n        const prefetchFlightRouterState = snapshot.flightRouterState;\n        const prefetchSeedData = snapshot.seedData;\n        const headSnapshot = readHeadSnapshotFromCache(now, route);\n        const prefetchHead = headSnapshot.rsc;\n        const isPrefetchHeadPartial = headSnapshot.isPartial;\n        // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n        // because hash entries do not vary by hash fragment. However, the one\n        // we set in the router state *does* include the hash, and it's used to\n        // sync with the actual browser location. To make this less of a refactor\n        // hazard, we should always track the hash separately from the rest of\n        // the URL.\n        const newCanonicalUrl = route.canonicalUrl + url.hash;\n        const renderedSearch = route.renderedSearch;\n        return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, renderedSearch, shouldScroll, url.hash);\n    }\n    // There was no matching route tree in the cache. Let's see if we can\n    // construct an \"optimistic\" route tree.\n    //\n    // Do not construct an optimistic route tree if there was a cache hit, but\n    // the entry has a rejected status, since it may have been rejected due to a\n    // rewrite or redirect based on the search params.\n    //\n    // TODO: There are multiple reasons a prefetch might be rejected; we should\n    // track them explicitly and choose what to do here based on that.\n    if (route === null || route.status !== _cache.EntryStatus.Rejected) {\n        const optimisticRoute = (0, _cache.requestOptimisticRouteCacheEntry)(now, url, nextUrl);\n        if (optimisticRoute !== null) {\n            // We have an optimistic route tree. Proceed with the normal flow.\n            const snapshot = readRenderSnapshotFromCache(now, optimisticRoute, optimisticRoute.tree);\n            const prefetchFlightRouterState = snapshot.flightRouterState;\n            const prefetchSeedData = snapshot.seedData;\n            const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute);\n            const prefetchHead = headSnapshot.rsc;\n            const isPrefetchHeadPartial = headSnapshot.isPartial;\n            const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash;\n            const newRenderedSearch = optimisticRoute.renderedSearch;\n            return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, newRenderedSearch, shouldScroll, url.hash);\n        }\n    }\n    // There's no matching prefetch for this route in the cache.\n    let collectedDebugInfo = accumulation.collectedDebugInfo ?? [];\n    if (accumulation.collectedDebugInfo === undefined) {\n        collectedDebugInfo = accumulation.collectedDebugInfo = [];\n    }\n    return {\n        tag: _types.NavigationResultTag.Async,\n        data: navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, shouldScroll, url.hash, collectedDebugInfo)\n    };\n}\nfunction navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, canonicalUrl, renderedSearch, shouldScroll, hash) {\n    // Recursively construct a prefetch tree by reading from the Segment Cache. To\n    // maintain compatibility, we output the same data structures as the old\n    // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n    // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n    // read from the Segment Cache directly. It's only structured this way for now\n    // so we can share code with the old prefetching implementation.\n    const scrollableSegments = [];\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegments);\n    if (task !== null) {\n        const dynamicRequestTree = task.dynamicRequestTree;\n        if (dynamicRequestTree !== null) {\n            const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(new URL(canonicalUrl, url.origin), {\n                flightRouterState: dynamicRequestTree,\n                nextUrl\n            });\n            (0, _pprnavigations.listenForDynamicRequest)(task, promiseForDynamicServerResponse);\n        } else {\n        // The prefetched tree does not contain dynamic holes  it's\n        // fully static. We can skip the dynamic request.\n        }\n        return navigationTaskToResult(task, currentCacheNode, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash);\n    }\n    // The server sent back an empty tree patch. There's nothing to update, except\n    // possibly the URL.\n    return {\n        tag: _types.NavigationResultTag.NoOp,\n        data: {\n            canonicalUrl,\n            shouldScroll\n        }\n    };\n}\nfunction navigationTaskToResult(task, currentCacheNode, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash) {\n    const flightRouterState = task.route;\n    if (flightRouterState === null) {\n        // When no router state is provided, it signals that we should perform an\n        // MPA navigation.\n        return {\n            tag: _types.NavigationResultTag.MPA,\n            data: canonicalUrl\n        };\n    }\n    const newCacheNode = task.node;\n    return {\n        tag: _types.NavigationResultTag.Success,\n        data: {\n            flightRouterState,\n            cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n            canonicalUrl,\n            renderedSearch,\n            scrollableSegments,\n            shouldScroll,\n            hash\n        }\n    };\n}\nfunction readRenderSnapshotFromCache(now, route, tree) {\n    let childRouterStates = {};\n    let childSeedDatas = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childResult = readRenderSnapshotFromCache(now, route, childTree);\n            childRouterStates[parallelRouteKey] = childResult.flightRouterState;\n            childSeedDatas[parallelRouteKey] = childResult.seedData;\n        }\n    }\n    let rsc = null;\n    let loading = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, tree.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    // Happy path: a cache hit\n                    rsc = segmentEntry.rsc;\n                    loading = segmentEntry.loading;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    // We haven't received data for this segment yet, but there's already\n                    // an in-progress request. Since it's extremely likely to arrive\n                    // before the dynamic data response, we might as well use it.\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    loading = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.loading : null);\n                    // Since we don't know yet whether the segment is partial or fully\n                    // static, we must assume it's partial; we can't skip the\n                    // dynamic request.\n                    isPartial = true;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    // The navigation implementation expects the search params to be\n    // included in the segment. However, the Segment Cache tracks search\n    // params separately from the rest of the segment key. So we need to\n    // add them back here.\n    //\n    // See corresponding comment in convertFlightRouterStateToTree.\n    //\n    // TODO: What we should do instead is update the navigation diffing\n    // logic to compare search params explicitly. This is a temporary\n    // solution until more of the Segment Cache implementation has settled.\n    const segment = (0, _segment.addSearchParamsIfPageSegment)(tree.segment, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    // We don't need this information in a render snapshot, so this can just be a placeholder.\n    const hasRuntimePrefetch = false;\n    return {\n        flightRouterState: [\n            segment,\n            childRouterStates,\n            null,\n            null,\n            tree.isRootLayout\n        ],\n        seedData: [\n            rsc,\n            childSeedDatas,\n            loading,\n            isPartial,\n            hasRuntimePrefetch\n        ]\n    };\n}\nfunction readHeadSnapshotFromCache(now, route) {\n    // Same as readRenderSnapshotFromCache, but for the head\n    let rsc = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, route.metadata.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    rsc = segmentEntry.rsc;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    isPartial = true;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    return {\n        rsc,\n        isPartial\n    };\n}\nasync function navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, shouldScroll, hash, collectedDebugInfo) {\n    // Runs when a navigation happens but there's no cached prefetch we can use.\n    // Don't bother to wait for a prefetch response; go straight to a full\n    // navigation that contains both static and dynamic data in a single stream.\n    // (This is unlike the old navigation implementation, which instead blocks\n    // the dynamic request until a prefetch request is received.)\n    //\n    // To avoid duplication of logic, we're going to pretend that the tree\n    // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n    // use the same server response to write the actual data into the CacheNode\n    // tree. So it's the same flow as the \"happy path\" (prefetch, then\n    // navigation), except we use a single server response for both stages.\n    const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(url, {\n        flightRouterState: currentFlightRouterState,\n        nextUrl\n    });\n    const result = await promiseForDynamicServerResponse;\n    if (typeof result === 'string') {\n        // This is an MPA navigation.\n        const newUrl = result;\n        return {\n            tag: _types.NavigationResultTag.MPA,\n            data: newUrl\n        };\n    }\n    const { flightData, canonicalUrl, renderedSearch, debugInfo: debugInfoFromResponse } = result;\n    if (debugInfoFromResponse !== null) {\n        collectedDebugInfo.push(...debugInfoFromResponse);\n    }\n    // Since the response format of dynamic requests and prefetches is slightly\n    // different, we'll need to massage the data a bit. Create FlightRouterState\n    // tree that simulates what we'd receive as the result of a prefetch.\n    const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(currentFlightRouterState, flightData);\n    // In our simulated prefetch payload, we pretend that there's no seed data\n    // nor a prefetch head.\n    const prefetchSeedData = null;\n    const prefetchHead = null;\n    const isPrefetchHeadPartial = true;\n    // Now we proceed exactly as we would for normal navigation.\n    const scrollableSegments = [];\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegments);\n    if (task !== null) {\n        // In this case, we've already sent the dynamic request, so we don't\n        // actually use the request tree created by `startPPRNavigation`,\n        // except to check if it contains dynamic holes.\n        //\n        // This is almost always true, but it could be false if all the segment data\n        // was present in the cache, but the route tree was not. E.g. navigating\n        // to a URL that was not prefetched but rewrites to a different URL\n        // that was.\n        const hasDynamicHoles = task.dynamicRequestTree !== null;\n        if (hasDynamicHoles) {\n            (0, _pprnavigations.listenForDynamicRequest)(task, promiseForDynamicServerResponse);\n        } else {\n        // The prefetched tree does not contain dynamic holes  it's\n        // fully static. We don't need to process the server response further.\n        }\n        return navigationTaskToResult(task, currentCacheNode, (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl), renderedSearch, scrollableSegments, shouldScroll, hash);\n    }\n    // The server sent back an empty tree patch. There's nothing to update, except\n    // possibly the URL.\n    return {\n        tag: _types.NavigationResultTag.NoOp,\n        data: {\n            canonicalUrl: (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl),\n            shouldScroll\n        }\n    };\n}\nfunction simulatePrefetchTreeUsingDynamicTreePatch(currentTree, flightData) {\n    // Takes the current FlightRouterState and applies the router state patch\n    // received from the server, to create a full FlightRouterState tree that we\n    // can pretend was returned by a prefetch.\n    //\n    // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n    // to handle stuff like interception routes or diffing since that will be\n    // handled later.)\n    let baseTree = currentTree;\n    for (const { segmentPath, tree: treePatch } of flightData){\n        // If the server sends us multiple tree patches, we only need to clone the\n        // base tree when applying the first patch. After the first patch, we can\n        // apply the remaining patches in place without copying.\n        const canMutateInPlace = baseTree !== currentTree;\n        baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(baseTree, treePatch, segmentPath, canMutateInPlace, 0);\n    }\n    return baseTree;\n}\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(baseRouterState, patch, segmentPath, canMutateInPlace, index) {\n    if (index === segmentPath.length) {\n        // We reached the part of the tree that we need to patch.\n        return patch;\n    }\n    // segmentPath represents the parent path of subtree. It's a repeating\n    // pattern of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // This path tells us which part of the base tree to apply the tree patch.\n    //\n    // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n    // the FlightRouterState patch in the same request as the dynamic data.\n    // Therefore we don't need to worry about diffing the segment values; we can\n    // assume the server sent us a correct result.\n    const updatedParallelRouteKey = segmentPath[index];\n    // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n    const baseChildren = baseRouterState[1];\n    const newChildren = {};\n    for(const parallelRouteKey in baseChildren){\n        if (parallelRouteKey === updatedParallelRouteKey) {\n            const childBaseRouterState = baseChildren[parallelRouteKey];\n            newChildren[parallelRouteKey] = simulatePrefetchTreeUsingDynamicTreePatchImpl(childBaseRouterState, patch, segmentPath, canMutateInPlace, // Advance the index by two and keep cloning until we reach\n            // the end of the segment path.\n            index + 2);\n        } else {\n            // This child is not being patched. Copy it over as-is.\n            newChildren[parallelRouteKey] = baseChildren[parallelRouteKey];\n        }\n    }\n    if (canMutateInPlace) {\n        // We can mutate the base tree in place, because the base tree is already\n        // a clone.\n        baseRouterState[1] = newChildren;\n        return baseRouterState;\n    }\n    // Clone all the fields except the children.\n    //\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4742, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DYNAMIC_STALETIME_MS: null,\n    STATIC_STALETIME_MS: null,\n    generateSegmentsFromPatch: null,\n    handleExternalUrl: null,\n    navigateReducer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    generateSegmentsFromPatch: function() {\n        return generateSegmentsFromPatch;\n    },\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _navigation = require(\"../../segment-cache/navigation\");\nconst _types = require(\"../../segment-cache/types\");\nconst _cache = require(\"../../segment-cache/cache\");\nconst DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000;\nconst STATIC_STALETIME_MS = (0, _cache.getStaleTimeMs)(Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME));\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _types.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _types.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // We don't need to compare the origins, because client-driven\n                // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _types.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.renderedSearch = result.data.renderedSearch;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _types.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // If the navigation failed, return the current state.\n                // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    const result = (0, _navigation.navigate)(url, currentUrl, state.cache, state.tree, state.nextUrl, shouldScroll, mutable);\n    return handleNavigationResult(url, state, mutable, pendingPush, result);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigate-reducer.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4907, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/segment-cache/output-export-prefetch-encoding.js"],"sourcesContent":["// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DOC_PREFETCH_RANGE_HEADER_VALUE: null,\n    doesExportedHtmlMatchBuildId: null,\n    insertBuildIdComment: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DOC_PREFETCH_RANGE_HEADER_VALUE: function() {\n        return DOC_PREFETCH_RANGE_HEADER_VALUE;\n    },\n    doesExportedHtmlMatchBuildId: function() {\n        return doesExportedHtmlMatchBuildId;\n    },\n    insertBuildIdComment: function() {\n        return insertBuildIdComment;\n    }\n});\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\n;\nconst MAX_BUILD_ID_LENGTH = 24;\nconst DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63';\nfunction escapeBuildId(buildId) {\n    // If the build id is longer than the given limit, it's OK for our purposes\n    // to only match the beginning.\n    const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH);\n    // Replace hyphens with underscores so it doesn't break the HTML comment.\n    // (Unlikely, but if this did happen it would break the whole document.)\n    return truncated.replace(/-/g, '_');\n}\nfunction insertBuildIdComment(originalHtml, buildId) {\n    if (// Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') || // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)) {\n        // Return the original HTML unchanged. This means the document will not\n        // be prefetched.\n        // TODO: The build id comment is currently only used during prefetches, but\n        // if we eventually use this mechanism for regular navigations, we may need\n        // to error during build if we fail to insert it for some reason.\n        return originalHtml;\n    }\n    // The comment must be inserted after the doctype.\n    return originalHtml.replace(DOCTYPE_PREFIX, DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');\n}\nfunction doesExportedHtmlMatchBuildId(partialHtmlDocument, buildId) {\n    // Check whether the document starts with the expected buildId.\n    return partialHtmlDocument.startsWith(DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');\n}\n\n//# sourceMappingURL=output-export-prefetch-encoding.js.map"],"names":[],"mappings":"AAAA,yEAAyE;AACzE,2EAA2E;AAC3E,+EAA+E;AAC/E,6CAA6C;AAC7C,EAAE;AACF,2EAA2E;AAC3E,6EAA6E;AAC7E,sEAAsE;AACtE,mBAAmB;AACnB,EAAE;AACF,yEAAyE;AACzE,2EAA2E;AAC3E,6EAA6E;AAC7E,oBAAoB;AAEpB,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,iCAAiC;IACjC,8BAA8B;IAC9B,sBAAsB;AAC1B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,iCAAiC;QAC7B,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;AACJ;AACA,MAAM,iBAAiB,kBAAkB,WAAW;;AAEpD,MAAM,sBAAsB;AAC5B,MAAM,kCAAkC;AACxC,SAAS,cAAc,OAAO;IAC1B,2EAA2E;IAC3E,+BAA+B;IAC/B,MAAM,YAAY,QAAQ,KAAK,CAAC,GAAG;IACnC,yEAAyE;IACzE,wEAAwE;IACxE,OAAO,UAAU,OAAO,CAAC,MAAM;AACnC;AACA,SAAS,qBAAqB,YAAY,EAAE,OAAO;IAC/C,IACA,QAAQ,QAAQ,CAAC,UAAU,0EAA0E;IACrG,gEAAgE;IAChE,CAAC,aAAa,UAAU,CAAC,iBAAiB;QACtC,uEAAuE;QACvE,iBAAiB;QACjB,2EAA2E;QAC3E,2EAA2E;QAC3E,iEAAiE;QACjE,OAAO;IACX;IACA,kDAAkD;IAClD,OAAO,aAAa,OAAO,CAAC,gBAAgB,iBAAiB,SAAS,cAAc,WAAW;AACnG;AACA,SAAS,6BAA6B,mBAAmB,EAAE,OAAO;IAC9D,+DAA+D;IAC/D,OAAO,oBAAoB,UAAU,CAAC,iBAAiB,SAAS,cAAc,WAAW;AAC7F,EAEA,2DAA2D","ignoreList":[0]}},
    {"offset": {"line": 4980, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/promise-with-resolvers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createPromiseWithResolvers\", {\n    enumerable: true,\n    get: function() {\n        return createPromiseWithResolvers;\n    }\n});\nfunction createPromiseWithResolvers() {\n    // Shim of Stage 4 Promise.withResolvers proposal\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise\n    };\n}\n\n//# sourceMappingURL=promise-with-resolvers.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,8BAA8B;IACzD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS;IACL,iDAAiD;IACjD,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;QAC9B,UAAU;QACV,SAAS;IACb;IACA,OAAO;QACH,SAAS;QACT,QAAQ;QACR;IACJ;AACJ,EAEA,kDAAkD","ignoreList":[0]}},
    {"offset": {"line": 5007, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/cache.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    EntryStatus: null,\n    canNewFetchStrategyProvideMoreContent: null,\n    convertRouteTreeToFlightRouterState: null,\n    createDetachedSegmentCacheEntry: null,\n    fetchRouteOnCacheMiss: null,\n    fetchSegmentOnCacheMiss: null,\n    fetchSegmentPrefetchesUsingDynamicRequest: null,\n    getCurrentCacheVersion: null,\n    getStaleTimeMs: null,\n    overwriteRevalidatingSegmentCacheEntry: null,\n    pingInvalidationListeners: null,\n    readOrCreateRevalidatingSegmentEntry: null,\n    readOrCreateRouteCacheEntry: null,\n    readOrCreateSegmentCacheEntry: null,\n    readRouteCacheEntry: null,\n    readSegmentCacheEntry: null,\n    requestOptimisticRouteCacheEntry: null,\n    revalidateEntireCache: null,\n    upgradeToPendingSegment: null,\n    upsertSegmentEntry: null,\n    waitForSegmentCacheEntry: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    EntryStatus: function() {\n        return EntryStatus;\n    },\n    canNewFetchStrategyProvideMoreContent: function() {\n        return canNewFetchStrategyProvideMoreContent;\n    },\n    convertRouteTreeToFlightRouterState: function() {\n        return convertRouteTreeToFlightRouterState;\n    },\n    createDetachedSegmentCacheEntry: function() {\n        return createDetachedSegmentCacheEntry;\n    },\n    fetchRouteOnCacheMiss: function() {\n        return fetchRouteOnCacheMiss;\n    },\n    fetchSegmentOnCacheMiss: function() {\n        return fetchSegmentOnCacheMiss;\n    },\n    fetchSegmentPrefetchesUsingDynamicRequest: function() {\n        return fetchSegmentPrefetchesUsingDynamicRequest;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    getStaleTimeMs: function() {\n        return getStaleTimeMs;\n    },\n    overwriteRevalidatingSegmentCacheEntry: function() {\n        return overwriteRevalidatingSegmentCacheEntry;\n    },\n    pingInvalidationListeners: function() {\n        return pingInvalidationListeners;\n    },\n    readOrCreateRevalidatingSegmentEntry: function() {\n        return readOrCreateRevalidatingSegmentEntry;\n    },\n    readOrCreateRouteCacheEntry: function() {\n        return readOrCreateRouteCacheEntry;\n    },\n    readOrCreateSegmentCacheEntry: function() {\n        return readOrCreateSegmentCacheEntry;\n    },\n    readRouteCacheEntry: function() {\n        return readRouteCacheEntry;\n    },\n    readSegmentCacheEntry: function() {\n        return readSegmentCacheEntry;\n    },\n    requestOptimisticRouteCacheEntry: function() {\n        return requestOptimisticRouteCacheEntry;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    upgradeToPendingSegment: function() {\n        return upgradeToPendingSegment;\n    },\n    upsertSegmentEntry: function() {\n        return upsertSegmentEntry;\n    },\n    waitForSegmentCacheEntry: function() {\n        return waitForSegmentCacheEntry;\n    }\n});\nconst _approutertypes = require(\"../../../shared/lib/app-router-types\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst _fetchserverresponse = require(\"../router-reducer/fetch-server-response\");\nconst _scheduler = require(\"./scheduler\");\nconst _varypath = require(\"./vary-path\");\nconst _appbuildid = require(\"../../app-build-id\");\nconst _createhreffromurl = require(\"../router-reducer/create-href-from-url\");\nconst _cachekey = require(\"./cache-key\");\nconst _routeparams = require(\"../../route-params\");\nconst _cachemap = require(\"./cache-map\");\nconst _segmentvalueencoding = require(\"../../../shared/lib/segment-cache/segment-value-encoding\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nconst _navigatereducer = require(\"../router-reducer/reducers/navigate-reducer\");\nconst _links = require(\"../links\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _outputexportprefetchencoding = require(\"../../../shared/lib/segment-cache/output-export-prefetch-encoding\");\nconst _types = require(\"./types\");\nconst _promisewithresolvers = require(\"../../../shared/lib/promise-with-resolvers\");\nfunction getStaleTimeMs(staleTimeSeconds) {\n    return Math.max(staleTimeSeconds, 30) * 1000;\n}\nvar EntryStatus = /*#__PURE__*/ function(EntryStatus) {\n    EntryStatus[EntryStatus[\"Empty\"] = 0] = \"Empty\";\n    EntryStatus[EntryStatus[\"Pending\"] = 1] = \"Pending\";\n    EntryStatus[EntryStatus[\"Fulfilled\"] = 2] = \"Fulfilled\";\n    EntryStatus[EntryStatus[\"Rejected\"] = 3] = \"Rejected\";\n    return EntryStatus;\n}({});\nconst isOutputExportMode = process.env.NODE_ENV === 'production' && process.env.__NEXT_CONFIG_OUTPUT === 'export';\nconst MetadataOnlyRequestTree = [\n    '',\n    {},\n    null,\n    'metadata-only'\n];\nlet routeCacheMap = (0, _cachemap.createCacheMap)();\nlet segmentCacheMap = (0, _cachemap.createCacheMap)();\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners = null;\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0;\nfunction getCurrentCacheVersion() {\n    return currentCacheVersion;\n}\nfunction revalidateEntireCache(nextUrl, tree) {\n    // Increment the current cache version. This does not eagerly evict anything\n    // from the cache, but because all the entries are versioned, and we check\n    // the version when reading from the cache, this effectively causes all\n    // entries to be evicted lazily. We do it lazily because in the future,\n    // actions like revalidateTag or refresh will not evict the entire cache,\n    // but rather some subset of the entries.\n    currentCacheVersion++;\n    // Start a cooldown before re-prefetching to allow CDN cache propagation.\n    (0, _scheduler.startRevalidationCooldown)();\n    // Prefetch all the currently visible links again, to re-fill the cache.\n    (0, _links.pingVisibleLinks)(nextUrl, tree);\n    // Similarly, notify all invalidation listeners (i.e. those passed to\n    // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n    // if needed.\n    pingInvalidationListeners(nextUrl, tree);\n}\nfunction attachInvalidationListener(task) {\n    // This function is called whenever a prefetch task reads a cache entry. If\n    // the task has an onInvalidate function associated with it  i.e. the one\n    // optionally passed to router.prefetch(onInvalidate)  then we attach that\n    // listener to the every cache entry that the task reads. Then, if an entry\n    // is invalidated, we call the function.\n    if (task.onInvalidate !== null) {\n        if (invalidationListeners === null) {\n            invalidationListeners = new Set([\n                task\n            ]);\n        } else {\n            invalidationListeners.add(task);\n        }\n    }\n}\nfunction notifyInvalidationListener(task) {\n    const onInvalidate = task.onInvalidate;\n    if (onInvalidate !== null) {\n        // Clear the callback from the task object to guarantee it's not called more\n        // than once.\n        task.onInvalidate = null;\n        // This is a user-space function, so we must wrap in try/catch.\n        try {\n            onInvalidate();\n        } catch (error) {\n            if (typeof reportError === 'function') {\n                reportError(error);\n            } else {\n                console.error(error);\n            }\n        }\n    }\n}\nfunction pingInvalidationListeners(nextUrl, tree) {\n    // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    if (invalidationListeners !== null) {\n        const tasks = invalidationListeners;\n        invalidationListeners = null;\n        for (const task of tasks){\n            if ((0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n                notifyInvalidationListener(task);\n            }\n        }\n    }\n}\nfunction readRouteCacheEntry(now, key) {\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), routeCacheMap, varyPath, isRevalidation);\n}\nfunction readSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction readRevalidatingSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = true;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction waitForSegmentCacheEntry(pendingEntry) {\n    // Because the entry is pending, there's already a in-progress request.\n    // Attach a promise to the entry that will resolve when the server responds.\n    let promiseWithResolvers = pendingEntry.promise;\n    if (promiseWithResolvers === null) {\n        promiseWithResolvers = pendingEntry.promise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n    } else {\n    // There's already a promise we can use\n    }\n    return promiseWithResolvers.promise;\n}\nfunction readOrCreateRouteCacheEntry(now, task, key) {\n    attachInvalidationListener(task);\n    const existingEntry = readRouteCacheEntry(now, key);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const pendingEntry = {\n        canonicalUrl: null,\n        status: 0,\n        blockedTasks: null,\n        tree: null,\n        metadata: null,\n        // This is initialized to true because we don't know yet whether the route\n        // could be intercepted. It's only set to false once we receive a response\n        // from the server.\n        couldBeIntercepted: true,\n        // Similarly, we don't yet know if the route supports PPR.\n        isPPREnabled: false,\n        renderedSearch: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        // Since this is an empty entry, there's no reason to ever evict it. It will\n        // be updated when the data is populated.\n        staleAt: Infinity,\n        version: getCurrentCacheVersion()\n    };\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(routeCacheMap, varyPath, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction requestOptimisticRouteCacheEntry(now, requestedUrl, nextUrl) {\n    // This function is called during a navigation when there was no matching\n    // route tree in the prefetch cache. Before de-opting to a blocking,\n    // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n    // route tree by checking the cache for similar routes.\n    //\n    // Check if there's a route with the same pathname, but with different\n    // search params. We can then base our optimistic route tree on this entry.\n    //\n    // Conceptually, we are simulating what would happen if we did perform a\n    // prefetch the requested URL, under the assumption that the server will\n    // not redirect or rewrite the request in a different manner than the\n    // base route tree. This assumption might not hold, in which case we'll have\n    // to recover when we perform the dynamic navigation request. However, this\n    // is what would happen if a route were dynamically rewritten/redirected\n    // in between the prefetch and the navigation. So the logic needs to exist\n    // to handle this case regardless.\n    // Look for a route with the same pathname, but with an empty search string.\n    // TODO: There's nothing inherently special about the empty search string;\n    // it's chosen somewhat arbitrarily, with the rationale that it's the most\n    // likely one to exist. But we should update this to match _any_ search\n    // string. The plan is to generalize this logic alongside other improvements\n    // related to \"fallback\" cache entries.\n    const requestedSearch = requestedUrl.search;\n    if (requestedSearch === '') {\n        // The caller would have already checked if a route with an empty search\n        // string is in the cache. So we can bail out here.\n        return null;\n    }\n    const urlWithoutSearchParams = new URL(requestedUrl);\n    urlWithoutSearchParams.search = '';\n    const routeWithNoSearchParams = readRouteCacheEntry(now, (0, _cachekey.createCacheKey)(urlWithoutSearchParams.href, nextUrl));\n    if (routeWithNoSearchParams === null || routeWithNoSearchParams.status !== 2) {\n        // Bail out of constructing an optimistic route tree. This will result in\n        // a blocking, unprefetched navigation.\n        return null;\n    }\n    // Now we have a base route tree we can \"patch\" with our optimistic values.\n    // Optimistically assume that redirects for the requested pathname do\n    // not vary on the search string. Therefore, if the base route was\n    // redirected to a different search string, then the optimistic route\n    // should be redirected to the same search string. Otherwise, we use\n    // the requested search string.\n    const canonicalUrlForRouteWithNoSearchParams = new URL(routeWithNoSearchParams.canonicalUrl, requestedUrl.origin);\n    const optimisticCanonicalSearch = canonicalUrlForRouteWithNoSearchParams.search !== '' ? canonicalUrlForRouteWithNoSearchParams.search : requestedSearch;\n    // Similarly, optimistically assume that rewrites for the requested\n    // pathname do not vary on the search string. Therefore, if the base\n    // route was rewritten to a different search string, then the optimistic\n    // route should be rewritten to the same search string. Otherwise, we use\n    // the requested search string.\n    const optimisticRenderedSearch = routeWithNoSearchParams.renderedSearch !== '' ? routeWithNoSearchParams.renderedSearch : requestedSearch;\n    const optimisticUrl = new URL(routeWithNoSearchParams.canonicalUrl, location.origin);\n    optimisticUrl.search = optimisticCanonicalSearch;\n    const optimisticCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(optimisticUrl);\n    const optimisticRouteTree = createOptimisticRouteTree(routeWithNoSearchParams.tree, optimisticRenderedSearch);\n    const optimisticMetadataTree = createOptimisticRouteTree(routeWithNoSearchParams.metadata, optimisticRenderedSearch);\n    // Clone the base route tree, and override the relevant fields with our\n    // optimistic values.\n    const optimisticEntry = {\n        canonicalUrl: optimisticCanonicalUrl,\n        status: 2,\n        // This isn't cloned because it's instance-specific\n        blockedTasks: null,\n        tree: optimisticRouteTree,\n        metadata: optimisticMetadataTree,\n        couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n        isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n        // Override the rendered search with the optimistic value.\n        renderedSearch: optimisticRenderedSearch,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt: routeWithNoSearchParams.staleAt,\n        version: routeWithNoSearchParams.version\n    };\n    // Do not insert this entry into the cache. It only exists so we can\n    // perform the current navigation. Just return it to the caller.\n    return optimisticEntry;\n}\nfunction createOptimisticRouteTree(tree, newRenderedSearch) {\n    // Create a new route tree that identical to the original one except for\n    // the rendered search string, which is contained in the vary path.\n    let clonedSlots = null;\n    const originalSlots = tree.slots;\n    if (originalSlots !== null) {\n        clonedSlots = {};\n        for(const parallelRouteKey in originalSlots){\n            const childTree = originalSlots[parallelRouteKey];\n            clonedSlots[parallelRouteKey] = createOptimisticRouteTree(childTree, newRenderedSearch);\n        }\n    }\n    // We only need to clone the vary path if the route is a page.\n    if (tree.isPage) {\n        return {\n            requestKey: tree.requestKey,\n            segment: tree.segment,\n            varyPath: (0, _varypath.clonePageVaryPathWithNewSearchParams)(tree.varyPath, newRenderedSearch),\n            isPage: true,\n            slots: clonedSlots,\n            isRootLayout: tree.isRootLayout,\n            hasLoadingBoundary: tree.hasLoadingBoundary,\n            hasRuntimePrefetch: tree.hasRuntimePrefetch\n        };\n    }\n    return {\n        requestKey: tree.requestKey,\n        segment: tree.segment,\n        varyPath: tree.varyPath,\n        isPage: false,\n        slots: clonedSlots,\n        isRootLayout: tree.isRootLayout,\n        hasLoadingBoundary: tree.hasLoadingBoundary,\n        hasRuntimePrefetch: tree.hasRuntimePrefetch\n    };\n}\nfunction readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree) {\n    const existingEntry = readSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction readOrCreateRevalidatingSegmentEntry(now, fetchStrategy, route, tree) {\n    // This function is called when we've already confirmed that a particular\n    // segment is cached, but we want to perform another request anyway in case it\n    // returns more complete and/or fresher data than we already have. The logic\n    // for deciding whether to replace the existing entry is handled elsewhere;\n    // this function just handles retrieving a cache entry that we can use to\n    // track the revalidation.\n    //\n    // The reason revalidations are stored in the cache is because we need to be\n    // able to dedupe multiple revalidation requests. The reason they have to be\n    // handled specially is because we shouldn't overwrite a \"normal\" entry if\n    // one exists at the same keypath. So, for each internal cache location, there\n    // is a special \"revalidation\" slot that is used solely for this purpose.\n    //\n    // You can think of it as if all the revalidation entries were stored in a\n    // separate cache map from the canonical entries, and then transfered to the\n    // canonical cache map once the request is complete  this isn't how it's\n    // actually implemented, since it's more efficient to store them in the same\n    // data structure as the normal entries, but that's how it's modeled\n    // conceptually.\n    // TODO: Once we implement Fallback behavior for params, where an entry is\n    // re-keyed based on response information, we'll need to account for the\n    // possibility that the keypath of the previous entry is more generic than\n    // the keypath of the revalidating entry. In other words, the server could\n    // return a less generic entry upon revalidation. For now, though, this isn't\n    // a concern because the keypath is based solely on the prefetch strategy,\n    // not on data contained in the response.\n    const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction overwriteRevalidatingSegmentCacheEntry(fetchStrategy, route, tree) {\n    // This function is called when we've already decided to replace an existing\n    // revalidation entry. Create a new entry and write it into the cache,\n    // overwriting the previous value.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction upsertSegmentEntry(now, varyPath, candidateEntry) {\n    // We have a new entry that has not yet been inserted into the cache. Before\n    // we do so, we need to confirm whether it takes precedence over the existing\n    // entry (if one exists).\n    // TODO: We should not upsert an entry if its key was invalidated in the time\n    // since the request was made. We can do that by passing the \"owner\" entry to\n    // this function and confirming it's the same as `existingEntry`.\n    if ((0, _cachemap.isValueExpired)(now, getCurrentCacheVersion(), candidateEntry)) {\n        // The entry is expired. We cannot upsert it.\n        return null;\n    }\n    const existingEntry = readSegmentCacheEntry(now, varyPath);\n    if (existingEntry !== null) {\n        // Don't replace a more specific segment with a less-specific one. A case where this\n        // might happen is if the existing segment was fetched via\n        // `<Link prefetch={true}>`.\n        if (// We fetched the new segment using a different, less specific fetch strategy\n        // than the segment we already have in the cache, so it can't have more content.\n        candidateEntry.fetchStrategy !== existingEntry.fetchStrategy && !canNewFetchStrategyProvideMoreContent(existingEntry.fetchStrategy, candidateEntry.fetchStrategy) || // The existing entry isn't partial, but the new one is.\n        // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n        !existingEntry.isPartial && candidateEntry.isPartial) {\n            // We're going to leave revalidating entry in the cache so that it doesn't\n            // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n            // Rejected and null out the data so it can be garbage collected. We leave\n            // `staleAt` intact to prevent subsequent revalidation attempts only until\n            // the entry expires.\n            const rejectedEntry = candidateEntry;\n            rejectedEntry.status = 3;\n            rejectedEntry.loading = null;\n            rejectedEntry.rsc = null;\n            return null;\n        }\n        // Evict the existing entry from the cache.\n        (0, _cachemap.deleteFromCacheMap)(existingEntry);\n    }\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPath, candidateEntry, isRevalidation);\n    return candidateEntry;\n}\nfunction createDetachedSegmentCacheEntry(staleAt) {\n    const emptyEntry = {\n        status: 0,\n        // Default to assuming the fetch strategy will be PPR. This will be updated\n        // when a fetch is actually initiated.\n        fetchStrategy: _types.FetchStrategy.PPR,\n        rsc: null,\n        loading: null,\n        isPartial: true,\n        promise: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt,\n        version: 0\n    };\n    return emptyEntry;\n}\nfunction upgradeToPendingSegment(emptyEntry, fetchStrategy) {\n    const pendingEntry = emptyEntry;\n    pendingEntry.status = 1;\n    pendingEntry.fetchStrategy = fetchStrategy;\n    // Set the version here, since this is right before the request is initiated.\n    // The next time the global cache version is incremented, the entry will\n    // effectively be evicted. This happens before initiating the request, rather\n    // than when receiving the response, because it's guaranteed to happen\n    // before the data is read on the server.\n    pendingEntry.version = getCurrentCacheVersion();\n    return pendingEntry;\n}\nfunction pingBlockedTasks(entry) {\n    const blockedTasks = entry.blockedTasks;\n    if (blockedTasks !== null) {\n        for (const task of blockedTasks){\n            (0, _scheduler.pingPrefetchTask)(task);\n        }\n        entry.blockedTasks = null;\n    }\n}\nfunction fulfillRouteCacheEntry(entry, tree, metadataVaryPath, staleAt, couldBeIntercepted, canonicalUrl, renderedSearch, isPPREnabled) {\n    // The Head is not actually part of the route tree, but other than that, it's\n    // fetched and cached like a segment. Some functions expect a RouteTree\n    // object, so rather than fork the logic in all those places, we use this\n    // \"fake\" one.\n    const metadata = {\n        requestKey: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        segment: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        varyPath: metadataVaryPath,\n        // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n        // either) but for the purposes of how this field is used, it behaves like\n        // one. If this logic ever gets more complex we can change this to an enum.\n        isPage: true,\n        slots: null,\n        isRootLayout: false,\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        hasRuntimePrefetch: false\n    };\n    const fulfilledEntry = entry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.tree = tree;\n    fulfilledEntry.metadata = metadata;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.couldBeIntercepted = couldBeIntercepted;\n    fulfilledEntry.canonicalUrl = canonicalUrl;\n    fulfilledEntry.renderedSearch = renderedSearch;\n    fulfilledEntry.isPPREnabled = isPPREnabled;\n    pingBlockedTasks(entry);\n    return fulfilledEntry;\n}\nfunction fulfillSegmentCacheEntry(segmentCacheEntry, rsc, loading, staleAt, isPartial) {\n    const fulfilledEntry = segmentCacheEntry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.rsc = rsc;\n    fulfilledEntry.loading = loading;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.isPartial = isPartial;\n    // Resolve any listeners that were waiting for this data.\n    if (segmentCacheEntry.promise !== null) {\n        segmentCacheEntry.promise.resolve(fulfilledEntry);\n        // Free the promise for garbage collection.\n        fulfilledEntry.promise = null;\n    }\n    return fulfilledEntry;\n}\nfunction rejectRouteCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    pingBlockedTasks(entry);\n}\nfunction rejectSegmentCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    if (entry.promise !== null) {\n        // NOTE: We don't currently propagate the reason the prefetch was canceled\n        // but we could by accepting a `reason` argument.\n        entry.promise.resolve(null);\n        entry.promise = null;\n    }\n}\nfunction convertRootTreePrefetchToRouteTree(rootTree, renderedPathname, renderedSearch, acc) {\n    // Remove trailing and leading slashes\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    const rootSegment = _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY;\n    return convertTreePrefetchToRouteTree(rootTree.tree, rootSegment, null, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, pathnameParts, index, renderedSearch, acc);\n}\nfunction convertTreePrefetchToRouteTree(prefetch, segment, partialVaryPath, requestKey, pathnameParts, pathnamePartsIndex, renderedSearch, acc) {\n    // Converts the route tree sent by the server into the format used by the\n    // cache. The cached version of the tree includes additional fields, such as a\n    // cache key for each segment. Since this is frequently accessed, we compute\n    // it once instead of on every access. This same cache key is also used to\n    // request the segment from the server.\n    let slots = null;\n    let isPage;\n    let varyPath;\n    const prefetchSlots = prefetch.slots;\n    if (prefetchSlots !== null) {\n        isPage = false;\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        slots = {};\n        for(let parallelRouteKey in prefetchSlots){\n            const childPrefetch = prefetchSlots[parallelRouteKey];\n            const childParamName = childPrefetch.name;\n            const childParamType = childPrefetch.paramType;\n            const childServerSentParamKey = childPrefetch.paramKey;\n            let childDoesAppearInURL;\n            let childSegment;\n            let childPartialVaryPath;\n            if (childParamType !== null) {\n                // This segment is parameterized. Get the param from the pathname.\n                const childParamValue = (0, _routeparams.parseDynamicParamFromURLPart)(childParamType, pathnameParts, pathnamePartsIndex);\n                // Assign a cache key to the segment, based on the param value. In the\n                // pre-Segment Cache implementation, the server computes this and sends\n                // it in the body of the response. In the Segment Cache implementation,\n                // the server sends an empty string and we fill it in here.\n                // TODO: We're intentionally not adding the search param to page\n                // segments here; it's tracked separately and added back during a read.\n                // This would clearer if we waited to construct the segment until it's\n                // read from the cache, since that's effectively what we're\n                // doing anyway.\n                const childParamKey = // The server omits this field from the prefetch response when\n                // cacheComponents is enabled.\n                childServerSentParamKey !== null ? childServerSentParamKey : (0, _routeparams.getCacheKeyForDynamicParam)(childParamValue, '');\n                childPartialVaryPath = (0, _varypath.appendLayoutVaryPath)(partialVaryPath, childParamKey);\n                childSegment = [\n                    childParamName,\n                    childParamKey,\n                    childParamType\n                ];\n                childDoesAppearInURL = true;\n            } else {\n                // This segment does not have a param. Inherit the partial vary path of\n                // the parent.\n                childPartialVaryPath = partialVaryPath;\n                childSegment = childParamName;\n                childDoesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(childParamName);\n            }\n            // Only increment the index if the segment appears in the URL. If it's a\n            // \"virtual\" segment, like a route group, it remains the same.\n            const childPathnamePartsIndex = childDoesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n            const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n            const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n            slots[parallelRouteKey] = convertTreePrefetchToRouteTree(childPrefetch, childSegment, childPartialVaryPath, childRequestKey, pathnameParts, childPathnamePartsIndex, renderedSearch, acc);\n        }\n    } else {\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: prefetch.isRootLayout,\n        // This field is only relevant to dynamic routes. For a PPR/static route,\n        // there's always some partial loading state we can fetch.\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary,\n        hasRuntimePrefetch: prefetch.hasRuntimePrefetch\n    };\n}\nfunction convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc) {\n    return convertFlightRouterStateToRouteTree(flightRouterState, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, null, renderedSearch, acc);\n}\nfunction convertFlightRouterStateToRouteTree(flightRouterState, requestKey, parentPartialVaryPath, renderedSearch, acc) {\n    const originalSegment = flightRouterState[0];\n    let segment;\n    let partialVaryPath;\n    let isPage;\n    let varyPath;\n    if (Array.isArray(originalSegment)) {\n        isPage = false;\n        const paramCacheKey = originalSegment[1];\n        partialVaryPath = (0, _varypath.appendLayoutVaryPath)(parentPartialVaryPath, paramCacheKey);\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        segment = originalSegment;\n    } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        partialVaryPath = parentPartialVaryPath;\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            // The navigation implementation expects the search params to be included\n            // in the segment. However, in the case of a static response, the search\n            // params are omitted. So the client needs to add them back in when reading\n            // from the Segment Cache.\n            //\n            // For consistency, we'll do this for dynamic responses, too.\n            //\n            // TODO: We should move search params out of FlightRouterState and handle\n            // them entirely on the client, similar to our plan for dynamic params.\n            segment = _segment.PAGE_SEGMENT_KEY;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            segment = originalSegment;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    let slots = null;\n    const parallelRoutes = flightRouterState[1];\n    for(let parallelRouteKey in parallelRoutes){\n        const childRouterState = parallelRoutes[parallelRouteKey];\n        const childSegment = childRouterState[0];\n        // TODO: Eventually, the param values will not be included in the response\n        // from the server. We'll instead fill them in on the client by parsing\n        // the URL. This is where we'll do that.\n        const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n        const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n        const childTree = convertFlightRouterStateToRouteTree(childRouterState, childRequestKey, partialVaryPath, renderedSearch, acc);\n        if (slots === null) {\n            slots = {\n                [parallelRouteKey]: childTree\n            };\n        } else {\n            slots[parallelRouteKey] = childTree;\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: flightRouterState[4] === true,\n        hasLoadingBoundary: flightRouterState[5] !== undefined ? flightRouterState[5] : _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        // Non-static tree responses are only used by apps that haven't adopted\n        // Cache Components. So this is always false.\n        hasRuntimePrefetch: false\n    };\n}\nfunction convertRouteTreeToFlightRouterState(routeTree) {\n    const parallelRoutes = {};\n    if (routeTree.slots !== null) {\n        for(const parallelRouteKey in routeTree.slots){\n            parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(routeTree.slots[parallelRouteKey]);\n        }\n    }\n    const flightRouterState = [\n        routeTree.segment,\n        parallelRoutes,\n        null,\n        null,\n        routeTree.isRootLayout\n    ];\n    return flightRouterState;\n}\nasync function fetchRouteOnCacheMiss(entry, task, key) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    const pathname = key.pathname;\n    const search = key.search;\n    const nextUrl = key.nextUrl;\n    const segmentPath = '/_tree';\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        const url = new URL(pathname + search, location.origin);\n        let response;\n        let urlAfterRedirects;\n        if (isOutputExportMode) {\n            // In output: \"export\" mode, we can't use headers to request a particular\n            // segment. Instead, we encode the extra request information into the URL.\n            // This is not part of the \"public\" interface of the app; it's an internal\n            // Next.js implementation detail that the app developer should not need to\n            // concern themselves with.\n            //\n            // For example, to request a segment:\n            //\n            //   Path passed to <Link>:   /path/to/page\n            //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n            //\n            //   (This is not the exact protocol, just an illustration.)\n            //\n            // Before we do that, though, we need to account for redirects. Even in\n            // output: \"export\" mode, a proxy might redirect the page to a different\n            // location, but we shouldn't assume or expect that they also redirect all\n            // the segment files, too.\n            //\n            // To check whether the page is redirected, we perform a range request of\n            // the first N bytes of the HTML document. The canonical URL is determined\n            // from the response.\n            //\n            // Then we can use the canonical URL to request the route tree.\n            //\n            // NOTE: We could embed the route tree into the HTML document, to avoid\n            // a second request. We're not doing that currently because it would make\n            // the HTML document larger and affect normal page loads.\n            const htmlResponse = await fetch(url, {\n                headers: {\n                    Range: _outputexportprefetchencoding.DOC_PREFETCH_RANGE_HEADER_VALUE\n                }\n            });\n            const partialHtml = await htmlResponse.text();\n            if (!(0, _outputexportprefetchencoding.doesExportedHtmlMatchBuildId)(partialHtml, (0, _appbuildid.getAppBuildId)())) {\n                // The target page is not part of this app, or it belongs to a\n                // different build.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            urlAfterRedirects = htmlResponse.redirected ? new URL(htmlResponse.url) : url;\n            response = await fetchPrefetchResponse(addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath), headers);\n        } else {\n            // \"Server\" mode. We can use request headers instead of the pathname.\n            // TODO: The eventual plan is to get rid of our custom request headers and\n            // encode everything into the URL, using a similar strategy to the\n            // \"output: export\" block above.\n            response = await fetchPrefetchResponse(url, headers);\n            urlAfterRedirects = response !== null && response.redirected ? new URL(response.url) : url;\n        }\n        if (!response || !response.ok || // 204 is a Cache miss. Though theoretically this shouldn't happen when\n        // PPR is enabled, because we always respond to route tree requests, even\n        // if it needs to be blockingly generated on demand.\n        response.status === 204 || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // TODO: The canonical URL is the href without the origin. I think\n        // historically the reason for this is because the initial canonical URL\n        // gets passed as a prop to the top-level React component, which means it\n        // needs to be computed during SSR. If it were to include the origin, it\n        // would need to always be same as location.origin on the client, to prevent\n        // a hydration mismatch. To sidestep this complexity, we omit the origin.\n        //\n        // However, since this is neither a native URL object nor a fully qualified\n        // URL string, we need to be careful about how we use it. To prevent subtle\n        // mistakes, we should create a special type for it, instead of just string.\n        // Or, we should just use a (readonly) URL object instead. The type of the\n        // prop that we pass to seed the initial state does not need to be the same\n        // type as the state itself.\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(urlAfterRedirects);\n        // Check whether the response varies based on the Next-Url header.\n        const varyHeader = response.headers.get('vary');\n        const couldBeIntercepted = varyHeader !== null && varyHeader.includes(_approuterheaders.NEXT_URL);\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route.\n        const routeIsPPREnabled = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '2' || // In output: \"export\" mode, we can't rely on response headers. But if we\n        // receive a well-formed response, we can assume it's a static response,\n        // because all data is static in this mode.\n        isOutputExportMode;\n        if (routeIsPPREnabled) {\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            // Get the params that were used to render the target page. These may\n            // be different from the params in the request URL, if the page\n            // was rewritten.\n            const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n            const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n            // Convert the server-sent data into the RouteTree format used by the\n            // client cache.\n            //\n            // During this traversal, we accumulate additional data into this\n            // \"accumulator\" object.\n            const acc = {\n                metadataVaryPath: null\n            };\n            const routeTree = convertRootTreePrefetchToRouteTree(serverData, renderedPathname, renderedSearch, acc);\n            const metadataVaryPath = acc.metadataVaryPath;\n            if (metadataVaryPath === null) {\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            const staleTimeMs = getStaleTimeMs(serverData.staleTime);\n            fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, Date.now() + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n        } else {\n            // PPR is not enabled for this route. The server responds with a\n            // different format (FlightRouterState) that we need to convert.\n            // TODO: We will unify the responses eventually. I'm keeping the types\n            // separate for now because FlightRouterState has so many\n            // overloaded concerns.\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            writeDynamicTreeResponseIntoCache(Date.now(), task, // The non-PPR response format is what we'd get if we prefetched these segments\n            // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n            _types.FetchStrategy.LoadingBoundary, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled);\n        }\n        if (!couldBeIntercepted) {\n            // This route will never be intercepted. So we can use this entry for all\n            // requests to this route, regardless of the Next-Url header. This works\n            // because when reading the cache we always check for a valid\n            // non-intercepted entry first.\n            // Re-key the entry. The `set` implementation handles removing it from\n            // its previous position in the cache. We don't need to do anything to\n            // update the LRU, because the entry is already in it.\n            // TODO: Treat this as an upsert  should check if an entry already\n            // exists at the new keypath, and if so, whether we should keep that\n            // one instead.\n            const fulfilledVaryPath = (0, _varypath.getFulfilledRouteVaryPath)(pathname, search, nextUrl, couldBeIntercepted);\n            const isRevalidation = false;\n            (0, _cachemap.setInCacheMap)(routeCacheMap, fulfilledVaryPath, entry, isRevalidation);\n        }\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentOnCacheMiss(route, segmentCacheEntry, routeKey, tree) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    //\n    // Segment fetches are non-blocking so we don't need to ping the scheduler\n    // on completion.\n    // Use the canonical URL to request the segment, not the original URL. These\n    // are usually the same, but the canonical URL will be different if the route\n    // tree response was redirected. To avoid an extra waterfall on every segment\n    // request, we pass the redirected URL instead of the original one.\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = routeKey.nextUrl;\n    const requestKey = tree.requestKey;\n    const normalizedRequestKey = requestKey === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY ? // handling of these requests, we encode the root segment path as\n    // `_index` instead of as an empty string. This should be treated as\n    // an implementation detail and not as a stable part of the protocol.\n    // It just needs to match the equivalent logic that happens when\n    // prerendering the responses. It should not leak outside of Next.js.\n    '/_index' : requestKey;\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    const requestUrl = isOutputExportMode ? addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey) : url;\n    try {\n        const response = await fetchPrefetchResponse(requestUrl, headers);\n        if (!response || !response.ok || response.status === 204 || // Cache miss\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route. Theoretically this should never happen\n        // because we only issue requests for segments once we've verified that\n        // the route supports PPR.\n        response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) !== '2' && // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // Wrap the original stream in a new stream that never closes. That way the\n        // Flight client doesn't error if there's a hanging promise.\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n            (0, _cachemap.setSizeInCacheMap)(segmentCacheEntry, size);\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n            // The server build does not match the client. Treat as a 404. During\n            // an actual navigation, the router will trigger an MPA navigation.\n            // TODO: Consider moving the build ID to a response header so we can check\n            // it before decoding the response, and so there's one way of checking\n            // across all response types.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        return {\n            value: fulfillSegmentCacheEntry(segmentCacheEntry, serverData.rsc, serverData.loading, // TODO: The server does not currently provide per-segment stale time.\n            // So we use the stale time of the route.\n            route.staleAt, serverData.isPartial),\n            // Return a promise that resolves when the network connection closes, so\n            // the scheduler can track the number of concurrent network connections.\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentPrefetchesUsingDynamicRequest(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries) {\n    const key = task.key;\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = key.nextUrl;\n    if (spawnedEntries.size === 1 && spawnedEntries.has(route.metadata.requestKey)) {\n        // The only thing pending is the head. Instruct the server to\n        // skip over everything else.\n        dynamicRequestTree = MetadataOnlyRequestTree;\n    }\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(dynamicRequestTree)\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    switch(fetchStrategy){\n        case _types.FetchStrategy.Full:\n            {\n                break;\n            }\n        case _types.FetchStrategy.PPRRuntime:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '2';\n                break;\n            }\n        case _types.FetchStrategy.LoadingBoundary:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n                break;\n            }\n        default:\n            {\n                fetchStrategy;\n            }\n    }\n    try {\n        const response = await fetchPrefetchResponse(url, headers);\n        if (!response || !response.ok || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n        if (renderedSearch !== route.renderedSearch) {\n            // The search params that were used to render the target page are\n            // different from the search params in the request URL. This only happens\n            // when there's a dynamic rewrite in between the tree prefetch and the\n            // data prefetch.\n            // TODO: For now, since this is an edge case, we reject the prefetch, but\n            // the proper way to handle this is to evict the stale route tree entry\n            // then fill the cache with the new response.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        let fulfilledEntries = null;\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n            // When processing a dynamic response, we don't know how large each\n            // individual segment is, so approximate by assiging each segment\n            // the average of the total response size.\n            if (fulfilledEntries === null) {\n                // Haven't received enough data yet to know which segments\n                // were included.\n                return;\n            }\n            const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length;\n            for (const entry of fulfilledEntries){\n                (0, _cachemap.setSizeInCacheMap)(entry, averageSize);\n            }\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        const isResponsePartial = fetchStrategy === _types.FetchStrategy.PPRRuntime ? serverData.rp?.[0] === true : // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n        false;\n        // Aside from writing the data into the cache, this function also returns\n        // the entries that were fulfilled, so we can streamingly update their sizes\n        // in the LRU as more data comes in.\n        fulfilledEntries = writeDynamicRenderResponseIntoCache(Date.now(), task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries);\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nfunction writeDynamicTreeResponseIntoCache(now, task, fetchStrategy, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled) {\n    // Get the URL that was used to render the target page. This may be different\n    // from the URL in the request URL, if the page was rewritten.\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const normalizedFlightDataResult = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (// A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' || normalizedFlightDataResult.length !== 1) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightData = normalizedFlightDataResult[0];\n    if (!flightData.isRootRender) {\n        // Unexpected response format.\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightRouterState = flightData.tree;\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    // If the response contains dynamic holes, then we must conservatively assume\n    // that any individual segment might contain dynamic holes, and also the\n    // head. If it did not contain dynamic holes, then we can assume every segment\n    // and the head is completely static.\n    const isResponsePartial = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '1';\n    // Convert the server-sent data into the RouteTree format used by the\n    // client cache.\n    //\n    // During this traversal, we accumulate additional data into this\n    // \"accumulator\" object.\n    const acc = {\n        metadataVaryPath: null\n    };\n    const routeTree = convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc);\n    const metadataVaryPath = acc.metadataVaryPath;\n    if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const fulfilledEntry = fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, now + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n    // If the server sent segment data as part of the response, we should write\n    // it into the cache to prevent a second, redundant prefetch request.\n    //\n    // TODO: When `clientSegmentCache` is enabled, the server does not include\n    // segment data when responding to a route tree prefetch request. However,\n    // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n    // the page is fully static), the normal check is bypassed and the server\n    // responds with the full page. This is a temporary situation until we can\n    // remove the \"client-only\" option. Then, we can delete this function call.\n    writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, fulfilledEntry, null);\n}\nfunction rejectSegmentEntriesIfStillPending(entries, staleAt) {\n    const fulfilledEntries = [];\n    for (const entry of entries.values()){\n        if (entry.status === 1) {\n            rejectSegmentCacheEntry(entry, staleAt);\n        } else if (entry.status === 2) {\n            fulfilledEntries.push(entry);\n        }\n    }\n    return fulfilledEntries;\n}\nfunction writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries) {\n    if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        }\n        return null;\n    }\n    const flightDatas = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (typeof flightDatas === 'string') {\n        // This means navigating to this route will result in an MPA navigation.\n        // TODO: We should cache this, too, so that the MPA navigation is immediate.\n        return null;\n    }\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    const staleAt = now + staleTimeMs;\n    for (const flightData of flightDatas){\n        const seedData = flightData.seedData;\n        if (seedData !== null) {\n            // The data sent by the server represents only a subtree of the app. We\n            // need to find the part of the task tree that matches the response.\n            //\n            // segmentPath represents the parent path of subtree. It's a repeating\n            // pattern of parallel route key and segment:\n            //\n            //   [string, Segment, string, Segment, string, Segment, ...]\n            const segmentPath = flightData.segmentPath;\n            let tree = route.tree;\n            for(let i = 0; i < segmentPath.length; i += 2){\n                const parallelRouteKey = segmentPath[i];\n                if (tree?.slots?.[parallelRouteKey] !== undefined) {\n                    tree = tree.slots[parallelRouteKey];\n                } else {\n                    if (spawnedEntries !== null) {\n                        rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n                    }\n                    return null;\n                }\n            }\n            writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, spawnedEntries);\n        }\n        const head = flightData.head;\n        if (head !== null) {\n            fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, head, null, flightData.isHeadPartial, staleAt, route.metadata, spawnedEntries);\n        }\n    }\n    // Any entry that's still pending was intentionally not rendered by the\n    // server, because it was inside the loading boundary. Mark them as rejected\n    // so we know not to fetch them again.\n    // TODO: If PPR is enabled on some routes but not others, then it's possible\n    // that a different page is able to do a per-segment prefetch of one of the\n    // segments we're marking as rejected here. We should mark on the segment\n    // somehow that the reason for the rejection is because of a non-PPR prefetch.\n    // That way a per-segment prefetch knows to disregard the rejection.\n    if (spawnedEntries !== null) {\n        const fulfilledEntries = rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        return fulfilledEntries;\n    }\n    return null;\n}\nfunction writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, entriesOwnedByCurrentTask) {\n    // This function is used to write the result of a runtime server request\n    // (CacheNodeSeedData) into the prefetch cache.\n    const rsc = seedData[0];\n    const loading = seedData[2];\n    const isPartial = rsc === null || isResponsePartial;\n    fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask);\n    // Recursively write the child data into the cache.\n    const slots = tree.slots;\n    if (slots !== null) {\n        const seedDataChildren = seedData[1];\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childSeedData = seedDataChildren[parallelRouteKey];\n            if (childSeedData !== null && childSeedData !== undefined) {\n                writeSeedDataIntoCache(now, task, fetchStrategy, route, childTree, staleAt, childSeedData, isResponsePartial, entriesOwnedByCurrentTask);\n            }\n        }\n    }\n}\nfunction fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask) {\n    // We should only write into cache entries that are owned by us. Or create\n    // a new one and write into that. We must never write over an entry that was\n    // created by a different task, because that causes data races.\n    const ownedEntry = entriesOwnedByCurrentTask !== null ? entriesOwnedByCurrentTask.get(tree.requestKey) : undefined;\n    if (ownedEntry !== undefined) {\n        fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial);\n    } else {\n        // There's no matching entry. Attempt to create a new one.\n        const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree);\n        if (possiblyNewEntry.status === 0) {\n            // Confirmed this is a new entry. We can fulfill it.\n            const newEntry = possiblyNewEntry;\n            fulfillSegmentCacheEntry(upgradeToPendingSegment(newEntry, fetchStrategy), rsc, loading, staleAt, isPartial);\n        } else {\n            // There was already an entry in the cache. But we may be able to\n            // replace it with the new one from the server.\n            const newEntry = fulfillSegmentCacheEntry(upgradeToPendingSegment(createDetachedSegmentCacheEntry(staleAt), fetchStrategy), rsc, loading, staleAt, isPartial);\n            upsertSegmentEntry(now, (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree), newEntry);\n        }\n    }\n}\nasync function fetchPrefetchResponse(url, headers) {\n    const fetchPriority = 'low';\n    // When issuing a prefetch request, don't immediately decode the response; we\n    // use the lower level `createFromResponse` API instead because we need to do\n    // some extra processing of the response stream. See\n    // `createPrefetchResponseStream` for more details.\n    const shouldImmediatelyDecode = false;\n    const response = await (0, _fetchserverresponse.createFetch)(url, headers, fetchPriority, shouldImmediatelyDecode);\n    if (!response.ok) {\n        return null;\n    }\n    // Check the content type\n    if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n    } else {\n        const contentType = response.headers.get('content-type');\n        const isFlightResponse = contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (!isFlightResponse) {\n            return null;\n        }\n    }\n    return response;\n}\nfunction createPrefetchResponseStream(originalFlightStream, onStreamClose, onResponseSizeUpdate) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    //\n    // While processing the original stream, we also incrementally update the size\n    // of the cache entry in the LRU.\n    let totalByteLength = 0;\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    // Incrementally update the size of the cache entry in the LRU.\n                    // NOTE: Since prefetch responses are delivered in a single chunk,\n                    // it's not really necessary to do this streamingly, but I'm doing it\n                    // anyway in case this changes in the future.\n                    totalByteLength += value.byteLength;\n                    onResponseSizeUpdate(totalByteLength);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream. We do notify the caller, though.\n                onStreamClose();\n                return;\n            }\n        }\n    });\n}\nfunction addSegmentPathToUrlInOutputExportMode(url, segmentPath) {\n    if (isOutputExportMode) {\n        // In output: \"export\" mode, we cannot use a header to encode the segment\n        // path. Instead, we append it to the end of the pathname.\n        const staticUrl = new URL(url);\n        const routeDir = staticUrl.pathname.endsWith('/') ? staticUrl.pathname.slice(0, -1) : staticUrl.pathname;\n        const staticExportFilename = (0, _segmentvalueencoding.convertSegmentPathToStaticExportFilename)(segmentPath);\n        staticUrl.pathname = `${routeDir}/${staticExportFilename}`;\n        return staticUrl;\n    }\n    return url;\n}\nfunction canNewFetchStrategyProvideMoreContent(currentStrategy, newStrategy) {\n    return currentStrategy < newStrategy;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=cache.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6378, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/scheduler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    cancelPrefetchTask: null,\n    isPrefetchTaskDirty: null,\n    pingPrefetchTask: null,\n    reschedulePrefetchTask: null,\n    schedulePrefetchTask: null,\n    startRevalidationCooldown: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    isPrefetchTaskDirty: function() {\n        return isPrefetchTaskDirty;\n    },\n    pingPrefetchTask: function() {\n        return pingPrefetchTask;\n    },\n    reschedulePrefetchTask: function() {\n        return reschedulePrefetchTask;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    },\n    startRevalidationCooldown: function() {\n        return startRevalidationCooldown;\n    }\n});\nconst _approutertypes = require(\"../../../shared/lib/app-router-types\");\nconst _matchsegments = require(\"../match-segments\");\nconst _cache = require(\"./cache\");\nconst _varypath = require(\"./vary-path\");\nconst _cachekey = require(\"./cache-key\");\nconst _types = require(\"./types\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn)=>Promise.resolve().then(fn).catch((error)=>setTimeout(()=>{\n            throw error;\n        }));\nconst taskHeap = [];\nlet inProgressRequests = 0;\nlet sortIdCounter = 0;\nlet didScheduleMicrotask = false;\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink = null;\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300;\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle = null;\nfunction startRevalidationCooldown() {\n    // Clear any existing timeout in case multiple revalidations happen\n    // in quick succession.\n    if (revalidationCooldownTimeoutHandle !== null) {\n        clearTimeout(revalidationCooldownTimeoutHandle);\n    }\n    // Schedule the cooldown to expire after the delay.\n    revalidationCooldownTimeoutHandle = setTimeout(()=>{\n        revalidationCooldownTimeoutHandle = null;\n        // Retry the prefetch queue now that the cooldown has expired.\n        ensureWorkIsScheduled();\n    }, REVALIDATION_COOLDOWN_MS);\n}\nfunction schedulePrefetchTask(key, treeAtTimeOfPrefetch, fetchStrategy, priority, onInvalidate) {\n    // Spawn a new prefetch task\n    const task = {\n        key,\n        treeAtTimeOfPrefetch,\n        cacheVersion: (0, _cache.getCurrentCacheVersion)(),\n        priority,\n        phase: 1,\n        hasBackgroundWork: false,\n        spawnedRuntimePrefetches: null,\n        fetchStrategy,\n        sortId: sortIdCounter++,\n        isCanceled: false,\n        onInvalidate,\n        _heapIndex: -1\n    };\n    trackMostRecentlyHoveredLink(task);\n    heapPush(taskHeap, task);\n    // Schedule an async task to process the queue.\n    //\n    // The main reason we process the queue in an async task is for batching.\n    // It's common for a single JS task/event to trigger multiple prefetches.\n    // By deferring to a microtask, we only process the queue once per JS task.\n    // If they have different priorities, it also ensures they are processed in\n    // the optimal order.\n    ensureWorkIsScheduled();\n    return task;\n}\nfunction cancelPrefetchTask(task) {\n    // Remove the prefetch task from the queue. If the task already completed,\n    // then this is a no-op.\n    //\n    // We must also explicitly mark the task as canceled so that a blocked task\n    // does not get added back to the queue when it's pinged by the network.\n    task.isCanceled = true;\n    heapDelete(taskHeap, task);\n}\nfunction reschedulePrefetchTask(task, treeAtTimeOfPrefetch, fetchStrategy, priority) {\n    // Bump the prefetch task to the top of the queue, as if it were a fresh\n    // task. This is essentially the same as canceling the task and scheduling\n    // a new one, except it reuses the original object.\n    //\n    // The primary use case is to increase the priority of a Link-initated\n    // prefetch on hover.\n    // Un-cancel the task, in case it was previously canceled.\n    task.isCanceled = false;\n    task.phase = 1;\n    // Assign a new sort ID to move it ahead of all other tasks at the same\n    // priority level. (Higher sort IDs are processed first.)\n    task.sortId = sortIdCounter++;\n    task.priority = // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? _types.PrefetchPriority.Intent : priority;\n    task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch;\n    task.fetchStrategy = fetchStrategy;\n    trackMostRecentlyHoveredLink(task);\n    if (task._heapIndex !== -1) {\n        // The task is already in the queue.\n        heapResift(taskHeap, task);\n    } else {\n        heapPush(taskHeap, task);\n    }\n    ensureWorkIsScheduled();\n}\nfunction isPrefetchTaskDirty(task, nextUrl, tree) {\n    // This is used to quickly bail out of a prefetch task if the result is\n    // guaranteed to not have changed since the task was initiated. This is\n    // strictly an optimization  theoretically, if it always returned true, no\n    // behavior should change because a full prefetch task will effectively\n    // perform the same checks.\n    const currentCacheVersion = (0, _cache.getCurrentCacheVersion)();\n    return task.cacheVersion !== currentCacheVersion || task.treeAtTimeOfPrefetch !== tree || task.key.nextUrl !== nextUrl;\n}\nfunction trackMostRecentlyHoveredLink(task) {\n    // Track the mostly recently hovered link, i.e. the most recently scheduled\n    // task at Intent priority. There must only be one such task at a time.\n    if (task.priority === _types.PrefetchPriority.Intent && task !== mostRecentlyHoveredLink) {\n        if (mostRecentlyHoveredLink !== null) {\n            // Bump the previously hovered link's priority down to Default.\n            if (mostRecentlyHoveredLink.priority !== _types.PrefetchPriority.Background) {\n                mostRecentlyHoveredLink.priority = _types.PrefetchPriority.Default;\n                heapResift(taskHeap, mostRecentlyHoveredLink);\n            }\n        }\n        mostRecentlyHoveredLink = task;\n    }\n}\nfunction ensureWorkIsScheduled() {\n    if (didScheduleMicrotask) {\n        // Already scheduled a task to process the queue\n        return;\n    }\n    didScheduleMicrotask = true;\n    scheduleMicrotask(processQueueInMicrotask);\n}\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */ function hasNetworkBandwidth(task) {\n    // Check if we're within the revalidation cooldown window\n    if (revalidationCooldownTimeoutHandle !== null) {\n        // We're within the cooldown window. Return false to prevent prefetching.\n        // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n        // to retry the queue.\n        return false;\n    }\n    // TODO: Also check if there's an in-progress navigation. We should never\n    // add prefetch requests to the network queue if an actual navigation is\n    // taking place, to ensure there's sufficient bandwidth for render-blocking\n    // data and resources.\n    // TODO: Consider reserving some amount of bandwidth for static prefetches.\n    if (task.priority === _types.PrefetchPriority.Intent) {\n        // The most recently hovered link is allowed to exceed the default limit.\n        //\n        // The goal is to always have enough bandwidth to start a new prefetch\n        // request when hovering over a link.\n        //\n        // However, because we don't abort in-progress requests, it's still possible\n        // we'll run out of bandwidth. When links are hovered in quick succession,\n        // there could be multiple hover requests running simultaneously.\n        return inProgressRequests < 12;\n    }\n    // The default limit is lower than the limit for a hovered link.\n    return inProgressRequests < 4;\n}\nfunction spawnPrefetchSubtask(prefetchSubtask) {\n    // When the scheduler spawns an async task, we don't await its result.\n    // Instead, the async task writes its result directly into the cache, then\n    // pings the scheduler to continue.\n    //\n    // We process server responses streamingly, so the prefetch subtask will\n    // likely resolve before we're finished receiving all the data. The subtask\n    // result includes a promise that resolves once the network connection is\n    // closed. The scheduler uses this to control network bandwidth by tracking\n    // and limiting the number of concurrent requests.\n    inProgressRequests++;\n    return prefetchSubtask.then((result)=>{\n        if (result === null) {\n            // The prefetch task errored before it could start processing the\n            // network stream. Assume the connection is closed.\n            onPrefetchConnectionClosed();\n            return null;\n        }\n        // Wait for the connection to close before freeing up more bandwidth.\n        result.closed.then(onPrefetchConnectionClosed);\n        return result.value;\n    });\n}\nfunction onPrefetchConnectionClosed() {\n    inProgressRequests--;\n    // Notify the scheduler that we have more bandwidth, and can continue\n    // processing tasks.\n    ensureWorkIsScheduled();\n}\nfunction pingPrefetchTask(task) {\n    // \"Ping\" a prefetch that's already in progress to notify it of new data.\n    if (// Check if prefetch was canceled.\n    task.isCanceled || // Check if prefetch is already queued.\n    task._heapIndex !== -1) {\n        return;\n    }\n    // Add the task back to the queue.\n    heapPush(taskHeap, task);\n    ensureWorkIsScheduled();\n}\nfunction processQueueInMicrotask() {\n    didScheduleMicrotask = false;\n    // We aim to minimize how often we read the current time. Since nearly all\n    // functions in the prefetch scheduler are synchronous, we can read the time\n    // once and pass it as an argument wherever it's needed.\n    const now = Date.now();\n    // Process the task queue until we run out of network bandwidth.\n    let task = heapPeek(taskHeap);\n    while(task !== null && hasNetworkBandwidth(task)){\n        task.cacheVersion = (0, _cache.getCurrentCacheVersion)();\n        const exitStatus = pingRoute(now, task);\n        // These fields are only valid for a single attempt. Reset them after each\n        // iteration of the task queue.\n        const hasBackgroundWork = task.hasBackgroundWork;\n        task.hasBackgroundWork = false;\n        task.spawnedRuntimePrefetches = null;\n        switch(exitStatus){\n            case 0:\n                // The task yielded because there are too many requests in progress.\n                // Stop processing tasks until we have more bandwidth.\n                return;\n            case 1:\n                // The task is blocked. It needs more data before it can proceed.\n                // Keep the task out of the queue until the server responds.\n                heapPop(taskHeap);\n                // Continue to the next task\n                task = heapPeek(taskHeap);\n                continue;\n            case 2:\n                if (task.phase === 1) {\n                    // Finished prefetching the route tree. Proceed to prefetching\n                    // the segments.\n                    task.phase = 0;\n                    heapResift(taskHeap, task);\n                } else if (hasBackgroundWork) {\n                    // The task spawned additional background work. Reschedule the task\n                    // at background priority.\n                    task.priority = _types.PrefetchPriority.Background;\n                    heapResift(taskHeap, task);\n                } else {\n                    // The prefetch is complete. Continue to the next task.\n                    heapPop(taskHeap);\n                }\n                task = heapPeek(taskHeap);\n                continue;\n            default:\n                exitStatus;\n        }\n    }\n}\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */ function background(task) {\n    if (task.priority === _types.PrefetchPriority.Background) {\n        return true;\n    }\n    task.hasBackgroundWork = true;\n    return false;\n}\nfunction pingRoute(now, task) {\n    const key = task.key;\n    const route = (0, _cache.readOrCreateRouteCacheEntry)(now, task, key);\n    const exitStatus = pingRootRouteTree(now, task, route);\n    if (exitStatus !== 0 && key.search !== '') {\n        // If the URL has a non-empty search string, also prefetch the pathname\n        // without the search string. We use the searchless route tree as a base for\n        // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n        //\n        // Note that we don't need to prefetch any of the segment data. Just the\n        // route tree.\n        //\n        // TODO: This is a temporary solution; the plan is to replace this by adding\n        // a wildcard lookup method to the TupleMap implementation. This is\n        // non-trivial to implement because it needs to account for things like\n        // fallback route entries, hence this temporary workaround.\n        const url = new URL(key.pathname, location.origin);\n        const keyWithoutSearch = (0, _cachekey.createCacheKey)(url.href, key.nextUrl);\n        const routeWithoutSearch = (0, _cache.readOrCreateRouteCacheEntry)(now, task, keyWithoutSearch);\n        switch(routeWithoutSearch.status){\n            case _cache.EntryStatus.Empty:\n                {\n                    if (background(task)) {\n                        routeWithoutSearch.status = _cache.EntryStatus.Pending;\n                        spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(routeWithoutSearch, task, keyWithoutSearch));\n                    }\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                {\n                    break;\n                }\n            default:\n                routeWithoutSearch;\n        }\n    }\n    return exitStatus;\n}\nfunction pingRootRouteTree(now, task, route) {\n    switch(route.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // Route is not yet cached, and there's no request already in progress.\n                // Spawn a task to request the route, load it into the cache, and ping\n                // the task to continue.\n                // TODO: There are multiple strategies in the <Link> API for prefetching\n                // a route. Currently we've only implemented the main one: per-segment,\n                // static-data only.\n                //\n                // There's also `<Link prefetch={true}>`\n                // which prefetch both static *and* dynamic data.\n                // Similarly, we need to fallback to the old, per-page\n                // behavior if PPR is disabled for a route (via the incremental opt-in).\n                //\n                // Those cases will be handled here.\n                spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(route, task, task.key));\n                // If the request takes longer than a minute, a subsequent request should\n                // retry instead of waiting for this one. When the response is received,\n                // this value will be replaced by a new value based on the stale time sent\n                // from the server.\n                // TODO: We should probably also manually abort the fetch task, to reclaim\n                // server bandwidth.\n                route.staleAt = now + 60 * 1000;\n                // Upgrade to Pending so we know there's already a request in progress\n                route.status = _cache.EntryStatus.Pending;\n            // Intentional fallthrough to the Pending branch\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                // Still pending. We can't start prefetching the segments until the route\n                // tree has loaded. Add the task to the set of blocked tasks so that it\n                // is notified when the route tree is ready.\n                const blockedTasks = route.blockedTasks;\n                if (blockedTasks === null) {\n                    route.blockedTasks = new Set([\n                        task\n                    ]);\n                } else {\n                    blockedTasks.add(task);\n                }\n                return 1;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // Route tree failed to load. Treat as a 404.\n                return 2;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                if (task.phase !== 0) {\n                    // Do not prefetch segment data until we've entered the segment phase.\n                    return 2;\n                }\n                // Recursively fill in the segment tree.\n                if (!hasNetworkBandwidth(task)) {\n                    // Stop prefetching segments until there's more bandwidth.\n                    return 0;\n                }\n                const tree = route.tree;\n                // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n                // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n                // We don't need to do this for runtime prefetches, because those are only available in\n                // `cacheComponents`, where every route is PPR.\n                const fetchStrategy = task.fetchStrategy === _types.FetchStrategy.PPR ? route.isPPREnabled ? _types.FetchStrategy.PPR : _types.FetchStrategy.LoadingBoundary : task.fetchStrategy;\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                        {\n                            // For Cache Components pages, each segment may be prefetched\n                            // statically or using a runtime request, based on various\n                            // configurations and heuristics. We'll do this in two passes: first\n                            // traverse the tree and perform all the static prefetches.\n                            //\n                            // Then, if there are any segments that need a runtime request,\n                            // do another pass to perform a runtime prefetch.\n                            pingStaticHead(now, task, route);\n                            const exitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, task.treeAtTimeOfPrefetch, tree);\n                            if (exitStatus === 0) {\n                                // Child yielded without finishing.\n                                return 0;\n                            }\n                            const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches;\n                            if (spawnedRuntimePrefetches !== null) {\n                                // During the first pass, we discovered segments that require a\n                                // runtime prefetch. Do a second pass to construct a request tree.\n                                const spawnedEntries = new Map();\n                                pingRuntimeHead(now, task, route, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n                                const requestTree = pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries);\n                                let needsDynamicRequest = spawnedEntries.size > 0;\n                                if (needsDynamicRequest) {\n                                    // Perform a dynamic prefetch request and populate the cache with\n                                    // the result.\n                                    spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, _types.FetchStrategy.PPRRuntime, requestTree, spawnedEntries));\n                                }\n                            }\n                            return 2;\n                        }\n                    case _types.FetchStrategy.Full:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // Prefetch multiple segments using a single dynamic request.\n                            // TODO: We can consolidate this branch with previous one by modeling\n                            // it as if the first segment in the new tree has runtime prefetching\n                            // enabled. Will do this as a follow-up refactor. Might want to remove\n                            // the special metatdata case below first. In the meantime, it's not\n                            // really that much duplication, just would be nice to remove one of\n                            // these codepaths.\n                            const spawnedEntries = new Map();\n                            pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy);\n                            const dynamicRequestTree = diffRouteTreeAgainstCurrent(now, task, route, task.treeAtTimeOfPrefetch, tree, spawnedEntries, fetchStrategy);\n                            let needsDynamicRequest = spawnedEntries.size > 0;\n                            if (needsDynamicRequest) {\n                                spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries));\n                            }\n                            return 2;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n                break;\n            }\n        default:\n            {\n                route;\n            }\n    }\n    return 2;\n}\nfunction pingStaticHead(now, task, route) {\n    // The Head data for a page (metadata, viewport) is not really a route\n    // segment, in the sense that it doesn't appear in the route tree. But we\n    // store it in the cache as if it were, using a special key.\n    pingStaticSegmentData(now, task, route, (0, _cache.readOrCreateSegmentCacheEntry)(now, _types.FetchStrategy.PPR, route, route.metadata), task.key, route.metadata);\n}\nfunction pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy) {\n    pingRouteTreeAndIncludeDynamicData(now, task, route, route.metadata, false, spawnedEntries, // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === _types.FetchStrategy.LoadingBoundary ? _types.FetchStrategy.Full : fetchStrategy);\n}\n// TODO: Rename dynamic -> runtime throughout this module\nfunction pingSharedPartOfCacheComponentsTree(now, task, route, oldTree, newTree) {\n    // When Cache Components is enabled (or PPR, or a fully static route when PPR\n    // is disabled; those cases are treated equivalently to Cache Components), we\n    // start by prefetching each segment individually. Once we reach the \"new\"\n    // part of the tree  the part that doesn't exist on the current page  we\n    // may choose to switch to a runtime prefetch instead, based on the\n    // information sent by the server in the route tree.\n    //\n    // The traversal starts in the \"shared\" part of the tree. Once we reach the\n    // \"new\" part of the tree, we switch to a different traversal,\n    // pingNewPartOfCacheComponentsTree.\n    // Prefetch this segment's static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, newTree);\n    pingStaticSegmentData(now, task, route, segment, task.key, newTree);\n    // Recursively ping the children.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            if (!hasNetworkBandwidth(task)) {\n                // Stop prefetching segments until there's more bandwidth.\n                return 0;\n            }\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            let childExitStatus;\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // We're still in the \"shared\" part of the tree.\n                childExitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, oldTreeChild, newTreeChild);\n            } else {\n                // We've entered the \"new\" part of the tree. Switch\n                // traversal functions.\n                childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, newTreeChild);\n            }\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    return 2;\n}\nfunction pingNewPartOfCacheComponentsTree(now, task, route, tree) {\n    // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n    // exist on the current page. (In other words, we're deeper than the\n    // shared layouts.) Segments in here default to being prefetched statically.\n    // However, if the server instructs us to, we may switch to a runtime\n    // prefetch instead. Traverse the tree and check at each segment.\n    if (tree.hasRuntimePrefetch) {\n        // This route has a runtime prefetch response. Since we're below the shared\n        // layout, everything from this point should be prefetched using a single,\n        // combined runtime request, rather than using per-segment static requests.\n        // This is true even if some of the child segments are known to be fully\n        // static  once we've decided to perform a runtime prefetch, we might as\n        // well respond with the static segments in the same roundtrip. (That's how\n        // regular navigations work, too.) We'll still skip over segments that are\n        // already cached, though.\n        //\n        // It's the server's responsibility to set a reasonable value of\n        // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n        // server may send a value of `false` even if the user opts in, if it\n        // determines during build that the route is always fully static. There are\n        // more optimizations we can do once we implement fallback param\n        // tracking, too.\n        //\n        // Use the task object to collect the segments that need a runtime prefetch.\n        // This will signal to the outer task queue that a second traversal is\n        // required to construct a request tree.\n        if (task.spawnedRuntimePrefetches === null) {\n            task.spawnedRuntimePrefetches = new Set([\n                tree.requestKey\n            ]);\n        } else {\n            task.spawnedRuntimePrefetches.add(tree.requestKey);\n        }\n        // Then exit the traversal without prefetching anything further.\n        return 2;\n    }\n    // This segment should not be runtime prefetched. Prefetch its static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    pingStaticSegmentData(now, task, route, segment, task.key, tree);\n    if (tree.slots !== null) {\n        if (!hasNetworkBandwidth(task)) {\n            // Stop prefetching segments until there's more bandwidth.\n            return 0;\n        }\n        // Recursively ping the children.\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            const childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, childTree);\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    // This segment and all its children have finished prefetching.\n    return 2;\n}\nfunction diffRouteTreeAgainstCurrent(now, task, route, oldTree, newTree, spawnedEntries, fetchStrategy) {\n    // This is a single recursive traversal that does multiple things:\n    // - Finds the parts of the target route (newTree) that are not part of\n    //   of the current page (oldTree) by diffing them, using the same algorithm\n    //   as a real navigation.\n    // - Constructs a request tree (FlightRouterState) that describes which\n    //   segments need to be prefetched and which ones are already cached.\n    // - Creates a set of pending cache entries for the segments that need to\n    //   be prefetched, so that a subsequent prefetch task does not request the\n    //   same segments again.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    let requestTreeChildren = {};\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // This segment is already part of the current route. Keep traversing.\n                const requestTreeChild = diffRouteTreeAgainstCurrent(now, task, route, oldTreeChild, newTreeChild, spawnedEntries, fetchStrategy);\n                requestTreeChildren[parallelRouteKey] = requestTreeChild;\n            } else {\n                // This segment is not part of the current route. We're entering a\n                // part of the tree that we need to prefetch (unless everything is\n                // already cached).\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // When PPR is disabled, we can't prefetch per segment. We must\n                            // fallback to the old prefetch behavior and send a dynamic request.\n                            // Only routes that include a loading boundary can be prefetched in\n                            // this way.\n                            //\n                            // This is simlar to a \"full\" prefetch, but we're much more\n                            // conservative about which segments to include in the request.\n                            //\n                            // The server will only render up to the first loading boundary\n                            // inside new part of the tree. If there's no loading boundary\n                            // anywhere in the tree, the server will never return any data, so\n                            // we can skip the request.\n                            const subtreeHasLoadingBoundary = newTreeChild.hasLoadingBoundary !== _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary;\n                            const requestTreeChild = subtreeHasLoadingBoundary ? pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, newTreeChild, null, spawnedEntries) : (0, _cache.convertRouteTreeToFlightRouterState)(newTreeChild);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.PPRRuntime:\n                        {\n                            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n                            // not just the static PPR shell.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.Full:\n                        {\n                            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n                            // static and dynamic. We issue roughly the same request that we\n                            // would during a real navigation. The goal is that once the\n                            // navigation occurs, the router should not have to fetch any\n                            // additional data.\n                            //\n                            // Although the response will include dynamic data, opting into a\n                            // Full prefetch  via <Link prefetch={true}>  implicitly\n                            // instructs the cache to treat the response as \"static\", or non-\n                            // dynamic, since the whole point is to cache it for\n                            // future navigations.\n                            //\n                            // Construct a tree (currently a FlightRouterState) that represents\n                            // which segments need to be prefetched and which ones are already\n                            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n                            // send the request tree to the server and use the response to\n                            // populate the segment cache.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n            }\n        }\n    }\n    const requestTree = [\n        newTree.segment,\n        requestTreeChildren,\n        null,\n        null,\n        newTree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, tree, refetchMarkerContext, spawnedEntries) {\n    // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n    // server is only going to return a minimal loading state  it will stop\n    // rendering at the first loading boundary. Whereas a Full prefetch is\n    // intentionally aggressive and tries to pretfetch all the data that will be\n    // needed for a navigation, a LoadingBoundary prefetch is much more\n    // conservative. For example, it will omit from the request tree any segment\n    // that is already cached, regardles of whether it's partial or full. By\n    // contrast, a Full prefetch will refetch partial segments.\n    // \"inside-shared-layout\" tells the server where to start looking for a\n    // loading boundary.\n    let refetchMarker = refetchMarkerContext === null ? 'inside-shared-layout' : null;\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Add a refetch marker so the server knows\n                // to start rendering here.\n                // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n                // FlightRouterState from the request tree. I think this would probably\n                // already work even without any updates to the server. For consistency,\n                // though, I'll send the full tree and we'll look into this later as part\n                // of a larger redesign of the request protocol.\n                // Add the pending cache entry to the result map.\n                spawnedEntries.set(tree.requestKey, (0, _cache.upgradeToPendingSegment)(segment, // Set the fetch strategy to LoadingBoundary to indicate that the server\n                // might not include it in the pending response. If another route is able\n                // to issue a per-segment request, we'll do that in the background.\n                _types.FetchStrategy.LoadingBoundary));\n                if (refetchMarkerContext !== 'refetch') {\n                    refetchMarker = refetchMarkerContext = 'refetch';\n                } else {\n                // There's already a parent with a refetch marker, so we don't need\n                // to add another one.\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                const segmentHasLoadingBoundary = tree.hasLoadingBoundary === _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary;\n                if (segmentHasLoadingBoundary) {\n                    // This segment has a loading boundary, which means the server won't\n                    // render its children. So there's nothing left to prefetch along this\n                    // path. We can bail out.\n                    return (0, _cache.convertRouteTreeToFlightRouterState)(tree);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, childTree, refetchMarkerContext, spawnedEntries);\n        }\n    }\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRouteTreeAndIncludeDynamicData(now, task, route, tree, isInsideRefetchingParent, spawnedEntries, fetchStrategy) {\n    // The tree we're constructing is the same shape as the tree we're navigating\n    // to. But even though this is a \"new\" tree, some of the individual segments\n    // may be cached as a result of other route prefetches.\n    //\n    // So we need to find the first uncached segment along each path add an\n    // explicit \"refetch\" marker so the server knows where to start rendering.\n    // Once the server starts rendering along a path, it keeps rendering the\n    // entire subtree.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy, route, tree);\n    let spawnedSegment = null;\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Include it in the request.\n                spawnedSegment = (0, _cache.upgradeToPendingSegment)(segment, fetchStrategy);\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                if (segment.isPartial && (0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n                    // This means we're in one of these cases:\n                    //   - we have a static prefetch, and we're doing a runtime prefetch\n                    //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n                    // In either case, we need to include it in the request to get a more specific (or full) version.\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n        case _cache.EntryStatus.Rejected:\n            {\n                // There's either another prefetch currently in progress, or the previous\n                // attempt failed. If the new strategy can provide more content, fetch it again.\n                if ((0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRouteTreeAndIncludeDynamicData(now, task, route, childTree, isInsideRefetchingParent || spawnedSegment !== null, spawnedEntries, fetchStrategy);\n        }\n    }\n    if (spawnedSegment !== null) {\n        // Add the pending entry to the result map.\n        spawnedEntries.set(tree.requestKey, spawnedSegment);\n    }\n    // Don't bother to add a refetch marker if one is already present in a parent.\n    const refetchMarker = !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null;\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries) {\n    // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n    // a segment is part of the runtime prefetch, the tree is constructed by\n    // diffing against what's already in the prefetch cache. Otherwise, we send\n    // a regular FlightRouterState with no special markers.\n    //\n    // See pingRouteTreeAndIncludeDynamicData for details.\n    if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n        // This segment needs a runtime prefetch.\n        return pingRouteTreeAndIncludeDynamicData(now, task, route, tree, false, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n    }\n    let requestTreeChildren = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(now, task, route, childTree, spawnedRuntimePrefetches, spawnedEntries);\n        }\n    }\n    // This segment is not part of the runtime prefetch. Clone the base tree.\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        null\n    ];\n    return requestTree;\n}\nfunction pingStaticSegmentData(now, task, route, segment, routeKey, tree) {\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            // Upgrade to Pending so we know there's already a request in progress\n            spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(segment, _types.FetchStrategy.PPR), routeKey, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            {\n                // There's already a request in progress. Depending on what kind of\n                // request it is, we may want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a pending request, but because it's using the old\n                        // prefetching strategy, we can't be sure if it will be fulfilled by\n                        // the response  it might be inside the loading boundary. Perform\n                        // a revalidation, but because it's speculative, wait to do it at\n                        // background priority.\n                        if (background(task)) {\n                            // TODO: Instead of speculatively revalidating, consider including\n                            // `hasLoading` in the route tree prefetch response.\n                            pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        }\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // The existing entry in the cache was rejected. Depending on how it\n                // was originally fetched, we may or may not want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a rejected entry, but it was fetched using the loading\n                        // boundary strategy. So the reason it wasn't returned by the server\n                        // might just be because it was inside a loading boundary. Or because\n                        // there was a dynamic rewrite. Revalidate it using the per-\n                        // segment strategy.\n                        //\n                        // Because a rejected segment will definitely prevent the segment (and\n                        // all of its children) from rendering, we perform this revalidation\n                        // immediately instead of deferring it to a background task.\n                        pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            break;\n        default:\n            segment;\n    }\n// Segments do not have dependent tasks, so once the prefetch is initiated,\n// there's nothing else for us to do (except write the server data into the\n// entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\nfunction pingPPRSegmentRevalidation(now, route, routeKey, tree) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, _types.FetchStrategy.PPR, route, tree);\n    switch(revalidatingSegment.status){\n        case _cache.EntryStatus.Empty:\n            // Spawn a prefetch request and upsert the segment into the cache\n            // upon completion.\n            upsertSegmentOnCompletion(spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(revalidatingSegment, _types.FetchStrategy.PPR), routeKey, tree)), (0, _varypath.getSegmentVaryPathForRequest)(_types.FetchStrategy.PPR, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            break;\n        case _cache.EntryStatus.Fulfilled:\n        case _cache.EntryStatus.Rejected:\n            break;\n        default:\n            revalidatingSegment;\n    }\n}\nfunction pingFullSegmentRevalidation(now, route, tree, fetchStrategy) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, fetchStrategy, route, tree);\n    if (revalidatingSegment.status === _cache.EntryStatus.Empty) {\n        // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n        // segments that we need. So we don't initiate a request here directly. By\n        // returning a pending entry from this function, it signals to the caller\n        // that this segment should be included in the request that's sent to\n        // the server.\n        const pendingSegment = (0, _cache.upgradeToPendingSegment)(revalidatingSegment, fetchStrategy);\n        upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n        return pendingSegment;\n    } else {\n        // There's already a revalidation in progress.\n        const nonEmptyRevalidatingSegment = revalidatingSegment;\n        if ((0, _cache.canNewFetchStrategyProvideMoreContent)(nonEmptyRevalidatingSegment.fetchStrategy, fetchStrategy)) {\n            // The existing revalidation was fetched using a less specific strategy.\n            // Reset it and start a new revalidation.\n            const emptySegment = (0, _cache.overwriteRevalidatingSegmentCacheEntry)(fetchStrategy, route, tree);\n            const pendingSegment = (0, _cache.upgradeToPendingSegment)(emptySegment, fetchStrategy);\n            upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n            return pendingSegment;\n        }\n        switch(nonEmptyRevalidatingSegment.status){\n            case _cache.EntryStatus.Pending:\n                // There's already an in-progress prefetch that includes this segment.\n                return null;\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                // A previous revalidation attempt finished, but we chose not to replace\n                // the existing entry in the cache. Don't try again until or unless the\n                // revalidation entry expires.\n                return null;\n            default:\n                nonEmptyRevalidatingSegment;\n                return null;\n        }\n    }\n}\nconst noop = ()=>{};\nfunction upsertSegmentOnCompletion(promise, varyPath) {\n    // Wait for a segment to finish loading, then upsert it into the cache\n    promise.then((fulfilled)=>{\n        if (fulfilled !== null) {\n            // Received new data. Attempt to replace the existing entry in the cache.\n            (0, _cache.upsertSegmentEntry)(Date.now(), varyPath, fulfilled);\n        }\n    }, noop);\n}\nfunction doesCurrentSegmentMatchCachedSegment(route, currentSegment, cachedSegment) {\n    if (cachedSegment === _segment.PAGE_SEGMENT_KEY) {\n        // In the FlightRouterState stored by the router, the page segment has the\n        // rendered search params appended to the name of the segment. In the\n        // prefetch cache, however, this is stored separately. So, when comparing\n        // the router's current FlightRouterState to the cached FlightRouterState,\n        // we need to make sure we compare both parts of the segment.\n        // TODO: This is not modeled clearly. We use the same type,\n        // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n        // _and_ the server response format, when conceptually those are three\n        // different things and treated in different ways. We should encode more of\n        // this information into the type design so mistakes are less likely.\n        return currentSegment === (0, _segment.addSearchParamsIfPageSegment)(_segment.PAGE_SEGMENT_KEY, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    }\n    // Non-page segments are compared using the same function as the server\n    return (0, _matchsegments.matchSegment)(cachedSegment, currentSegment);\n}\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\nfunction compareQueuePriority(a, b) {\n    // Since the queue is a MinHeap, this should return a positive number if b is\n    // higher priority than a, and a negative number if a is higher priority\n    // than b.\n    // `priority` is an integer, where higher numbers are higher priority.\n    const priorityDiff = b.priority - a.priority;\n    if (priorityDiff !== 0) {\n        return priorityDiff;\n    }\n    // If the priority is the same, check which phase the prefetch is in  is it\n    // prefetching the route tree, or the segments? Route trees are prioritized.\n    const phaseDiff = b.phase - a.phase;\n    if (phaseDiff !== 0) {\n        return phaseDiff;\n    }\n    // Finally, check the insertion order. `sortId` is an incrementing counter\n    // assigned to prefetches. We want to process the newest prefetches first.\n    return b.sortId - a.sortId;\n}\nfunction heapPush(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    node._heapIndex = index;\n    heapSiftUp(heap, node, index);\n}\nfunction heapPeek(heap) {\n    return heap.length === 0 ? null : heap[0];\n}\nfunction heapPop(heap) {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    first._heapIndex = -1;\n    const last = heap.pop();\n    if (last !== first) {\n        heap[0] = last;\n        last._heapIndex = 0;\n        heapSiftDown(heap, last, 0);\n    }\n    return first;\n}\nfunction heapDelete(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        node._heapIndex = -1;\n        if (heap.length !== 0) {\n            const last = heap.pop();\n            if (last !== node) {\n                heap[index] = last;\n                last._heapIndex = index;\n                heapSiftDown(heap, last, index);\n            }\n        }\n    }\n}\nfunction heapResift(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        if (index === 0) {\n            heapSiftDown(heap, node, 0);\n        } else {\n            const parentIndex = index - 1 >>> 1;\n            const parent = heap[parentIndex];\n            if (compareQueuePriority(parent, node) > 0) {\n                // The parent is larger. Sift up.\n                heapSiftUp(heap, node, index);\n            } else {\n                // The parent is smaller (or equal). Sift down.\n                heapSiftDown(heap, node, index);\n            }\n        }\n    }\n}\nfunction heapSiftUp(heap, node, i) {\n    let index = i;\n    while(index > 0){\n        const parentIndex = index - 1 >>> 1;\n        const parent = heap[parentIndex];\n        if (compareQueuePriority(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            node._heapIndex = parentIndex;\n            heap[index] = parent;\n            parent._heapIndex = index;\n            index = parentIndex;\n        } else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction heapSiftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while(index < halfLength){\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compareQueuePriority(left, node) < 0) {\n            if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n                heap[index] = right;\n                right._heapIndex = index;\n                heap[rightIndex] = node;\n                node._heapIndex = rightIndex;\n                index = rightIndex;\n            } else {\n                heap[index] = left;\n                left._heapIndex = index;\n                heap[leftIndex] = node;\n                node._heapIndex = leftIndex;\n                index = leftIndex;\n            }\n        } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n            heap[index] = right;\n            right._heapIndex = index;\n            heap[rightIndex] = node;\n            node._heapIndex = rightIndex;\n            index = rightIndex;\n        } else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=scheduler.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7529, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/links.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    IDLE_LINK_STATUS: null,\n    PENDING_LINK_STATUS: null,\n    mountFormInstance: null,\n    mountLinkInstance: null,\n    onLinkVisibilityChanged: null,\n    onNavigationIntent: null,\n    pingVisibleLinks: null,\n    setLinkForCurrentNavigation: null,\n    unmountLinkForCurrentNavigation: null,\n    unmountPrefetchableInstance: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    IDLE_LINK_STATUS: function() {\n        return IDLE_LINK_STATUS;\n    },\n    PENDING_LINK_STATUS: function() {\n        return PENDING_LINK_STATUS;\n    },\n    mountFormInstance: function() {\n        return mountFormInstance;\n    },\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    setLinkForCurrentNavigation: function() {\n        return setLinkForCurrentNavigation;\n    },\n    unmountLinkForCurrentNavigation: function() {\n        return unmountLinkForCurrentNavigation;\n    },\n    unmountPrefetchableInstance: function() {\n        return unmountPrefetchableInstance;\n    }\n});\nconst _types = require(\"./segment-cache/types\");\nconst _cachekey = require(\"./segment-cache/cache-key\");\nconst _scheduler = require(\"./segment-cache/scheduler\");\nconst _react = require(\"react\");\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\nconst PENDING_LINK_STATUS = {\n    pending: true\n};\nconst IDLE_LINK_STATUS = {\n    pending: false\n};\nfunction setLinkForCurrentNavigation(link) {\n    (0, _react.startTransition)(()=>{\n        linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link?.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\nfunction unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    if (typeof window !== 'undefined') {\n        const { createPrefetchURL } = require('./app-router-utils');\n        try {\n            return createPrefetchURL(href);\n        } catch  {\n            // createPrefetchURL sometimes throws an error if an invalid URL is\n            // provided, though I'm not sure if it's actually necessary.\n            // TODO: Consider removing the throw from the inner function, or change it\n            // to reportError. Or maybe the error isn't even necessary for automatic\n            // prefetches, just navigations.\n            const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n            reportErrorFn(`Cannot prefetch '${href}' because it cannot be converted to a URL.`);\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nfunction mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nfunction mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nfunction unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _scheduler.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (process.env.NODE_ENV !== 'production') {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        prefetchableAndVisible.add(instance);\n    } else {\n        prefetchableAndVisible.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Default);\n}\nfunction onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (process.env.__NEXT_DYNAMIC_ON_HOVER && unstable_upgradeToDynamicPrefetch) {\n            // Switch to a full prefetch\n            instance.fetchStrategy = _types.FetchStrategy.Full;\n        }\n        rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    // Ensures that app-router-instance is not compiled in the server bundle\n    if (typeof window !== 'undefined') {\n        const existingPrefetchTask = instance.prefetchTask;\n        if (!instance.isVisible) {\n            // Cancel any in-progress prefetch task. (If it already finished then this\n            // is a no-op.)\n            if (existingPrefetchTask !== null) {\n                (0, _scheduler.cancelPrefetchTask)(existingPrefetchTask);\n            }\n            // We don't need to reset the prefetchTask to null upon cancellation; an\n            // old task object can be rescheduled with reschedulePrefetchTask. This is a\n            // micro-optimization but also makes the code simpler (don't need to\n            // worry about whether an old task object is stale).\n            return;\n        }\n        const { getCurrentAppRouterState } = require('./app-router-instance');\n        const appRouterState = getCurrentAppRouterState();\n        if (appRouterState !== null) {\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            if (existingPrefetchTask === null) {\n                // Initiate a prefetch task.\n                const nextUrl = appRouterState.nextUrl;\n                const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n                instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n            } else {\n                // We already have an old task object that we can reschedule. This is\n                // effectively the same as canceling the old task and creating a new one.\n                (0, _scheduler.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n            }\n        }\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !(0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _scheduler.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _types.PrefetchPriority.Default, null);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=links.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,kBAAkB;IAClB,qBAAqB;IACrB,mBAAmB;IACnB,mBAAmB;IACnB,yBAAyB;IACzB,oBAAoB;IACpB,kBAAkB;IAClB,6BAA6B;IAC7B,iCAAiC;IACjC,6BAA6B;AACjC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,kBAAkB;QACd,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;IACA,mBAAmB;QACf,OAAO;IACX;IACA,mBAAmB;QACf,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;IACA,oBAAoB;QAChB,OAAO;IACX;IACA,kBAAkB;QACd,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,iCAAiC;QAC7B,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,yEAAyE;AACzE,4DAA4D;AAC5D,IAAI,8BAA8B;AAClC,MAAM,sBAAsB;IACxB,SAAS;AACb;AACA,MAAM,mBAAmB;IACrB,SAAS;AACb;AACA,SAAS,4BAA4B,IAAI;IACrC,CAAC,GAAG,OAAO,eAAe,EAAE;QACxB,6BAA6B,wBAAwB;QACrD,MAAM,wBAAwB;QAC9B,8BAA8B;IAClC;AACJ;AACA,SAAS,gCAAgC,IAAI;IACzC,IAAI,gCAAgC,MAAM;QACtC,8BAA8B;IAClC;AACJ;AACA,2EAA2E;AAC3E,mEAAmE;AACnE,MAAM,eAAe,OAAO,YAAY,aAAa,IAAI,YAAY,IAAI;AACzE,6EAA6E;AAC7E,4EAA4E;AAC5E,0EAA0E;AAC1E,iBAAiB;AACjB,MAAM,yBAAyB,IAAI;AACnC,0EAA0E;AAC1E,MAAM,WAAW,OAAO,yBAAyB,aAAa,IAAI,qBAAqB,iBAAiB;IACpG,YAAY;AAChB,KAAK;AACL,SAAS,kBAAkB,OAAO,EAAE,QAAQ;IACxC,MAAM,mBAAmB,aAAa,GAAG,CAAC;IAC1C,IAAI,qBAAqB,WAAW;QAChC,0EAA0E;QAC1E,2EAA2E;QAC3E,+CAA+C;QAC/C,4BAA4B;IAChC;IACA,+DAA+D;IAC/D,aAAa,GAAG,CAAC,SAAS;IAC1B,IAAI,aAAa,MAAM;QACnB,SAAS,OAAO,CAAC;IACrB;AACJ;AACA,SAAS,sBAAsB,IAAI;IAC/B;;SAcO;QACH,OAAO;IACX;AACJ;AACA,SAAS,kBAAkB,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,aAAa,EAAE,eAAe,EAAE,uBAAuB;IACrG,IAAI,iBAAiB;QACjB,MAAM,cAAc,sBAAsB;QAC1C,IAAI,gBAAgB,MAAM;YACtB,MAAM,WAAW;gBACb;gBACA;gBACA,WAAW;gBACX,cAAc;gBACd,cAAc,YAAY,IAAI;gBAC9B;YACJ;YACA,kEAAkE;YAClE,iDAAiD;YACjD,kBAAkB,SAAS;YAC3B,OAAO;QACX;IACJ;IACA,yEAAyE;IACzE,mDAAmD;IACnD,MAAM,WAAW;QACb;QACA;QACA,WAAW;QACX,cAAc;QACd,cAAc;QACd;IACJ;IACA,OAAO;AACX;AACA,SAAS,kBAAkB,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,aAAa;IAC3D,MAAM,cAAc,sBAAsB;IAC1C,IAAI,gBAAgB,MAAM;QACtB,uDAAuD;QACvD,2EAA2E;QAC3E,4EAA4E;QAC5E,gEAAgE;QAChE;IACJ;IACA,MAAM,WAAW;QACb;QACA;QACA,WAAW;QACX,cAAc;QACd,cAAc,YAAY,IAAI;QAC9B,yBAAyB;IAC7B;IACA,kBAAkB,SAAS;AAC/B;AACA,SAAS,4BAA4B,OAAO;IACxC,MAAM,WAAW,aAAa,GAAG,CAAC;IAClC,IAAI,aAAa,WAAW;QACxB,aAAa,MAAM,CAAC;QACpB,uBAAuB,MAAM,CAAC;QAC9B,MAAM,eAAe,SAAS,YAAY;QAC1C,IAAI,iBAAiB,MAAM;YACvB,CAAC,GAAG,WAAW,kBAAkB,EAAE;QACvC;IACJ;IACA,IAAI,aAAa,MAAM;QACnB,SAAS,SAAS,CAAC;IACvB;AACJ;AACA,SAAS,gBAAgB,OAAO;IAC5B,KAAK,MAAM,SAAS,QAAQ;QACxB,kEAAkE;QAClE,yEAAyE;QACzE,sCAAsC;QACtC,MAAM,YAAY,MAAM,iBAAiB,GAAG;QAC5C,wBAAwB,MAAM,MAAM,EAAE;IAC1C;AACJ;AACA,SAAS,wBAAwB,OAAO,EAAE,SAAS;IAC/C,wCAA2C;QACvC,qEAAqE;QACrE,0DAA0D;QAC1D,sCAAsC;QACtC;IACJ;;;IACA,MAAM;AAWV;AACA,SAAS,mBAAmB,OAAO,EAAE,iCAAiC;IAClE,MAAM,WAAW,aAAa,GAAG,CAAC;IAClC,IAAI,aAAa,WAAW;QACxB;IACJ;IACA,yCAAyC;IACzC,IAAI,aAAa,WAAW;QACxB;;QAIA,uBAAuB,UAAU,OAAO,gBAAgB,CAAC,MAAM;IACnE;AACJ;AACA,SAAS,uBAAuB,QAAQ,EAAE,QAAQ;IAC9C,wEAAwE;IACxE;;AA8BJ;AACA,SAAS,iBAAiB,OAAO,EAAE,IAAI;IACnC,4EAA4E;IAC5E,6EAA6E;IAC7E,uDAAuD;IACvD,EAAE;IACF,yEAAyE;IACzE,qEAAqE;IACrE,sBAAsB;IACtB,KAAK,MAAM,YAAY,uBAAuB;QAC1C,MAAM,OAAO,SAAS,YAAY;QAClC,IAAI,SAAS,QAAQ,CAAC,CAAC,GAAG,WAAW,mBAAmB,EAAE,MAAM,SAAS,OAAO;YAC5E;QACJ;QACA,sEAAsE;QACtE,WAAW;QACX,IAAI,SAAS,MAAM;YACf,CAAC,GAAG,WAAW,kBAAkB,EAAE;QACvC;QACA,MAAM,WAAW,CAAC,GAAG,UAAU,cAAc,EAAE,SAAS,YAAY,EAAE;QACtE,SAAS,YAAY,GAAG,CAAC,GAAG,WAAW,oBAAoB,EAAE,UAAU,MAAM,SAAS,aAAa,EAAE,OAAO,gBAAgB,CAAC,OAAO,EAAE;IAC1I;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 7773, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"pathHasPrefix\", {\n    enumerable: true,\n    get: function() {\n        return pathHasPrefix;\n    }\n});\nconst _parsepath = require(\"./parse-path\");\nfunction pathHasPrefix(path, prefix) {\n    if (typeof path !== 'string') {\n        return false;\n    }\n    const { pathname } = (0, _parsepath.parsePath)(path);\n    return pathname === prefix || pathname.startsWith(prefix + '/');\n}\n\n//# sourceMappingURL=path-has-prefix.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,iBAAiB;IAC5C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,cAAc,IAAI,EAAE,MAAM;IAC/B,IAAI,OAAO,SAAS,UAAU;QAC1B,OAAO;IACX;IACA,MAAM,EAAE,QAAQ,EAAE,GAAG,CAAC,GAAG,WAAW,SAAS,EAAE;IAC/C,OAAO,aAAa,UAAU,SAAS,UAAU,CAAC,SAAS;AAC/D,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 7794, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/has-base-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasBasePath\", {\n    enumerable: true,\n    get: function() {\n        return hasBasePath;\n    }\n});\nconst _pathhasprefix = require(\"../shared/lib/router/utils/path-has-prefix\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction hasBasePath(path) {\n    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=has-base-path.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,eAAe;IAC1C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,WAAW,wCAAsC;AACvD,SAAS,YAAY,IAAI;IACrB,OAAO,CAAC,GAAG,eAAe,aAAa,EAAE,MAAM;AACnD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 7819, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/router/utils/is-local-url.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isLocalURL\", {\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n});\nconst _utils = require(\"../../utils\");\nconst _hasbasepath = require(\"../../../../client/has-base-path\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\n\n//# sourceMappingURL=is-local-url.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;;;;;AACN,MAAM;AACN,SAAS,WAAW,GAAG;IACnB,gEAAgE;IAChE,IAAI,CAAC,CAAC,GAAG,OAAO,aAAa,EAAE,MAAM,OAAO;IAC5C,IAAI;QACA,4DAA4D;QAC5D,MAAM,iBAAiB,CAAC,GAAG,OAAO,iBAAiB;QACnD,MAAM,WAAW,IAAI,IAAI,KAAK;QAC9B,OAAO,SAAS,MAAM,KAAK,kBAAkB,CAAC,GAAG,aAAa,WAAW,EAAE,SAAS,QAAQ;IAChG,EAAE,OAAO,GAAG;QACR,OAAO;IACX;AACJ,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 7850, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/utils/error-once.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"errorOnce\", {\n    enumerable: true,\n    get: function() {\n        return errorOnce;\n    }\n});\nlet errorOnce = (_)=>{};\nif (process.env.NODE_ENV !== 'production') {\n    const errors = new Set();\n    errorOnce = (msg)=>{\n        if (!errors.has(msg)) {\n            console.error(msg);\n        }\n        errors.add(msg);\n    };\n}\n\n//# sourceMappingURL=error-once.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,aAAa;IACxC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,IAAI,YAAY,CAAC,KAAK;AACtB,wCAA2C;IACvC,MAAM,SAAS,IAAI;IACnB,YAAY,CAAC;QACT,IAAI,CAAC,OAAO,GAAG,CAAC,MAAM;YAClB,QAAQ,KAAK,CAAC;QAClB;QACA,OAAO,GAAG,CAAC;IACf;AACJ,EAEA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 7873, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-dir/link.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    useLinkStatus: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */ default: function() {\n        return LinkComponent;\n    },\n    useLinkStatus: function() {\n        return useLinkStatus;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _formaturl = require(\"../../shared/lib/router/utils/format-url\");\nconst _approutercontextsharedruntime = require(\"../../shared/lib/app-router-context.shared-runtime\");\nconst _usemergedref = require(\"../use-merged-ref\");\nconst _utils = require(\"../../shared/lib/utils\");\nconst _addbasepath = require(\"../add-base-path\");\nconst _warnonce = require(\"../../shared/lib/utils/warn-once\");\nconst _links = require(\"../components/links\");\nconst _islocalurl = require(\"../../shared/lib/router/utils/is-local-url\");\nconst _types = require(\"../components/segment-cache/types\");\nconst _erroronce = require(\"../../shared/lib/utils/error-once\");\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {\n    if (typeof window !== 'undefined') {\n        const { nodeName } = e.currentTarget;\n        // anchors inside an svg have a lowercase nodeName\n        const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n        if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {\n            // ignore click for browsers default behavior\n            return;\n        }\n        if (!(0, _islocalurl.isLocalURL)(href)) {\n            if (replace) {\n                // browser default behavior does not replace the history state\n                // so we need to do it manually\n                e.preventDefault();\n                location.replace(href);\n            }\n            // ignore click for browsers default behavior\n            return;\n        }\n        e.preventDefault();\n        if (onNavigate) {\n            let isDefaultPrevented = false;\n            onNavigate({\n                preventDefault: ()=>{\n                    isDefaultPrevented = true;\n                }\n            });\n            if (isDefaultPrevented) {\n                return;\n            }\n        }\n        const { dispatchNavigateAction } = require('../components/app-router-instance');\n        _react.default.startTransition(()=>{\n            dispatchNavigateAction(as || href, replace ? 'replace' : 'push', scroll ?? true, linkInstanceRef.current);\n        });\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\nfunction LinkComponent(props) {\n    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);\n    let children;\n    const linkInstanceRef = (0, _react.useRef)(null);\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _types.FetchStrategy.PPR;\n    if (process.env.NODE_ENV !== 'production') {\n        function createPropError(args) {\n            return Object.defineProperty(new Error(`Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` + (typeof window !== 'undefined' ? \"\\nOpen your browser's console to view the Component stack trace.\" : '')), \"__NEXT_ERROR_CODE\", {\n                value: \"E319\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            unstable_dynamicOnHover: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true,\n            onNavigate: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'prefetch') {\n                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean | \"auto\"`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                const _ = key;\n            }\n        });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (props.locale) {\n            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');\n        }\n        if (!asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw Object.defineProperty(new Error(`Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E267\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        const resolvedHref = formatStringOrUrl(hrefProp);\n        return {\n            href: resolvedHref,\n            as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n        };\n    }, [\n        hrefProp,\n        asProp\n    ]);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (children?.$$typeof === Symbol.for('react.lazy')) {\n            throw Object.defineProperty(new Error(`\\`<Link legacyBehavior>\\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \\`<a>\\` tag.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E863\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (process.env.NODE_ENV === 'development') {\n            if (onClick) {\n                console.warn(`\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`);\n            }\n            if (onMouseEnterProp) {\n                console.warn(`\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw Object.defineProperty(new Error(`No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E320\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw Object.defineProperty(new Error(`Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? \" \\nOpen your browser's console to view the Component stack trace.\" : '')), \"__NEXT_ERROR_CODE\", {\n                    value: \"E266\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {\n            child = _react.default.Children.only(children);\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            if (children?.type === 'a') {\n                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E209\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n    // mount. In the future we will also use this to keep track of all the\n    // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n    // a revalidation or refresh.\n    const observeLinkVisibilityOnMount = _react.default.useCallback((element)=>{\n        if (router !== null) {\n            linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);\n        }\n        return ()=>{\n            if (linkInstanceRef.current) {\n                (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);\n                linkInstanceRef.current = null;\n            }\n            (0, _links.unmountPrefetchableInstance)(element);\n        };\n    }, [\n        prefetchEnabled,\n        href,\n        router,\n        fetchStrategy,\n        setOptimisticLinkStatus\n    ]);\n    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);\n    const childProps = {\n        ref: mergedRef,\n        onClick (e) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!e) {\n                    throw Object.defineProperty(new Error(`Component rendered inside next/link has to pass click event to \"onClick\" prop.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E312\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        },\n        onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START ? undefined : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled) {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        }\n    };\n    // If the url is absolute, we can bypass the logic to prepend the basePath.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        childProps.href = (0, _addbasepath.addBasePath)(as);\n    }\n    let link;\n    if (legacyBehavior) {\n        if (process.env.NODE_ENV === 'development') {\n            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\\n\\n' + 'npx @next/codemod@latest new-link .\\n\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');\n        }\n        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);\n    } else {\n        link = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            ...restProps,\n            ...childProps,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {\n        value: linkStatus,\n        children: link\n    });\n}\nconst LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);\nconst useLinkStatus = ()=>{\n    return (0, _react.useContext)(LinkStatusContext);\n};\nfunction getFetchStrategyFromPrefetchProp(prefetchProp) {\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        if (prefetchProp === true) {\n            return _types.FetchStrategy.Full;\n        }\n        // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n        // This will also include invalid prop values that don't match the types specified here.\n        // (although those should've been filtered out by prop validation in dev)\n        prefetchProp;\n        return _types.FetchStrategy.PPR;\n    } else {\n        return prefetchProp === null || prefetchProp === 'auto' ? _types.FetchStrategy.PPR : // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n        // (although invalid values should've been filtered out by prop validation in dev)\n        _types.FetchStrategy.Full;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=link.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,SAAS;IACT,eAAe;AACnB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb;;;;;;;;;CASH,GAAG,SAAS;QACL,OAAO;IACX;IACA,eAAe;QACX,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,SAAS,WAAW,GAAG,0BAA0B,CAAC;AACxD,MAAM;AACN,MAAM;AACN,MAAM;;;;;AACN,MAAM;;;;;AACN,MAAM;AACN,MAAM;;;;;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,gBAAgB,KAAK;IAC1B,MAAM,cAAc,MAAM,aAAa;IACvC,MAAM,SAAS,YAAY,YAAY,CAAC;IACxC,OAAO,UAAU,WAAW,WAAW,MAAM,OAAO,IAAI,MAAM,OAAO,IAAI,MAAM,QAAQ,IAAI,MAAM,MAAM,IAAI,6BAA6B;IACxI,MAAM,WAAW,IAAI,MAAM,WAAW,CAAC,KAAK,KAAK;AACrD;AACA,SAAS,YAAY,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,eAAe,EAAE,OAAO,EAAE,MAAM,EAAE,UAAU;IAC1E;;AAmCJ;AACA,SAAS,kBAAkB,cAAc;IACrC,IAAI,OAAO,mBAAmB,UAAU;QACpC,OAAO;IACX;IACA,OAAO,CAAC,GAAG,WAAW,SAAS,EAAE;AACrC;AACA,SAAS,cAAc,KAAK;IACxB,MAAM,CAAC,YAAY,wBAAwB,GAAG,CAAC,GAAG,OAAO,aAAa,EAAE,OAAO,gBAAgB;IAC/F,IAAI;IACJ,MAAM,kBAAkB,CAAC,GAAG,OAAO,MAAM,EAAE;IAC3C,MAAM,EAAE,MAAM,QAAQ,EAAE,IAAI,MAAM,EAAE,UAAU,YAAY,EAAE,UAAU,eAAe,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,cAAc,gBAAgB,EAAE,cAAc,gBAAgB,EAAE,iBAAiB,KAAK,EAAE,UAAU,EAAE,KAAK,YAAY,EAAE,uBAAuB,EAAE,GAAG,WAAW,GAAG;IACzS,WAAW;IACX,IAAI,kBAAkB,CAAC,OAAO,aAAa,YAAY,OAAO,aAAa,QAAQ,GAAG;QAClF,WAAW,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,KAAK;YAC/C,UAAU;QACd;IACJ;IACA,MAAM,SAAS,OAAO,OAAO,CAAC,UAAU,CAAC,+BAA+B,gBAAgB;IACxF,MAAM,kBAAkB,iBAAiB;IACzC,MAAM,gBAAgB,iBAAiB,QAAQ,iCAAiC,gBAAgB,OAAO,aAAa,CAAC,GAAG;IACxH,wCAA2C;QACvC,SAAS,gBAAgB,IAAI;YACzB,OAAO,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,6BAA6B,EAAE,KAAK,GAAG,CAAC,aAAa,EAAE,KAAK,QAAQ,CAAC,0BAA0B,EAAE,KAAK,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,sCAAgC,0BAAqE,EAAE,IAAI,qBAAqB;gBACjS,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;QACA,sCAAsC;QACtC,MAAM,qBAAqB;YACvB,MAAM;QACV;QACA,MAAM,gBAAgB,OAAO,IAAI,CAAC;QAClC,cAAc,OAAO,CAAC,CAAC;YACnB,IAAI,QAAQ,QAAQ;gBAChB,IAAI,KAAK,CAAC,IAAI,IAAI,QAAQ,OAAO,KAAK,CAAC,IAAI,KAAK,YAAY,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU;oBACxF,MAAM,gBAAgB;wBAClB;wBACA,UAAU;wBACV,QAAQ,KAAK,CAAC,IAAI,KAAK,OAAO,SAAS,OAAO,KAAK,CAAC,IAAI;oBAC5D;gBACJ;YACJ,OAAO;gBACH,sCAAsC;gBACtC,MAAM,IAAI;YACd;QACJ;QACA,sCAAsC;QACtC,MAAM,qBAAqB;YACvB,IAAI;YACJ,SAAS;YACT,QAAQ;YACR,SAAS;YACT,UAAU;YACV,UAAU;YACV,yBAAyB;YACzB,SAAS;YACT,cAAc;YACd,cAAc;YACd,gBAAgB;YAChB,YAAY;QAChB;QACA,MAAM,gBAAgB,OAAO,IAAI,CAAC;QAClC,cAAc,OAAO,CAAC,CAAC;YACnB,MAAM,UAAU,OAAO,KAAK,CAAC,IAAI;YACjC,IAAI,QAAQ,MAAM;gBACd,IAAI,KAAK,CAAC,IAAI,IAAI,YAAY,YAAY,YAAY,UAAU;oBAC5D,MAAM,gBAAgB;wBAClB;wBACA,UAAU;wBACV,QAAQ;oBACZ;gBACJ;YACJ,OAAO,IAAI,QAAQ,aAAa,QAAQ,kBAAkB,QAAQ,kBAAkB,QAAQ,cAAc;gBACtG,IAAI,KAAK,CAAC,IAAI,IAAI,YAAY,YAAY;oBACtC,MAAM,gBAAgB;wBAClB;wBACA,UAAU;wBACV,QAAQ;oBACZ;gBACJ;YACJ,OAAO,IAAI,QAAQ,aAAa,QAAQ,YAAY,QAAQ,aAAa,QAAQ,cAAc,QAAQ,oBAAoB,QAAQ,2BAA2B;gBAC1J,IAAI,KAAK,CAAC,IAAI,IAAI,QAAQ,YAAY,WAAW;oBAC7C,MAAM,gBAAgB;wBAClB;wBACA,UAAU;wBACV,QAAQ;oBACZ;gBACJ;YACJ,OAAO,IAAI,QAAQ,YAAY;gBAC3B,IAAI,KAAK,CAAC,IAAI,IAAI,QAAQ,YAAY,aAAa,KAAK,CAAC,IAAI,KAAK,QAAQ;oBACtE,MAAM,gBAAgB;wBAClB;wBACA,UAAU;wBACV,QAAQ;oBACZ;gBACJ;YACJ,OAAO;gBACH,sCAAsC;gBACtC,MAAM,IAAI;YACd;QACJ;IACJ;IACA,wCAA2C;QACvC,IAAI,MAAM,MAAM,EAAE;YACd,CAAC,GAAG,UAAU,QAAQ,EAAE;QAC5B;QACA,IAAI,CAAC,QAAQ;YACT,IAAI;YACJ,IAAI,OAAO,aAAa,UAAU;gBAC9B,OAAO;YACX,OAAO,IAAI,OAAO,aAAa,YAAY,OAAO,SAAS,QAAQ,KAAK,UAAU;gBAC9E,OAAO,SAAS,QAAQ;YAC5B;YACA,IAAI,MAAM;gBACN,MAAM,oBAAoB,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,UAAU,QAAQ,UAAU,CAAC,QAAQ,QAAQ,QAAQ,CAAC;gBACtG,IAAI,mBAAmB;oBACnB,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,eAAe,EAAE,KAAK,2IAA2I,CAAC,GAAG,qBAAqB;wBAC7N,OAAO;wBACP,YAAY;wBACZ,cAAc;oBAClB;gBACJ;YACJ;QACJ;IACJ;IACA,MAAM,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,OAAO,OAAO,CAAC,OAAO,CAAC;QACxC,MAAM,eAAe,kBAAkB;QACvC,OAAO;YACH,MAAM;YACN,IAAI,SAAS,kBAAkB,UAAU;QAC7C;IACJ,GAAG;QACC;QACA;KACH;IACD,oFAAoF;IACpF,IAAI;IACJ,IAAI,gBAAgB;QAChB,IAAI,UAAU,aAAa,OAAO,GAAG,CAAC,eAAe;YACjD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,oQAAoQ,CAAC,GAAG,qBAAqB;gBAChU,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;QACA,wCAA4C;YACxC,IAAI,SAAS;gBACT,QAAQ,IAAI,CAAC,CAAC,kDAAkD,EAAE,SAAS,sGAAsG,CAAC;YACtL;YACA,IAAI,kBAAkB;gBAClB,QAAQ,IAAI,CAAC,CAAC,uDAAuD,EAAE,SAAS,2GAA2G,CAAC;YAChM;YACA,IAAI;gBACA,QAAQ,OAAO,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;YACzC,EAAE,OAAO,KAAK;gBACV,IAAI,CAAC,UAAU;oBACX,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,qDAAqD,EAAE,SAAS,8EAA8E,CAAC,GAAG,qBAAqB;wBAC1M,OAAO;wBACP,YAAY;wBACZ,cAAc;oBAClB;gBACJ;gBACA,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,2DAA2D,EAAE,SAAS,0FAA0F,CAAC,GAAG,CAAC,sCAAgC,0BAAsE,EAAE,IAAI,qBAAqB;oBACzU,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;QACJ;;IAGJ,OAAO;QACH,wCAA4C;YACxC,IAAI,UAAU,SAAS,KAAK;gBACxB,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,oKAAoK,qBAAqB;oBAC3N,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;QACJ;IACJ;IACA,MAAM,WAAW,iBAAiB,SAAS,OAAO,UAAU,YAAY,MAAM,GAAG,GAAG;IACpF,4EAA4E;IAC5E,sEAAsE;IACtE,4EAA4E;IAC5E,6BAA6B;IAC7B,MAAM,+BAA+B,OAAO,OAAO,CAAC,WAAW,CAAC,CAAC;QAC7D,IAAI,WAAW,MAAM;YACjB,gBAAgB,OAAO,GAAG,CAAC,GAAG,OAAO,iBAAiB,EAAE,SAAS,MAAM,QAAQ,eAAe,iBAAiB;QACnH;QACA,OAAO;YACH,IAAI,gBAAgB,OAAO,EAAE;gBACzB,CAAC,GAAG,OAAO,+BAA+B,EAAE,gBAAgB,OAAO;gBACnE,gBAAgB,OAAO,GAAG;YAC9B;YACA,CAAC,GAAG,OAAO,2BAA2B,EAAE;QAC5C;IACJ,GAAG;QACC;QACA;QACA;QACA;QACA;KACH;IACD,MAAM,YAAY,CAAC,GAAG,cAAc,YAAY,EAAE,8BAA8B;IAChF,MAAM,aAAa;QACf,KAAK;QACL,SAAS,CAAC;YACN,wCAA2C;gBACvC,IAAI,CAAC,GAAG;oBACJ,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,8EAA8E,CAAC,GAAG,qBAAqB;wBAC1I,OAAO;wBACP,YAAY;wBACZ,cAAc;oBAClB;gBACJ;YACJ;YACA,IAAI,CAAC,kBAAkB,OAAO,YAAY,YAAY;gBAClD,QAAQ;YACZ;YACA,IAAI,kBAAkB,MAAM,KAAK,IAAI,OAAO,MAAM,KAAK,CAAC,OAAO,KAAK,YAAY;gBAC5E,MAAM,KAAK,CAAC,OAAO,CAAC;YACxB;YACA,IAAI,CAAC,QAAQ;gBACT;YACJ;YACA,IAAI,EAAE,gBAAgB,EAAE;gBACpB;YACJ;YACA,YAAY,GAAG,MAAM,IAAI,iBAAiB,SAAS,QAAQ;QAC/D;QACA,cAAc,CAAC;YACX,IAAI,CAAC,kBAAkB,OAAO,qBAAqB,YAAY;gBAC3D,iBAAiB;YACrB;YACA,IAAI,kBAAkB,MAAM,KAAK,IAAI,OAAO,MAAM,KAAK,CAAC,YAAY,KAAK,YAAY;gBACjF,MAAM,KAAK,CAAC,YAAY,CAAC;YAC7B;YACA,IAAI,CAAC,QAAQ;gBACT;YACJ;YACA,wCAAgE;gBAC5D;YACJ;;;YACA,MAAM;QAEV;QACA,cAAc,sCAAyC,0BAAY,SAAS,aAAa,CAAC;YACtF,IAAI,CAAC,kBAAkB,OAAO,qBAAqB,YAAY;gBAC3D,iBAAiB;YACrB;YACA,IAAI,kBAAkB,MAAM,KAAK,IAAI,OAAO,MAAM,KAAK,CAAC,YAAY,KAAK,YAAY;gBACjF,MAAM,KAAK,CAAC,YAAY,CAAC;YAC7B;YACA,IAAI,CAAC,QAAQ;gBACT;YACJ;YACA,IAAI,CAAC,iBAAiB;gBAClB;YACJ;YACA,MAAM,2BAA2B,4BAA4B;YAC7D,CAAC,GAAG,OAAO,kBAAkB,EAAE,EAAE,aAAa,EAAE;QACpD;IACJ;IACA,2EAA2E;IAC3E,IAAI,CAAC,GAAG,OAAO,aAAa,EAAE,KAAK;QAC/B,WAAW,IAAI,GAAG;IACtB,OAAO,IAAI,CAAC,kBAAkB,YAAY,MAAM,IAAI,KAAK,OAAO,CAAC,CAAC,UAAU,MAAM,KAAK,GAAG;QACtF,WAAW,IAAI,GAAG,CAAC,GAAG,aAAa,WAAW,EAAE;IACpD;IACA,IAAI;IACJ,IAAI,gBAAgB;QAChB,wCAA4C;YACxC,CAAC,GAAG,WAAW,SAAS,EAAE,oEAAoE,oEAAoE,4CAA4C;QAClN;QACA,OAAO,WAAW,GAAG,OAAO,OAAO,CAAC,YAAY,CAAC,OAAO;IAC5D,OAAO;QACH,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,KAAK;YAC3C,GAAG,SAAS;YACZ,GAAG,UAAU;YACb,UAAU;QACd;IACJ;IACA,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,kBAAkB,QAAQ,EAAE;QAClE,OAAO;QACP,UAAU;IACd;AACJ;AACA,MAAM,oBAAoB,WAAW,GAAG,CAAC,GAAG,OAAO,aAAa,EAAE,OAAO,gBAAgB;AACzF,MAAM,gBAAgB;IAClB,OAAO,CAAC,GAAG,OAAO,UAAU,EAAE;AAClC;AACA,SAAS,iCAAiC,YAAY;IAClD;;SASO;QACH,OAAO,iBAAiB,QAAQ,iBAAiB,SAAS,OAAO,aAAa,CAAC,GAAG,GAClF,kFAAkF;QAClF,OAAO,aAAa,CAAC,IAAI;IAC7B;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 8251, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['contexts'].HooksClientContext;\n\n//# sourceMappingURL=hooks-client-context.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,WAAW,CAAC,kBAAkB,EAEzF,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8256, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/readonly-url-search-params.js"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */ /** @internal */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ReadonlyURLSearchParams\", {\n    enumerable: true,\n    get: function() {\n        return ReadonlyURLSearchParams;\n    }\n});\nclass ReadonlyURLSearchParamsError extends Error {\n    constructor(){\n        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');\n    }\n}\nclass ReadonlyURLSearchParams extends URLSearchParams {\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=readonly-url-search-params.js.map"],"names":[],"mappings":"AAAA;;;;CAIC,GAAG,cAAc,GAClB,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,2BAA2B;IACtD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,qCAAqC;IACvC,aAAa;QACT,KAAK,CAAC;IACV;AACJ;AACA,MAAM,gCAAgC;IAClC,wKAAwK,GAAG,SAAS;QAChL,MAAM,IAAI;IACd;IACA,wKAAwK,GAAG,SAAS;QAChL,MAAM,IAAI;IACd;IACA,wKAAwK,GAAG,MAAM;QAC7K,MAAM,IAAI;IACd;IACA,wKAAwK,GAAG,OAAO;QAC9K,MAAM,IAAI;IACd;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,sDAAsD","ignoreList":[0]}},
    {"offset": {"line": 8299, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/server-inserted-html.js"],"sourcesContent":["\"use strict\";\nmodule.exports = require('../../module.compiled').vendored['contexts'].ServerInsertedHtml;\n\n//# sourceMappingURL=server-inserted-html.js.map"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,oJAAiC,QAAQ,CAAC,WAAW,CAAC,kBAAkB,EAEzF,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8304, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect-status-code.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"RedirectStatusCode\", {\n    enumerable: true,\n    get: function() {\n        return RedirectStatusCode;\n    }\n});\nvar RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {\n    RedirectStatusCode[RedirectStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\n    RedirectStatusCode[RedirectStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    RedirectStatusCode[RedirectStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    return RedirectStatusCode;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect-status-code.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,IAAI,qBAAqB,WAAW,GAAG,SAAS,kBAAkB;IAC9D,kBAAkB,CAAC,kBAAkB,CAAC,WAAW,GAAG,IAAI,GAAG;IAC3D,kBAAkB,CAAC,kBAAkB,CAAC,oBAAoB,GAAG,IAAI,GAAG;IACpE,kBAAkB,CAAC,kBAAkB,CAAC,oBAAoB,GAAG,IAAI,GAAG;IACpE,OAAO;AACX,EAAE,CAAC;AAEH,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8330, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    REDIRECT_ERROR_CODE: null,\n    RedirectType: null,\n    isRedirectError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    REDIRECT_ERROR_CODE: function() {\n        return REDIRECT_ERROR_CODE;\n    },\n    RedirectType: function() {\n        return RedirectType;\n    },\n    isRedirectError: function() {\n        return isRedirectError;\n    }\n});\nconst _redirectstatuscode = require(\"./redirect-status-code\");\nconst REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';\nvar RedirectType = /*#__PURE__*/ function(RedirectType) {\n    RedirectType[\"push\"] = \"push\";\n    RedirectType[\"replace\"] = \"replace\";\n    return RedirectType;\n}({});\nfunction isRedirectError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const digest = error.digest.split(';');\n    const [errorCode, type] = digest;\n    const destination = digest.slice(2, -2).join(';');\n    const status = digest.at(-2);\n    const statusCode = Number(status);\n    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,qBAAqB;IACrB,cAAc;IACd,iBAAiB;AACrB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,qBAAqB;QACjB,OAAO;IACX;IACA,cAAc;QACV,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,sBAAsB;AAC5B,IAAI,eAAe,WAAW,GAAG,SAAS,YAAY;IAClD,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,UAAU,GAAG;IAC1B,OAAO;AACX,EAAE,CAAC;AACH,SAAS,gBAAgB,KAAK;IAC1B,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,YAAY,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,UAAU;QACzG,OAAO;IACX;IACA,MAAM,SAAS,MAAM,MAAM,CAAC,KAAK,CAAC;IAClC,MAAM,CAAC,WAAW,KAAK,GAAG;IAC1B,MAAM,cAAc,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;IAC7C,MAAM,SAAS,OAAO,EAAE,CAAC,CAAC;IAC1B,MAAM,aAAa,OAAO;IAC1B,OAAO,cAAc,uBAAuB,CAAC,SAAS,aAAa,SAAS,MAAM,KAAK,OAAO,gBAAgB,YAAY,CAAC,MAAM,eAAe,cAAc,oBAAoB,kBAAkB;AACxM;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 8384, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getRedirectError: null,\n    getRedirectStatusCodeFromError: null,\n    getRedirectTypeFromError: null,\n    getURLFromRedirectError: null,\n    permanentRedirect: null,\n    redirect: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRedirectError: function() {\n        return getRedirectError;\n    },\n    getRedirectStatusCodeFromError: function() {\n        return getRedirectStatusCodeFromError;\n    },\n    getRedirectTypeFromError: function() {\n        return getRedirectTypeFromError;\n    },\n    getURLFromRedirectError: function() {\n        return getURLFromRedirectError;\n    },\n    permanentRedirect: function() {\n        return permanentRedirect;\n    },\n    redirect: function() {\n        return redirect;\n    }\n});\nconst _redirectstatuscode = require(\"./redirect-status-code\");\nconst _redirecterror = require(\"./redirect-error\");\nconst actionAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/action-async-storage.external').actionAsyncStorage : undefined;\nfunction getRedirectError(url, type, statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect) {\n    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = `${_redirecterror.REDIRECT_ERROR_CODE};${type};${url};${statusCode};`;\n    return error;\n}\nfunction redirect(/** The URL to redirect to */ url, type) {\n    type ??= actionAsyncStorage?.getStore()?.isAction ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;\n    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);\n}\nfunction permanentRedirect(/** The URL to redirect to */ url, type = _redirecterror.RedirectType.replace) {\n    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);\n}\nfunction getURLFromRedirectError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) return null;\n    // Slices off the beginning of the digest that contains the code and the\n    // separating ';'.\n    return error.digest.split(';').slice(2, -2).join(';');\n}\nfunction getRedirectTypeFromError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) {\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\n            value: \"E260\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return error.digest.split(';', 2)[1];\n}\nfunction getRedirectStatusCodeFromError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) {\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\n            value: \"E260\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return Number(error.digest.split(';').at(-2));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8477, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    HTTPAccessErrorStatus: null,\n    HTTP_ERROR_FALLBACK_ERROR_CODE: null,\n    getAccessFallbackErrorTypeByStatus: null,\n    getAccessFallbackHTTPStatus: null,\n    isHTTPAccessFallbackError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    HTTPAccessErrorStatus: function() {\n        return HTTPAccessErrorStatus;\n    },\n    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {\n        return HTTP_ERROR_FALLBACK_ERROR_CODE;\n    },\n    getAccessFallbackErrorTypeByStatus: function() {\n        return getAccessFallbackErrorTypeByStatus;\n    },\n    getAccessFallbackHTTPStatus: function() {\n        return getAccessFallbackHTTPStatus;\n    },\n    isHTTPAccessFallbackError: function() {\n        return isHTTPAccessFallbackError;\n    }\n});\nconst HTTPAccessErrorStatus = {\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    UNAUTHORIZED: 401\n};\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));\nconst HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';\nfunction isHTTPAccessFallbackError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const [prefix, httpStatus] = error.digest.split(';');\n    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));\n}\nfunction getAccessFallbackHTTPStatus(error) {\n    const httpStatus = error.digest.split(';')[1];\n    return Number(httpStatus);\n}\nfunction getAccessFallbackErrorTypeByStatus(status) {\n    switch(status){\n        case 401:\n            return 'unauthorized';\n        case 403:\n            return 'forbidden';\n        case 404:\n            return 'not-found';\n        default:\n            return;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=http-access-fallback.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,uBAAuB;IACvB,gCAAgC;IAChC,oCAAoC;IACpC,6BAA6B;IAC7B,2BAA2B;AAC/B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,uBAAuB;QACnB,OAAO;IACX;IACA,gCAAgC;QAC5B,OAAO;IACX;IACA,oCAAoC;QAChC,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,2BAA2B;QACvB,OAAO;IACX;AACJ;AACA,MAAM,wBAAwB;IAC1B,WAAW;IACX,WAAW;IACX,cAAc;AAClB;AACA,MAAM,gBAAgB,IAAI,IAAI,OAAO,MAAM,CAAC;AAC5C,MAAM,iCAAiC;AACvC,SAAS,0BAA0B,KAAK;IACpC,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,YAAY,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,UAAU;QACzG,OAAO;IACX;IACA,MAAM,CAAC,QAAQ,WAAW,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC;IAChD,OAAO,WAAW,kCAAkC,cAAc,GAAG,CAAC,OAAO;AACjF;AACA,SAAS,4BAA4B,KAAK;IACtC,MAAM,aAAa,MAAM,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAO,OAAO;AAClB;AACA,SAAS,mCAAmC,MAAM;IAC9C,OAAO;QACH,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI;IACR;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8551, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/not-found.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"notFound\", {\n    enumerable: true,\n    get: function() {\n        return notFound;\n    }\n});\nconst _httpaccessfallback = require(\"./http-access-fallback/http-access-fallback\");\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};404`;\nfunction notFound() {\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=not-found.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,YAAY;IACvC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN;;;;;;;;;;;;;CAaC,GAAG,MAAM,SAAS,GAAG,oBAAoB,8BAA8B,CAAC,IAAI,CAAC;AAC9E,SAAS;IACL,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,SAAS,qBAAqB;QACxE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,MAAM,GAAG;IACf,MAAM;AACV;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 8595, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/forbidden.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"forbidden\", {\n    enumerable: true,\n    get: function() {\n        return forbidden;\n    }\n});\nconst _httpaccessfallback = require(\"./http-access-fallback/http-access-fallback\");\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};403`;\nfunction forbidden() {\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n        throw Object.defineProperty(new Error(`\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E488\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=forbidden.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,aAAa;IACxC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAAG,MAAM,SAAS,GAAG,oBAAoB,8BAA8B,CAAC,IAAI,CAAC;AAC9E,SAAS;IACL,wCAAsD;QAClD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,+GAA+G,CAAC,GAAG,qBAAqB;YAC3K,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,SAAS,qBAAqB;QACxE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,MAAM,GAAG;IACf,MAAM;AACV;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 8645, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/navigation.react-server.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ReadonlyURLSearchParams: null,\n    RedirectType: null,\n    forbidden: null,\n    notFound: null,\n    permanentRedirect: null,\n    redirect: null,\n    unauthorized: null,\n    unstable_isUnrecognizedActionError: null,\n    unstable_rethrow: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyURLSearchParams: function() {\n        return _readonlyurlsearchparams.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _redirecterror.RedirectType;\n    },\n    forbidden: function() {\n        return _forbidden.forbidden;\n    },\n    notFound: function() {\n        return _notfound.notFound;\n    },\n    permanentRedirect: function() {\n        return _redirect.permanentRedirect;\n    },\n    redirect: function() {\n        return _redirect.redirect;\n    },\n    unauthorized: function() {\n        return _unauthorized.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _unstablerethrow.unstable_rethrow;\n    }\n});\nconst _readonlyurlsearchparams = require(\"./readonly-url-search-params\");\nconst _redirect = require(\"./redirect\");\nconst _redirecterror = require(\"./redirect-error\");\nconst _notfound = require(\"./not-found\");\nconst _forbidden = require(\"./forbidden\");\nconst _unauthorized = require(\"./unauthorized\");\nconst _unstablerethrow = require(\"./unstable-rethrow\");\nfunction unstable_isUnrecognizedActionError() {\n    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E776\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.react-server.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,yBAAyB;IACzB,cAAc;IACd,WAAW;IACX,UAAU;IACV,mBAAmB;IACnB,UAAU;IACV,cAAc;IACd,oCAAoC;IACpC,kBAAkB;AACtB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,yBAAyB;QACrB,OAAO,yBAAyB,uBAAuB;IAC3D;IACA,cAAc;QACV,OAAO,eAAe,YAAY;IACtC;IACA,WAAW;QACP,OAAO,WAAW,SAAS;IAC/B;IACA,UAAU;QACN,OAAO,UAAU,QAAQ;IAC7B;IACA,mBAAmB;QACf,OAAO,UAAU,iBAAiB;IACtC;IACA,UAAU;QACN,OAAO,UAAU,QAAQ;IAC7B;IACA,cAAc;QACV,OAAO,cAAc,YAAY;IACrC;IACA,oCAAoC;QAChC,OAAO;IACX;IACA,kBAAkB;QACd,OAAO,iBAAiB,gBAAgB;IAC5C;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;;;;;AACN,MAAM;;;;;AACN,SAAS;IACL,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,yEAAyE,qBAAqB;QAChI,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 8727, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/hooks-server-context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DynamicServerError: null,\n    isDynamicServerError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DynamicServerError: function() {\n        return DynamicServerError;\n    },\n    isDynamicServerError: function() {\n        return isDynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\nclass DynamicServerError extends Error {\n    constructor(description){\n        super(`Dynamic server usage: ${description}`), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nfunction isDynamicServerError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=hooks-server-context.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,sBAAsB;AAC1B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;AACJ;AACA,MAAM,qBAAqB;AAC3B,MAAM,2BAA2B;IAC7B,YAAY,WAAW,CAAC;QACpB,KAAK,CAAC,CAAC,sBAAsB,EAAE,aAAa,GAAG,IAAI,CAAC,WAAW,GAAG,aAAa,IAAI,CAAC,MAAM,GAAG;IACjG;AACJ;AACA,SAAS,qBAAqB,GAAG;IAC7B,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,KAAK,OAAO,IAAI,MAAM,KAAK,UAAU;QACjG,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8771, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/static-generation-bailout.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    StaticGenBailoutError: null,\n    isStaticGenBailoutError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=static-generation-bailout.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,uBAAuB;IACvB,yBAAyB;AAC7B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,uBAAuB;QACnB,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;AACJ;AACA,MAAM,0BAA0B;AAChC,MAAM,8BAA8B;IAChC,YAAY,GAAG,IAAI,CAAC;QAChB,KAAK,IAAI,OAAO,IAAI,CAAC,IAAI,GAAG;IAChC;AACJ;AACA,SAAS,wBAAwB,KAAK;IAClC,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,UAAU,KAAK,GAAG;QACnE,OAAO;IACX;IACA,OAAO,MAAM,IAAI,KAAK;AAC1B;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 8815, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/dynamic-rendering-utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    isHangingPromiseRejectionError: null,\n    makeDevtoolsIOAwarePromise: null,\n    makeHangingPromise: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isHangingPromiseRejectionError: function() {\n        return isHangingPromiseRejectionError;\n    },\n    makeDevtoolsIOAwarePromise: function() {\n        return makeDevtoolsIOAwarePromise;\n    },\n    makeHangingPromise: function() {\n        return makeHangingPromise;\n    }\n});\nfunction isHangingPromiseRejectionError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === HANGING_PROMISE_REJECTION;\n}\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\nclass HangingPromiseRejectionError extends Error {\n    constructor(route, expression){\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\n    }\n}\nconst abortListenersBySignal = new WeakMap();\nfunction makeHangingPromise(signal, route, expression) {\n    if (signal.aborted) {\n        return Promise.reject(new HangingPromiseRejectionError(route, expression));\n    } else {\n        const hangingPromise = new Promise((_, reject)=>{\n            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));\n            let currentListeners = abortListenersBySignal.get(signal);\n            if (currentListeners) {\n                currentListeners.push(boundRejection);\n            } else {\n                const listeners = [\n                    boundRejection\n                ];\n                abortListenersBySignal.set(signal, listeners);\n                signal.addEventListener('abort', ()=>{\n                    for(let i = 0; i < listeners.length; i++){\n                        listeners[i]();\n                    }\n                }, {\n                    once: true\n                });\n            }\n        });\n        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n        // your own promise out of it you'll need to ensure you handle the error when it rejects.\n        hangingPromise.catch(ignoreReject);\n        return hangingPromise;\n    }\n}\nfunction ignoreReject() {}\nfunction makeDevtoolsIOAwarePromise(underlying, requestStore, stage) {\n    if (requestStore.stagedRendering) {\n        // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n        return requestStore.stagedRendering.delayUntilStage(stage, undefined, underlying);\n    }\n    // in React DevTools if we resolve in a setTimeout we will observe\n    // the promise resolution as something that can suspend a boundary or root.\n    return new Promise((resolve)=>{\n        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n        setTimeout(()=>{\n            resolve(underlying);\n        }, 0);\n    });\n}\n\n//# sourceMappingURL=dynamic-rendering-utils.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,gCAAgC;IAChC,4BAA4B;IAC5B,oBAAoB;AACxB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,gCAAgC;QAC5B,OAAO;IACX;IACA,4BAA4B;QACxB,OAAO;IACX;IACA,oBAAoB;QAChB,OAAO;IACX;AACJ;AACA,SAAS,+BAA+B,GAAG;IACvC,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B;AACA,MAAM,4BAA4B;AAClC,MAAM,qCAAqC;IACvC,YAAY,KAAK,EAAE,UAAU,CAAC;QAC1B,KAAK,CAAC,CAAC,qBAAqB,EAAE,WAAW,qGAAqG,EAAE,WAAW,8KAA8K,EAAE,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,IAAI,CAAC,UAAU,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG;IAC3Z;AACJ;AACA,MAAM,yBAAyB,IAAI;AACnC,SAAS,mBAAmB,MAAM,EAAE,KAAK,EAAE,UAAU;IACjD,IAAI,OAAO,OAAO,EAAE;QAChB,OAAO,QAAQ,MAAM,CAAC,IAAI,6BAA6B,OAAO;IAClE,OAAO;QACH,MAAM,iBAAiB,IAAI,QAAQ,CAAC,GAAG;YACnC,MAAM,iBAAiB,OAAO,IAAI,CAAC,MAAM,IAAI,6BAA6B,OAAO;YACjF,IAAI,mBAAmB,uBAAuB,GAAG,CAAC;YAClD,IAAI,kBAAkB;gBAClB,iBAAiB,IAAI,CAAC;YAC1B,OAAO;gBACH,MAAM,YAAY;oBACd;iBACH;gBACD,uBAAuB,GAAG,CAAC,QAAQ;gBACnC,OAAO,gBAAgB,CAAC,SAAS;oBAC7B,IAAI,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAI;wBACrC,SAAS,CAAC,EAAE;oBAChB;gBACJ,GAAG;oBACC,MAAM;gBACV;YACJ;QACJ;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzF,eAAe,KAAK,CAAC;QACrB,OAAO;IACX;AACJ;AACA,SAAS,gBAAgB;AACzB,SAAS,2BAA2B,UAAU,EAAE,YAAY,EAAE,KAAK;IAC/D,IAAI,aAAa,eAAe,EAAE;QAC9B,iFAAiF;QACjF,OAAO,aAAa,eAAe,CAAC,eAAe,CAAC,OAAO,WAAW;IAC1E;IACA,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAI,QAAQ,CAAC;QAChB,sFAAsF;QACtF,WAAW;YACP,QAAQ;QACZ,GAAG;IACP;AACJ,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 8902, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/lib/framework/boundary-constants.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    METADATA_BOUNDARY_NAME: null,\n    OUTLET_BOUNDARY_NAME: null,\n    ROOT_LAYOUT_BOUNDARY_NAME: null,\n    VIEWPORT_BOUNDARY_NAME: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    METADATA_BOUNDARY_NAME: function() {\n        return METADATA_BOUNDARY_NAME;\n    },\n    OUTLET_BOUNDARY_NAME: function() {\n        return OUTLET_BOUNDARY_NAME;\n    },\n    ROOT_LAYOUT_BOUNDARY_NAME: function() {\n        return ROOT_LAYOUT_BOUNDARY_NAME;\n    },\n    VIEWPORT_BOUNDARY_NAME: function() {\n        return VIEWPORT_BOUNDARY_NAME;\n    }\n});\nconst METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';\nconst VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';\nconst OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';\nconst ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__';\n\n//# sourceMappingURL=boundary-constants.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,wBAAwB;IACxB,sBAAsB;IACtB,2BAA2B;IAC3B,wBAAwB;AAC5B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,wBAAwB;QACpB,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;IACA,2BAA2B;QACvB,OAAO;IACX;IACA,wBAAwB;QACpB,OAAO;IACX;AACJ;AACA,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,uBAAuB;AAC7B,MAAM,4BAA4B,iCAElC,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 8939, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/lib/scheduler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    atLeastOneTask: null,\n    scheduleImmediate: null,\n    scheduleOnNextTick: null,\n    waitAtLeastOneReactRenderTask: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    atLeastOneTask: function() {\n        return atLeastOneTask;\n    },\n    scheduleImmediate: function() {\n        return scheduleImmediate;\n    },\n    scheduleOnNextTick: function() {\n        return scheduleOnNextTick;\n    },\n    waitAtLeastOneReactRenderTask: function() {\n        return waitAtLeastOneReactRenderTask;\n    }\n});\nconst scheduleOnNextTick = (cb)=>{\n    // We use Promise.resolve().then() here so that the operation is scheduled at\n    // the end of the promise job queue, we then add it to the next process tick\n    // to ensure it's evaluated afterwards.\n    //\n    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n    //\n    Promise.resolve().then(()=>{\n        if (process.env.NEXT_RUNTIME === 'edge') {\n            setTimeout(cb, 0);\n        } else {\n            process.nextTick(cb);\n        }\n    });\n};\nconst scheduleImmediate = (cb)=>{\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        setTimeout(cb, 0);\n    } else {\n        setImmediate(cb);\n    }\n};\nfunction atLeastOneTask() {\n    return new Promise((resolve)=>scheduleImmediate(resolve));\n}\nfunction waitAtLeastOneReactRenderTask() {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        return new Promise((r)=>setTimeout(r, 0));\n    } else {\n        return new Promise((r)=>setImmediate(r));\n    }\n}\n\n//# sourceMappingURL=scheduler.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,gBAAgB;IAChB,mBAAmB;IACnB,oBAAoB;IACpB,+BAA+B;AACnC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,gBAAgB;QACZ,OAAO;IACX;IACA,mBAAmB;QACf,OAAO;IACX;IACA,oBAAoB;QAChB,OAAO;IACX;IACA,+BAA+B;QAC3B,OAAO;IACX;AACJ;AACA,MAAM,qBAAqB,CAAC;IACxB,6EAA6E;IAC7E,4EAA4E;IAC5E,uCAAuC;IACvC,EAAE;IACF,kLAAkL;IAClL,EAAE;IACF,QAAQ,OAAO,GAAG,IAAI,CAAC;QACnB;;aAEO;YACH,QAAQ,QAAQ,CAAC;QACrB;IACJ;AACJ;AACA,MAAM,oBAAoB,CAAC;IACvB;;SAEO;QACH,aAAa;IACjB;AACJ;AACA,SAAS;IACL,OAAO,IAAI,QAAQ,CAAC,UAAU,kBAAkB;AACpD;AACA,SAAS;IACL;;SAEO;QACH,OAAO,IAAI,QAAQ,CAAC,IAAI,aAAa;IACzC;AACJ,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 9004, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    BailoutToCSRError: null,\n    isBailoutToCSRError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    BailoutToCSRError: function() {\n        return BailoutToCSRError;\n    },\n    isBailoutToCSRError: function() {\n        return isBailoutToCSRError;\n    }\n});\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';\nclass BailoutToCSRError extends Error {\n    constructor(reason){\n        super(`Bail out to client-side rendering: ${reason}`), this.reason = reason, this.digest = BAILOUT_TO_CSR;\n    }\n}\nfunction isBailoutToCSRError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === BAILOUT_TO_CSR;\n}\n\n//# sourceMappingURL=bailout-to-csr.js.map"],"names":[],"mappings":"AAAA,+GAA+G;AAE/G,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,mBAAmB;IACnB,qBAAqB;AACzB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,mBAAmB;QACf,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;AACJ;AACA,MAAM,iBAAiB;AACvB,MAAM,0BAA0B;IAC5B,YAAY,MAAM,CAAC;QACf,KAAK,CAAC,CAAC,mCAAmC,EAAE,QAAQ,GAAG,IAAI,CAAC,MAAM,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG;IAC/F;AACJ;AACA,SAAS,oBAAoB,GAAG;IAC5B,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 9042, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/shared/lib/invariant-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"InvariantError\", {\n    enumerable: true,\n    get: function() {\n        return InvariantError;\n    }\n});\nclass InvariantError extends Error {\n    constructor(message, options){\n        super(`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`, options);\n        this.name = 'InvariantError';\n    }\n}\n\n//# sourceMappingURL=invariant-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,uBAAuB;IACzB,YAAY,OAAO,EAAE,OAAO,CAAC;QACzB,KAAK,CAAC,CAAC,WAAW,EAAE,QAAQ,QAAQ,CAAC,OAAO,UAAU,UAAU,IAAI,0BAA0B,CAAC,EAAE;QACjG,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 9061, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/app-render/staged-rendering.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    RenderStage: null,\n    StagedRenderingController: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    RenderStage: function() {\n        return RenderStage;\n    },\n    StagedRenderingController: function() {\n        return StagedRenderingController;\n    }\n});\nconst _invarianterror = require(\"../../shared/lib/invariant-error\");\nconst _promisewithresolvers = require(\"../../shared/lib/promise-with-resolvers\");\nvar RenderStage = /*#__PURE__*/ function(RenderStage) {\n    RenderStage[RenderStage[\"Static\"] = 1] = \"Static\";\n    RenderStage[RenderStage[\"Runtime\"] = 2] = \"Runtime\";\n    RenderStage[RenderStage[\"Dynamic\"] = 3] = \"Dynamic\";\n    return RenderStage;\n}({});\nclass StagedRenderingController {\n    constructor(abortSignal = null){\n        this.abortSignal = abortSignal;\n        this.currentStage = 1;\n        this.runtimeStagePromise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        this.dynamicStagePromise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        if (abortSignal) {\n            abortSignal.addEventListener('abort', ()=>{\n                const { reason } = abortSignal;\n                if (this.currentStage < 2) {\n                    this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n                    ;\n                    this.runtimeStagePromise.reject(reason);\n                }\n                if (this.currentStage < 3) {\n                    this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n                    ;\n                    this.dynamicStagePromise.reject(reason);\n                }\n            }, {\n                once: true\n            });\n        }\n    }\n    advanceStage(stage) {\n        // If we're already at the target stage or beyond, do nothing.\n        // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n        if (this.currentStage >= stage) {\n            return;\n        }\n        this.currentStage = stage;\n        // Note that we might be going directly from Static to Dynamic,\n        // so we need to resolve the runtime stage as well.\n        if (stage >= 2) {\n            this.runtimeStagePromise.resolve();\n        }\n        if (stage >= 3) {\n            this.dynamicStagePromise.resolve();\n        }\n    }\n    getStagePromise(stage) {\n        switch(stage){\n            case 2:\n                {\n                    return this.runtimeStagePromise.promise;\n                }\n            case 3:\n                {\n                    return this.dynamicStagePromise.promise;\n                }\n            default:\n                {\n                    stage;\n                    throw Object.defineProperty(new _invarianterror.InvariantError(`Invalid render stage: ${stage}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E881\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n        }\n    }\n    waitForStage(stage) {\n        return this.getStagePromise(stage);\n    }\n    delayUntilStage(stage, displayName, resolvedValue) {\n        const ioTriggerPromise = this.getStagePromise(stage);\n        const promise = makeDevtoolsIOPromiseFromIOTrigger(ioTriggerPromise, displayName, resolvedValue);\n        // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n        // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n        // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n        if (this.abortSignal) {\n            promise.catch(ignoreReject);\n        }\n        return promise;\n    }\n}\nfunction ignoreReject() {}\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger(ioTrigger, displayName, resolvedValue) {\n    // If we create a `new Promise` and give it a displayName\n    // (with no userspace code above us in the stack)\n    // React Devtools will use it as the IO cause when determining \"suspended by\".\n    // In particular, it should shadow any inner IO that resolved/rejected the promise\n    // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n    const promise = new Promise((resolve, reject)=>{\n        ioTrigger.then(resolve.bind(null, resolvedValue), reject);\n    });\n    if (displayName !== undefined) {\n        // @ts-expect-error\n        promise.displayName = displayName;\n    }\n    return promise;\n}\n\n//# sourceMappingURL=staged-rendering.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9189, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/server/app-render/dynamic-rendering.js"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    Postpone: null,\n    PreludeState: null,\n    abortAndThrowOnSynchronousRequestDataAccess: null,\n    abortOnSynchronousPlatformIOAccess: null,\n    accessedDynamicData: null,\n    annotateDynamicAccess: null,\n    consumeDynamicAccess: null,\n    createDynamicTrackingState: null,\n    createDynamicValidationState: null,\n    createHangingInputAbortSignal: null,\n    createRenderInBrowserAbortSignal: null,\n    delayUntilRuntimeStage: null,\n    formatDynamicAPIAccesses: null,\n    getFirstDynamicReason: null,\n    isDynamicPostpone: null,\n    isPrerenderInterruptedError: null,\n    logDisallowedDynamicError: null,\n    markCurrentScopeAsDynamic: null,\n    postponeWithTracking: null,\n    throwIfDisallowedDynamic: null,\n    throwToInterruptStaticGeneration: null,\n    trackAllowedDynamicAccess: null,\n    trackDynamicDataInDynamicRender: null,\n    trackSynchronousPlatformIOAccessInDev: null,\n    useDynamicRouteParams: null,\n    useDynamicSearchParams: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Postpone: function() {\n        return Postpone;\n    },\n    PreludeState: function() {\n        return PreludeState;\n    },\n    abortAndThrowOnSynchronousRequestDataAccess: function() {\n        return abortAndThrowOnSynchronousRequestDataAccess;\n    },\n    abortOnSynchronousPlatformIOAccess: function() {\n        return abortOnSynchronousPlatformIOAccess;\n    },\n    accessedDynamicData: function() {\n        return accessedDynamicData;\n    },\n    annotateDynamicAccess: function() {\n        return annotateDynamicAccess;\n    },\n    consumeDynamicAccess: function() {\n        return consumeDynamicAccess;\n    },\n    createDynamicTrackingState: function() {\n        return createDynamicTrackingState;\n    },\n    createDynamicValidationState: function() {\n        return createDynamicValidationState;\n    },\n    createHangingInputAbortSignal: function() {\n        return createHangingInputAbortSignal;\n    },\n    createRenderInBrowserAbortSignal: function() {\n        return createRenderInBrowserAbortSignal;\n    },\n    delayUntilRuntimeStage: function() {\n        return delayUntilRuntimeStage;\n    },\n    formatDynamicAPIAccesses: function() {\n        return formatDynamicAPIAccesses;\n    },\n    getFirstDynamicReason: function() {\n        return getFirstDynamicReason;\n    },\n    isDynamicPostpone: function() {\n        return isDynamicPostpone;\n    },\n    isPrerenderInterruptedError: function() {\n        return isPrerenderInterruptedError;\n    },\n    logDisallowedDynamicError: function() {\n        return logDisallowedDynamicError;\n    },\n    markCurrentScopeAsDynamic: function() {\n        return markCurrentScopeAsDynamic;\n    },\n    postponeWithTracking: function() {\n        return postponeWithTracking;\n    },\n    throwIfDisallowedDynamic: function() {\n        return throwIfDisallowedDynamic;\n    },\n    throwToInterruptStaticGeneration: function() {\n        return throwToInterruptStaticGeneration;\n    },\n    trackAllowedDynamicAccess: function() {\n        return trackAllowedDynamicAccess;\n    },\n    trackDynamicDataInDynamicRender: function() {\n        return trackDynamicDataInDynamicRender;\n    },\n    trackSynchronousPlatformIOAccessInDev: function() {\n        return trackSynchronousPlatformIOAccessInDev;\n    },\n    useDynamicRouteParams: function() {\n        return useDynamicRouteParams;\n    },\n    useDynamicSearchParams: function() {\n        return useDynamicSearchParams;\n    }\n});\nconst _react = /*#__PURE__*/ _interop_require_default(require(\"react\"));\nconst _hooksservercontext = require(\"../../client/components/hooks-server-context\");\nconst _staticgenerationbailout = require(\"../../client/components/static-generation-bailout\");\nconst _workunitasyncstorageexternal = require(\"./work-unit-async-storage.external\");\nconst _workasyncstorageexternal = require(\"../app-render/work-async-storage.external\");\nconst _dynamicrenderingutils = require(\"../dynamic-rendering-utils\");\nconst _boundaryconstants = require(\"../../lib/framework/boundary-constants\");\nconst _scheduler = require(\"../../lib/scheduler\");\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _invarianterror = require(\"../../shared/lib/invariant-error\");\nconst _stagedrendering = require(\"./staged-rendering\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst hasPostpone = typeof _react.default.unstable_postpone === 'function';\nfunction createDynamicTrackingState(isDebugDynamicAccesses) {\n    return {\n        isDebugDynamicAccesses,\n        dynamicAccesses: [],\n        syncDynamicErrorWithStack: null\n    };\n}\nfunction createDynamicValidationState() {\n    return {\n        hasSuspenseAboveBody: false,\n        hasDynamicMetadata: false,\n        hasDynamicViewport: false,\n        hasAllowedDynamic: false,\n        dynamicErrors: []\n    };\n}\nfunction getFirstDynamicReason(trackingState) {\n    var _trackingState_dynamicAccesses_;\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\n}\nfunction markCurrentScopeAsDynamic(store, workUnitStore, expression) {\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'cache':\n            case 'unstable-cache':\n                // Inside cache scopes, marking a scope as dynamic has no effect,\n                // because the outer cache scope creates a cache boundary. This is\n                // subtly different from reading a dynamic data source, which is\n                // forbidden inside a cache scope.\n                return;\n            case 'private-cache':\n                // A private cache scope is already dynamic by definition.\n                return;\n            case 'prerender-legacy':\n            case 'prerender-ppr':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\n    // don't need to do anything here because the entire page is already dynamic\n    // or it's static and it should not throw or postpone here.\n    if (store.forceDynamic || store.forceStatic) return;\n    if (store.dynamicShouldError) {\n        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n            value: \"E553\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-ppr':\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n            case 'prerender-legacy':\n                workUnitStore.revalidate = 0;\n                // We aren't prerendering, but we are generating a static page. We need\n                // to bail out of static generation.\n                const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E550\",\n                    enumerable: false,\n                    configurable: true\n                });\n                store.dynamicUsageDescription = expression;\n                store.dynamicUsageStack = err.stack;\n                throw err;\n            case 'request':\n                if (process.env.NODE_ENV !== 'production') {\n                    workUnitStore.usedDynamic = true;\n                }\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nfunction throwToInterruptStaticGeneration(expression, store, prerenderStore) {\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n        value: \"E558\",\n        enumerable: false,\n        configurable: true\n    });\n    prerenderStore.revalidate = 0;\n    store.dynamicUsageDescription = expression;\n    store.dynamicUsageStack = err.stack;\n    throw err;\n}\nfunction trackDynamicDataInDynamicRender(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'cache':\n        case 'unstable-cache':\n            // Inside cache scopes, marking a scope as dynamic has no effect,\n            // because the outer cache scope creates a cache boundary. This is\n            // subtly different from reading a dynamic data source, which is\n            // forbidden inside a cache scope.\n            return;\n        case 'private-cache':\n            // A private cache scope is already dynamic by definition.\n            return;\n        case 'prerender':\n        case 'prerender-runtime':\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n        case 'prerender-client':\n            break;\n        case 'request':\n            if (process.env.NODE_ENV !== 'production') {\n                workUnitStore.usedDynamic = true;\n            }\n            break;\n        default:\n            workUnitStore;\n    }\n}\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\n    const error = createPrerenderInterruptedError(reason);\n    prerenderStore.controller.abort(error);\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nfunction abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n        }\n    }\n}\nfunction trackSynchronousPlatformIOAccessInDev(requestStore) {\n    // We don't actually have a controller to abort but we do the semantic equivalent by\n    // advancing the request store out of the prerender stage\n    if (requestStore.stagedRendering) {\n        // TODO: error for sync IO in the runtime stage\n        // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n        requestStore.stagedRendering.advanceStage(_stagedrendering.RenderStage.Dynamic);\n    }\n}\nfunction abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\n    const prerenderSignal = prerenderStore.controller.signal;\n    if (prerenderSignal.aborted === false) {\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\n        // the error object when it isn't relevant to the aborting of the prerender however\n        // since we need the throw semantics regardless of whether we abort it is easier to land\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n        // to ideal implementation\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n        // It is important that we set this tracking value after aborting. Aborts are executed\n        // synchronously except for the case where you abort during render itself. By setting this\n        // value late we can use it to determine if any of the aborted tasks are the task that\n        // called the sync IO expression in the first place.\n        const dynamicTracking = prerenderStore.dynamicTracking;\n        if (dynamicTracking) {\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n            }\n        }\n    }\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\n}\nfunction Postpone({ reason, route }) {\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n}\nfunction postponeWithTracking(route, expression, dynamicTracking) {\n    assertPostpone();\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n    _react.default.unstable_postpone(createPostponeReason(route, expression));\n}\nfunction createPostponeReason(route, expression) {\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n}\nfunction isDynamicPostpone(err) {\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\n        return isDynamicPostponeReason(err.message);\n    }\n    return false;\n}\nfunction isDynamicPostponeReason(reason) {\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\n}\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n        value: \"E296\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\nfunction createPrerenderInterruptedError(message) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\n    return error;\n}\nfunction isPrerenderInterruptedError(error) {\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\n}\nfunction accessedDynamicData(dynamicAccesses) {\n    return dynamicAccesses.length > 0;\n}\nfunction consumeDynamicAccess(serverDynamic, clientDynamic) {\n    // We mutate because we only call this once we are no longer writing\n    // to the dynamicTrackingState and it's more efficient than creating a new\n    // array.\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\n    return serverDynamic.dynamicAccesses;\n}\nfunction formatDynamicAPIAccesses(dynamicAccesses) {\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4).filter((line)=>{\n            // Exclude Next.js internals from the stack trace.\n            if (line.includes('node_modules/next/')) {\n                return false;\n            }\n            // Exclude anonymous functions from the stack trace.\n            if (line.includes(' (<anonymous>)')) {\n                return false;\n            }\n            // Exclude Node.js internals from the stack trace.\n            if (line.includes(' (node:')) {\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n    });\n}\nfunction assertPostpone() {\n    if (!hasPostpone) {\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E224\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction createRenderInBrowserAbortSignal() {\n    const controller = new AbortController();\n    controller.abort(Object.defineProperty(new _bailouttocsr.BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\n        value: \"E721\",\n        enumerable: false,\n        configurable: true\n    }));\n    return controller.signal;\n}\nfunction createHangingInputAbortSignal(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'prerender':\n        case 'prerender-runtime':\n            const controller = new AbortController();\n            if (workUnitStore.cacheSignal) {\n                // If we have a cacheSignal it means we're in a prospective render. If\n                // the input we're waiting on is coming from another cache, we do want\n                // to wait for it so that we can resolve this cache entry too.\n                workUnitStore.cacheSignal.inputReady().then(()=>{\n                    controller.abort();\n                });\n            } else {\n                // Otherwise we're in the final render and we should already have all\n                // our caches filled.\n                // If the prerender uses stages, we have wait until the runtime stage,\n                // at which point all runtime inputs will be resolved.\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\n                //  even though they'd resolve in the next task.)\n                //\n                // We might still be waiting on some microtasks so we\n                // wait one tick before giving up. When we give up, we still want to\n                // render the content of this cache as deeply as we can so that we can\n                // suspend as deeply as possible in the tree or not at all if we don't\n                // end up waiting for the input.\n                const runtimeStagePromise = (0, _workunitasyncstorageexternal.getRuntimeStagePromise)(workUnitStore);\n                if (runtimeStagePromise) {\n                    runtimeStagePromise.then(()=>(0, _scheduler.scheduleOnNextTick)(()=>controller.abort()));\n                } else {\n                    (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());\n                }\n            }\n            return controller.signal;\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            return undefined;\n        default:\n            workUnitStore;\n    }\n}\nfunction annotateDynamicAccess(expression, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nfunction useDynamicRouteParams(expression) {\n    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workStore && workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-client':\n            case 'prerender':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        // We are in a prerender with cacheComponents semantics. We are going to\n                        // hang here and never resolve. This will cause the currently\n                        // rendering component to effectively be a dynamic hole.\n                        _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression));\n                    }\n                    break;\n                }\n            case 'prerender-ppr':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n                    }\n                    break;\n                }\n            case 'prerender-runtime':\n                throw Object.defineProperty(new _invarianterror.InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E771\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n                throw Object.defineProperty(new _invarianterror.InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E745\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-legacy':\n            case 'request':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nfunction useDynamicSearchParams(expression) {\n    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (!workStore) {\n        // We assume pages router context and just return\n        return;\n    }\n    if (!workUnitStore) {\n        (0, _workunitasyncstorageexternal.throwForMissingRequestStore)(expression);\n    }\n    switch(workUnitStore.type){\n        case 'prerender-client':\n            {\n                _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression));\n                break;\n            }\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n            {\n                if (workStore.forceStatic) {\n                    return;\n                }\n                throw Object.defineProperty(new _bailouttocsr.BailoutToCSRError(expression), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        case 'prerender':\n        case 'prerender-runtime':\n            throw Object.defineProperty(new _invarianterror.InvariantError(`\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E795\",\n                enumerable: false,\n                configurable: true\n            });\n        case 'cache':\n        case 'unstable-cache':\n        case 'private-cache':\n            throw Object.defineProperty(new _invarianterror.InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E745\",\n                enumerable: false,\n                configurable: true\n            });\n        case 'request':\n            return;\n        default:\n            workUnitStore;\n    }\n}\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${_boundaryconstants.ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${_boundaryconstants.METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${_boundaryconstants.VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${_boundaryconstants.OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\nfunction trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\n    if (hasOutletRegex.test(componentStack)) {\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n        return;\n    } else if (hasMetadataRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicMetadata = true;\n        return;\n    } else if (hasViewportRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicViewport = true;\n        return;\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n        dynamicValidation.hasAllowedDynamic = true;\n        dynamicValidation.hasSuspenseAboveBody = true;\n        return;\n    } else if (hasSuspenseRegex.test(componentStack)) {\n        // this error had a Suspense boundary above it so we don't need to report it as a source\n        // of disallowed\n        dynamicValidation.hasAllowedDynamic = true;\n        return;\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\n        // This task was the task that called the sync error.\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\n        return;\n    } else {\n        const message = `Route \"${workStore.route}\": Uncached data was accessed outside of ` + '<Suspense>. This delays the entire page from rendering, resulting in a ' + 'slow user experience. Learn more: ' + 'https://nextjs.org/docs/messages/blocking-route';\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\n        dynamicValidation.dynamicErrors.push(error);\n        return;\n    }\n}\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\n    const ownerStack = process.env.NODE_ENV !== 'production' && _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : null;\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\n    return error;\n}\nvar PreludeState = /*#__PURE__*/ function(PreludeState) {\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\n    return PreludeState;\n}({});\nfunction logDisallowedDynamicError(workStore, error) {\n    console.error(error);\n    if (!workStore.dev) {\n        if (workStore.hasReadableErrorStacks) {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\n        } else {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\n        }\n    }\n}\nfunction throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\n    if (serverDynamic.syncDynamicErrorWithStack) {\n        logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\n        throw new _staticgenerationbailout.StaticGenBailoutError();\n    }\n    if (prelude !== 0) {\n        if (dynamicValidation.hasSuspenseAboveBody) {\n            // This route has opted into allowing fully dynamic rendering\n            // by including a Suspense boundary above the body. In this case\n            // a lack of a shell is not considered disallowed so we simply return\n            return;\n        }\n        // We didn't have any sync bailouts but there may be user code which\n        // blocked the root. We would have captured these during the prerender\n        // and can log them here and then terminate the build/validating render\n        const dynamicErrors = dynamicValidation.dynamicErrors;\n        if (dynamicErrors.length > 0) {\n            for(let i = 0; i < dynamicErrors.length; i++){\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\n            }\n            throw new _staticgenerationbailout.StaticGenBailoutError();\n        }\n        // If we got this far then the only other thing that could be blocking\n        // the root is dynamic Viewport. If this is dynamic then\n        // you need to opt into that by adding a Suspense boundary above the body\n        // to indicate your are ok with fully dynamic rendering.\n        if (dynamicValidation.hasDynamicViewport) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\n            throw new _staticgenerationbailout.StaticGenBailoutError();\n        }\n        if (prelude === 1) {\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\n            // We still adhere to the constraint that you must produce a shell but invite the\n            // user to report this as a bug in Next.js.\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\n            throw new _staticgenerationbailout.StaticGenBailoutError();\n        }\n    } else {\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\n            throw new _staticgenerationbailout.StaticGenBailoutError();\n        }\n    }\n}\nfunction delayUntilRuntimeStage(prerenderStore, result) {\n    if (prerenderStore.runtimeStagePromise) {\n        return prerenderStore.runtimeStagePromise.then(()=>result);\n    }\n    return result;\n}\n\n//# sourceMappingURL=dynamic-rendering.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9913, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/navigation.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ReadonlyURLSearchParams: null,\n    RedirectType: null,\n    ServerInsertedHTMLContext: null,\n    forbidden: null,\n    notFound: null,\n    permanentRedirect: null,\n    redirect: null,\n    unauthorized: null,\n    unstable_isUnrecognizedActionError: null,\n    unstable_rethrow: null,\n    useParams: null,\n    usePathname: null,\n    useRouter: null,\n    useSearchParams: null,\n    useSelectedLayoutSegment: null,\n    useSelectedLayoutSegments: null,\n    useServerInsertedHTML: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyURLSearchParams: function() {\n        return _navigationreactserver.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _navigationreactserver.RedirectType;\n    },\n    ServerInsertedHTMLContext: function() {\n        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;\n    },\n    forbidden: function() {\n        return _navigationreactserver.forbidden;\n    },\n    notFound: function() {\n        return _navigationreactserver.notFound;\n    },\n    permanentRedirect: function() {\n        return _navigationreactserver.permanentRedirect;\n    },\n    redirect: function() {\n        return _navigationreactserver.redirect;\n    },\n    unauthorized: function() {\n        return _navigationreactserver.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return _unrecognizedactionerror.unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _navigationreactserver.unstable_rethrow;\n    },\n    useParams: function() {\n        return useParams;\n    },\n    usePathname: function() {\n        return usePathname;\n    },\n    useRouter: function() {\n        return useRouter;\n    },\n    useSearchParams: function() {\n        return useSearchParams;\n    },\n    useSelectedLayoutSegment: function() {\n        return useSelectedLayoutSegment;\n    },\n    useSelectedLayoutSegments: function() {\n        return useSelectedLayoutSegments;\n    },\n    useServerInsertedHTML: function() {\n        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _approutercontextsharedruntime = require(\"../../shared/lib/app-router-context.shared-runtime\");\nconst _hooksclientcontextsharedruntime = require(\"../../shared/lib/hooks-client-context.shared-runtime\");\nconst _segment = require(\"../../shared/lib/segment\");\nconst _readonlyurlsearchparams = require(\"./readonly-url-search-params\");\nconst _serverinsertedhtmlsharedruntime = require(\"../../shared/lib/server-inserted-html.shared-runtime\");\nconst _unrecognizedactionerror = require(\"./unrecognized-action-error\");\nconst _navigationreactserver = require(\"./navigation.react-server\");\nconst useDynamicRouteParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicRouteParams : undefined;\nconst useDynamicSearchParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicSearchParams : undefined;\nfunction useSearchParams() {\n    useDynamicSearchParams?.('useSearchParams()');\n    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);\n    // In the case where this is `null`, the compat types added in\n    // `next-env.d.ts` will add a new overload that changes the return type to\n    // include `null`.\n    const readonlySearchParams = (0, _react.useMemo)(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new _readonlyurlsearchparams.ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.searchParams);\n        }\n    }\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    useDynamicRouteParams?.('usePathname()');\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\n    // will add a new overload that changes the return type to include `null`.\n    const pathname = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.pathname);\n        }\n    }\n    return pathname;\n}\nfunction useRouter() {\n    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);\n    if (router === null) {\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E238\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return router;\n}\nfunction useParams() {\n    useDynamicRouteParams?.('useParams()');\n    const params = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.params);\n        }\n    }\n    return params;\n}\nfunction useSelectedLayoutSegments(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegments()');\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n    if (!context) return null;\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            const promise = navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey);\n            if (promise) {\n                // We should always have a promise here, but if we don't, it's not worth erroring over.\n                // We just won't be able to instrument it, but can still provide the value.\n                return (0, _react.use)(promise);\n            }\n        }\n    }\n    return (0, _segment.getSelectedLayoutSegmentPath)(context.parentTree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegment()');\n    const navigationPromises = (0, _react.useContext)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && navigationPromises && 'use' in _react.default) {\n        const promise = navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey);\n        if (promise) {\n            // We should always have a promise here, but if we don't, it's not worth erroring over.\n            // We just won't be able to instrument it, but can still provide the value.\n            return (0, _react.use)(promise);\n        }\n    }\n    return (0, _segment.computeSelectedLayoutSegment)(selectedLayoutSegments, parallelRouteKey);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/navigation.js"],"sourcesContent":["module.exports = require('./dist/client/components/navigation')\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 10120, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/medical/node_modules/lucide-react/dist/esm/icons/chevron-up.js","sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/lucide-react/src/icons/chevron-up.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ChevronUp\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTggMTUtNi02LTYgNiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/chevron-up\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronUp = createLucideIcon('ChevronUp', [['path', { d: 'm18 15-6-6-6 6', key: '153udz' }]]);\n\nexport default ChevronUp;\n"],"names":[],"mappings":";;;;;;;;;;;AAaA,CAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAY,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,oLAAA,EAAiB,WAAa,CAAA,CAAA;IAAC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ;YAAE,CAAA,CAAA,CAAG,gBAAkB,CAAA;YAAA,CAAA,CAAA,CAAA,EAAK,CAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAC;KAAC;CAAC,CAAA,CAAA"}}]
}