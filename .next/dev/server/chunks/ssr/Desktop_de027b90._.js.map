{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;;AAAO,IAAWA,YAAAA,WAAAA,GAAAA,SAAAA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;WAtBeA;MAwBjB","ignoreList":[0]}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0]}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServer"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,oIACRC,QAAQ,CAAC,YAAY,CAAEC,6BAA6B","ignoreList":[0]}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackStatic\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackStatic"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,oIACRC,QAAQ,CAAC,YAAY,CAAEC,6BAA6B","ignoreList":[0]}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.React\n"],"names":["module","exports","require","vendored","React"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,oIACRC,QAAQ,CAAC,YAAY,CAAEC,KAAK","ignoreList":[0]}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/layout-router.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/layout-router.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/layout-router.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/layout-router.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/client-page.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/client-page.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/client-page.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/client-page.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/client-segment.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/client-segment.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/client-segment.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/client-segment.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/hooks-server-context.js"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\nexport class DynamicServerError extends Error {\n    constructor(description){\n        super(`Dynamic server usage: ${description}`), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nexport function isDynamicServerError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\n\n//# sourceMappingURL=hooks-server-context.js.map"],"names":[],"mappings":";;;;;;AAAA,MAAM,qBAAqB;AACpB,MAAM,2BAA2B;IACpC,YAAY,WAAW,CAAC;QACpB,KAAK,CAAC,CAAC,sBAAsB,EAAE,aAAa,GAAG,IAAI,CAAC,WAAW,GAAG,aAAa,IAAI,CAAC,MAAM,GAAG;IACjG;AACJ;AACO,SAAS,qBAAqB,GAAG;IACpC,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,KAAK,OAAO,IAAI,MAAM,KAAK,UAAU;QACjG,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/dynamic-rendering-utils.js"],"sourcesContent":["export function isHangingPromiseRejectionError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === HANGING_PROMISE_REJECTION;\n}\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\nclass HangingPromiseRejectionError extends Error {\n    constructor(route, expression){\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\n    }\n}\nconst abortListenersBySignal = new WeakMap();\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */ export function makeHangingPromise(signal, route, expression) {\n    if (signal.aborted) {\n        return Promise.reject(new HangingPromiseRejectionError(route, expression));\n    } else {\n        const hangingPromise = new Promise((_, reject)=>{\n            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));\n            let currentListeners = abortListenersBySignal.get(signal);\n            if (currentListeners) {\n                currentListeners.push(boundRejection);\n            } else {\n                const listeners = [\n                    boundRejection\n                ];\n                abortListenersBySignal.set(signal, listeners);\n                signal.addEventListener('abort', ()=>{\n                    for(let i = 0; i < listeners.length; i++){\n                        listeners[i]();\n                    }\n                }, {\n                    once: true\n                });\n            }\n        });\n        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n        // your own promise out of it you'll need to ensure you handle the error when it rejects.\n        hangingPromise.catch(ignoreReject);\n        return hangingPromise;\n    }\n}\nfunction ignoreReject() {}\nexport function makeDevtoolsIOAwarePromise(underlying, requestStore, stage) {\n    if (requestStore.stagedRendering) {\n        // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n        return requestStore.stagedRendering.delayUntilStage(stage, undefined, underlying);\n    }\n    // in React DevTools if we resolve in a setTimeout we will observe\n    // the promise resolution as something that can suspend a boundary or root.\n    return new Promise((resolve)=>{\n        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n        setTimeout(()=>{\n            resolve(underlying);\n        }, 0);\n    });\n}\n\n//# sourceMappingURL=dynamic-rendering-utils.js.map"],"names":[],"mappings":";;;;;;;;AAAO,SAAS,+BAA+B,GAAG;IAC9C,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B;AACA,MAAM,4BAA4B;AAClC,MAAM,qCAAqC;IACvC,YAAY,KAAK,EAAE,UAAU,CAAC;QAC1B,KAAK,CAAC,CAAC,qBAAqB,EAAE,WAAW,qGAAqG,EAAE,WAAW,8KAA8K,EAAE,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,IAAI,CAAC,UAAU,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG;IAC3Z;AACJ;AACA,MAAM,yBAAyB,IAAI;AAOxB,SAAS,mBAAmB,MAAM,EAAE,KAAK,EAAE,UAAU;IAC5D,IAAI,OAAO,OAAO,EAAE;QAChB,OAAO,QAAQ,MAAM,CAAC,IAAI,6BAA6B,OAAO;IAClE,OAAO;QACH,MAAM,iBAAiB,IAAI,QAAQ,CAAC,GAAG;YACnC,MAAM,iBAAiB,OAAO,IAAI,CAAC,MAAM,IAAI,6BAA6B,OAAO;YACjF,IAAI,mBAAmB,uBAAuB,GAAG,CAAC;YAClD,IAAI,kBAAkB;gBAClB,iBAAiB,IAAI,CAAC;YAC1B,OAAO;gBACH,MAAM,YAAY;oBACd;iBACH;gBACD,uBAAuB,GAAG,CAAC,QAAQ;gBACnC,OAAO,gBAAgB,CAAC,SAAS;oBAC7B,IAAI,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAI;wBACrC,SAAS,CAAC,EAAE;oBAChB;gBACJ,GAAG;oBACC,MAAM;gBACV;YACJ;QACJ;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzF,eAAe,KAAK,CAAC;QACrB,OAAO;IACX;AACJ;AACA,SAAS,gBAAgB;AAClB,SAAS,2BAA2B,UAAU,EAAE,YAAY,EAAE,KAAK;IACtE,IAAI,aAAa,eAAe,EAAE;QAC9B,iFAAiF;QACjF,OAAO,aAAa,eAAe,CAAC,eAAe,CAAC,OAAO,WAAW;IAC1E;IACA,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAI,QAAQ,CAAC;QAChB,sFAAsF;QACtF,WAAW;YACP,QAAQ;QACZ,GAAG;IACP;AACJ,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/framework/boundary-constants.js"],"sourcesContent":["export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__';\n\n//# sourceMappingURL=boundary-constants.js.map"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,uBAAuB;AAC7B,MAAM,4BAA4B,iCAEzC,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';\n/** An error that should be thrown when we want to bail out to client-side rendering. */ export class BailoutToCSRError extends Error {\n    constructor(reason){\n        super(`Bail out to client-side rendering: ${reason}`), this.reason = reason, this.digest = BAILOUT_TO_CSR;\n    }\n}\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */ export function isBailoutToCSRError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === BAILOUT_TO_CSR;\n}\n\n//# sourceMappingURL=bailout-to-csr.js.map"],"names":[],"mappings":"AAAA,+GAA+G;;;;;;;AAC/G,MAAM,iBAAiB;AACyE,MAAM,0BAA0B;IAC5H,YAAY,MAAM,CAAC;QACf,KAAK,CAAC,CAAC,mCAAmC,EAAE,QAAQ,GAAG,IAAI,CAAC,MAAM,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG;IAC/F;AACJ;AACsH,SAAS,oBAAoB,GAAG;IAClJ,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/invariant-error.js"],"sourcesContent":["export class InvariantError extends Error {\n    constructor(message, options){\n        super(`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`, options);\n        this.name = 'InvariantError';\n    }\n}\n\n//# sourceMappingURL=invariant-error.js.map"],"names":[],"mappings":";;;;AAAO,MAAM,uBAAuB;IAChC,YAAY,OAAO,EAAE,OAAO,CAAC;QACzB,KAAK,CAAC,CAAC,WAAW,EAAE,QAAQ,QAAQ,CAAC,OAAO,UAAU,UAAU,IAAI,0BAA0B,CAAC,EAAE;QACjG,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ // Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react';\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { getRuntimeStagePromise, throwForMissingRequestStore, workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { METADATA_BOUNDARY_NAME, VIEWPORT_BOUNDARY_NAME, OUTLET_BOUNDARY_NAME, ROOT_LAYOUT_BOUNDARY_NAME } from '../../lib/framework/boundary-constants';\nimport { scheduleOnNextTick } from '../../lib/scheduler';\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { RenderStage } from './staged-rendering';\nconst hasPostpone = typeof React.unstable_postpone === 'function';\nexport function createDynamicTrackingState(isDebugDynamicAccesses) {\n    return {\n        isDebugDynamicAccesses,\n        dynamicAccesses: [],\n        syncDynamicErrorWithStack: null\n    };\n}\nexport function createDynamicValidationState() {\n    return {\n        hasSuspenseAboveBody: false,\n        hasDynamicMetadata: false,\n        hasDynamicViewport: false,\n        hasAllowedDynamic: false,\n        dynamicErrors: []\n    };\n}\nexport function getFirstDynamicReason(trackingState) {\n    var _trackingState_dynamicAccesses_;\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\n}\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */ export function markCurrentScopeAsDynamic(store, workUnitStore, expression) {\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'cache':\n            case 'unstable-cache':\n                // Inside cache scopes, marking a scope as dynamic has no effect,\n                // because the outer cache scope creates a cache boundary. This is\n                // subtly different from reading a dynamic data source, which is\n                // forbidden inside a cache scope.\n                return;\n            case 'private-cache':\n                // A private cache scope is already dynamic by definition.\n                return;\n            case 'prerender-legacy':\n            case 'prerender-ppr':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\n    // don't need to do anything here because the entire page is already dynamic\n    // or it's static and it should not throw or postpone here.\n    if (store.forceDynamic || store.forceStatic) return;\n    if (store.dynamicShouldError) {\n        throw Object.defineProperty(new StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n            value: \"E553\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-ppr':\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n            case 'prerender-legacy':\n                workUnitStore.revalidate = 0;\n                // We aren't prerendering, but we are generating a static page. We need\n                // to bail out of static generation.\n                const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E550\",\n                    enumerable: false,\n                    configurable: true\n                });\n                store.dynamicUsageDescription = expression;\n                store.dynamicUsageStack = err.stack;\n                throw err;\n            case 'request':\n                if (process.env.NODE_ENV !== 'production') {\n                    workUnitStore.usedDynamic = true;\n                }\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */ export function throwToInterruptStaticGeneration(expression, store, prerenderStore) {\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n    const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n        value: \"E558\",\n        enumerable: false,\n        configurable: true\n    });\n    prerenderStore.revalidate = 0;\n    store.dynamicUsageDescription = expression;\n    store.dynamicUsageStack = err.stack;\n    throw err;\n}\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */ export function trackDynamicDataInDynamicRender(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'cache':\n        case 'unstable-cache':\n            // Inside cache scopes, marking a scope as dynamic has no effect,\n            // because the outer cache scope creates a cache boundary. This is\n            // subtly different from reading a dynamic data source, which is\n            // forbidden inside a cache scope.\n            return;\n        case 'private-cache':\n            // A private cache scope is already dynamic by definition.\n            return;\n        case 'prerender':\n        case 'prerender-runtime':\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n        case 'prerender-client':\n            break;\n        case 'request':\n            if (process.env.NODE_ENV !== 'production') {\n                workUnitStore.usedDynamic = true;\n            }\n            break;\n        default:\n            workUnitStore;\n    }\n}\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\n    const error = createPrerenderInterruptedError(reason);\n    prerenderStore.controller.abort(error);\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nexport function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n        }\n    }\n}\nexport function trackSynchronousPlatformIOAccessInDev(requestStore) {\n    // We don't actually have a controller to abort but we do the semantic equivalent by\n    // advancing the request store out of the prerender stage\n    if (requestStore.stagedRendering) {\n        // TODO: error for sync IO in the runtime stage\n        // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n        requestStore.stagedRendering.advanceStage(RenderStage.Dynamic);\n    }\n}\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */ export function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\n    const prerenderSignal = prerenderStore.controller.signal;\n    if (prerenderSignal.aborted === false) {\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\n        // the error object when it isn't relevant to the aborting of the prerender however\n        // since we need the throw semantics regardless of whether we abort it is easier to land\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n        // to ideal implementation\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n        // It is important that we set this tracking value after aborting. Aborts are executed\n        // synchronously except for the case where you abort during render itself. By setting this\n        // value late we can use it to determine if any of the aborted tasks are the task that\n        // called the sync IO expression in the first place.\n        const dynamicTracking = prerenderStore.dynamicTracking;\n        if (dynamicTracking) {\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n            }\n        }\n    }\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\n}\nexport function Postpone({ reason, route }) {\n    const prerenderStore = workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n}\nexport function postponeWithTracking(route, expression, dynamicTracking) {\n    assertPostpone();\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n    React.unstable_postpone(createPostponeReason(route, expression));\n}\nfunction createPostponeReason(route, expression) {\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n}\nexport function isDynamicPostpone(err) {\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\n        return isDynamicPostponeReason(err.message);\n    }\n    return false;\n}\nfunction isDynamicPostponeReason(reason) {\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\n}\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n        value: \"E296\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\nfunction createPrerenderInterruptedError(message) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\n    return error;\n}\nexport function isPrerenderInterruptedError(error) {\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\n}\nexport function accessedDynamicData(dynamicAccesses) {\n    return dynamicAccesses.length > 0;\n}\nexport function consumeDynamicAccess(serverDynamic, clientDynamic) {\n    // We mutate because we only call this once we are no longer writing\n    // to the dynamicTrackingState and it's more efficient than creating a new\n    // array.\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\n    return serverDynamic.dynamicAccesses;\n}\nexport function formatDynamicAPIAccesses(dynamicAccesses) {\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4).filter((line)=>{\n            // Exclude Next.js internals from the stack trace.\n            if (line.includes('node_modules/next/')) {\n                return false;\n            }\n            // Exclude anonymous functions from the stack trace.\n            if (line.includes(' (<anonymous>)')) {\n                return false;\n            }\n            // Exclude Node.js internals from the stack trace.\n            if (line.includes(' (node:')) {\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n    });\n}\nfunction assertPostpone() {\n    if (!hasPostpone) {\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E224\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */ export function createRenderInBrowserAbortSignal() {\n    const controller = new AbortController();\n    controller.abort(Object.defineProperty(new BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\n        value: \"E721\",\n        enumerable: false,\n        configurable: true\n    }));\n    return controller.signal;\n}\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */ export function createHangingInputAbortSignal(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'prerender':\n        case 'prerender-runtime':\n            const controller = new AbortController();\n            if (workUnitStore.cacheSignal) {\n                // If we have a cacheSignal it means we're in a prospective render. If\n                // the input we're waiting on is coming from another cache, we do want\n                // to wait for it so that we can resolve this cache entry too.\n                workUnitStore.cacheSignal.inputReady().then(()=>{\n                    controller.abort();\n                });\n            } else {\n                // Otherwise we're in the final render and we should already have all\n                // our caches filled.\n                // If the prerender uses stages, we have wait until the runtime stage,\n                // at which point all runtime inputs will be resolved.\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\n                //  even though they'd resolve in the next task.)\n                //\n                // We might still be waiting on some microtasks so we\n                // wait one tick before giving up. When we give up, we still want to\n                // render the content of this cache as deeply as we can so that we can\n                // suspend as deeply as possible in the tree or not at all if we don't\n                // end up waiting for the input.\n                const runtimeStagePromise = getRuntimeStagePromise(workUnitStore);\n                if (runtimeStagePromise) {\n                    runtimeStagePromise.then(()=>scheduleOnNextTick(()=>controller.abort()));\n                } else {\n                    scheduleOnNextTick(()=>controller.abort());\n                }\n            }\n            return controller.signal;\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            return undefined;\n        default:\n            workUnitStore;\n    }\n}\nexport function annotateDynamicAccess(expression, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nexport function useDynamicRouteParams(expression) {\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore && workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-client':\n            case 'prerender':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        // We are in a prerender with cacheComponents semantics. We are going to\n                        // hang here and never resolve. This will cause the currently\n                        // rendering component to effectively be a dynamic hole.\n                        React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\n                    }\n                    break;\n                }\n            case 'prerender-ppr':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n                    }\n                    break;\n                }\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E771\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E745\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-legacy':\n            case 'request':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nexport function useDynamicSearchParams(expression) {\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (!workStore) {\n        // We assume pages router context and just return\n        return;\n    }\n    if (!workUnitStore) {\n        throwForMissingRequestStore(expression);\n    }\n    switch(workUnitStore.type){\n        case 'prerender-client':\n            {\n                React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\n                break;\n            }\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n            {\n                if (workStore.forceStatic) {\n                    return;\n                }\n                throw Object.defineProperty(new BailoutToCSRError(expression), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        case 'prerender':\n        case 'prerender-runtime':\n            throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E795\",\n                enumerable: false,\n                configurable: true\n            });\n        case 'cache':\n        case 'unstable-cache':\n        case 'private-cache':\n            throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E745\",\n                enumerable: false,\n                configurable: true\n            });\n        case 'request':\n            return;\n        default:\n            workUnitStore;\n    }\n}\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\nexport function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\n    if (hasOutletRegex.test(componentStack)) {\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n        return;\n    } else if (hasMetadataRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicMetadata = true;\n        return;\n    } else if (hasViewportRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicViewport = true;\n        return;\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n        dynamicValidation.hasAllowedDynamic = true;\n        dynamicValidation.hasSuspenseAboveBody = true;\n        return;\n    } else if (hasSuspenseRegex.test(componentStack)) {\n        // this error had a Suspense boundary above it so we don't need to report it as a source\n        // of disallowed\n        dynamicValidation.hasAllowedDynamic = true;\n        return;\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\n        // This task was the task that called the sync error.\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\n        return;\n    } else {\n        const message = `Route \"${workStore.route}\": Uncached data was accessed outside of ` + '<Suspense>. This delays the entire page from rendering, resulting in a ' + 'slow user experience. Learn more: ' + 'https://nextjs.org/docs/messages/blocking-route';\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\n        dynamicValidation.dynamicErrors.push(error);\n        return;\n    }\n}\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\n    const ownerStack = process.env.NODE_ENV !== 'production' && React.captureOwnerStack ? React.captureOwnerStack() : null;\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\n    return error;\n}\nexport var PreludeState = /*#__PURE__*/ function(PreludeState) {\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\n    return PreludeState;\n}({});\nexport function logDisallowedDynamicError(workStore, error) {\n    console.error(error);\n    if (!workStore.dev) {\n        if (workStore.hasReadableErrorStacks) {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\n        } else {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\n        }\n    }\n}\nexport function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\n    if (serverDynamic.syncDynamicErrorWithStack) {\n        logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\n        throw new StaticGenBailoutError();\n    }\n    if (prelude !== 0) {\n        if (dynamicValidation.hasSuspenseAboveBody) {\n            // This route has opted into allowing fully dynamic rendering\n            // by including a Suspense boundary above the body. In this case\n            // a lack of a shell is not considered disallowed so we simply return\n            return;\n        }\n        // We didn't have any sync bailouts but there may be user code which\n        // blocked the root. We would have captured these during the prerender\n        // and can log them here and then terminate the build/validating render\n        const dynamicErrors = dynamicValidation.dynamicErrors;\n        if (dynamicErrors.length > 0) {\n            for(let i = 0; i < dynamicErrors.length; i++){\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\n            }\n            throw new StaticGenBailoutError();\n        }\n        // If we got this far then the only other thing that could be blocking\n        // the root is dynamic Viewport. If this is dynamic then\n        // you need to opt into that by adding a Suspense boundary above the body\n        // to indicate your are ok with fully dynamic rendering.\n        if (dynamicValidation.hasDynamicViewport) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\n            throw new StaticGenBailoutError();\n        }\n        if (prelude === 1) {\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\n            // We still adhere to the constraint that you must produce a shell but invite the\n            // user to report this as a bug in Next.js.\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\n            throw new StaticGenBailoutError();\n        }\n    } else {\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\n            throw new StaticGenBailoutError();\n        }\n    }\n}\nexport function delayUntilRuntimeStage(prerenderStore, result) {\n    if (prerenderStore.runtimeStagePromise) {\n        return prerenderStore.runtimeStagePromise.then(()=>result);\n    }\n    return result;\n}\n\n//# sourceMappingURL=dynamic-rendering.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 953, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js"],"sourcesContent":["import * as React from 'react';\nconst errorRef = {\n    current: null\n};\n// React.cache is currently only available in canary/experimental React channels.\nconst cache = typeof React.cache === 'function' ? React.cache : (fn)=>fn;\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS ? console.error : console.warn;\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n(key)=>{\n    try {\n        logErrorOrWarn(errorRef.current);\n    } finally{\n        errorRef.current = null;\n    }\n});\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */ export function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\n    return function logDedupedError(...args) {\n        const message = getMessage(...args);\n        if (process.env.NODE_ENV !== 'production') {\n            var _stack;\n            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\n            if (callStackFrames === undefined || callStackFrames.length < 4) {\n                logErrorOrWarn(message);\n            } else {\n                // Error:\n                //   logDedupedError\n                //   asyncApiBeingAccessedSynchronously\n                //   <userland callsite>\n                // TODO: This breaks if sourcemaps with ignore lists are enabled.\n                const key = callStackFrames[4];\n                errorRef.current = message;\n                flushCurrentErrorIfNew(key);\n            }\n        } else {\n            logErrorOrWarn(message);\n        }\n    };\n}\n\n//# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,WAAW;IACb,SAAS;AACb;AACA,iFAAiF;AACjF,MAAM,QAAQ,OAAO,yNAAW,KAAK,aAAa,yNAAW,GAAG,CAAC,KAAK;AACtE,2EAA2E;AAC3E,qEAAqE;AACrE,gBAAgB;AAChB,MAAM,iBAAiB,sCAAsC,0BAAgB,QAAQ,IAAI;AACzF,2CAA2C;AAC3C,wGAAwG;AACxG,MAAM,yBAAyB,MAC/B,CAAC;IACG,IAAI;QACA,eAAe,SAAS,OAAO;IACnC,SAAS;QACL,SAAS,OAAO,GAAG;IACvB;AACJ;AAWW,SAAS,4CAA4C,UAAU;IACtE,OAAO,SAAS,gBAAgB,GAAG,IAAI;QACnC,MAAM,UAAU,cAAc;QAC9B,wCAA2C;YACvC,IAAI;YACJ,MAAM,kBAAkB,CAAC,SAAS,IAAI,QAAQ,KAAK,KAAK,OAAO,KAAK,IAAI,OAAO,KAAK,CAAC;YACrF,IAAI,oBAAoB,aAAa,gBAAgB,MAAM,GAAG,GAAG;gBAC7D,eAAe;YACnB,OAAO;gBACH,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAM,MAAM,eAAe,CAAC,EAAE;gBAC9B,SAAS,OAAO,GAAG;gBACnB,uBAAuB;YAC3B;QACJ;;IAGJ;AACJ,EAEA,0EAA0E","ignoreList":[0]}},
    {"offset": {"line": 1003, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/request/params.js"],"sourcesContent":["import { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\nimport { throwToInterruptStaticGeneration, postponeWithTracking, delayUntilRuntimeStage } from '../app-render/dynamic-rendering';\nimport { workUnitAsyncStorage, throwInvariantForMissingStore } from '../app-render/work-unit-async-storage.external';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { describeStringPropertyAccess, wellKnownProperties } from '../../shared/lib/utils/reflect-utils';\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external';\nimport { RenderStage } from '../app-render/staged-rendering';\nexport function createParamsFromClient(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createParamsFromClient should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E736\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError('createParamsFromClient should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E770\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore, workUnitStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport const createServerParamsForMetadata = createServerParamsForServerSegment;\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerParamsForRoute should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E738\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderParams(underlyingParams, workUnitStore);\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore, workUnitStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createServerParamsForServerSegment(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerParamsForServerSegment should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E743\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderParams(underlyingParams, workUnitStore);\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore, workUnitStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createPrerenderParamsForClientSegment(underlyingParams) {\n    const workStore = workAsyncStorage.getStore();\n    if (!workStore) {\n        throw Object.defineProperty(new InvariantError('Missing workStore in createPrerenderParamsForClientSegment'), \"__NEXT_ERROR_CODE\", {\n            value: \"E773\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n                const fallbackParams = workUnitStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(let key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            // This params object has one or more fallback params, so we need\n                            // to consider the awaiting of this params object \"dynamic\". Since\n                            // we are in cacheComponents mode we encode this as a promise that never\n                            // resolves.\n                            return makeHangingPromise(workUnitStore.renderSignal, workStore.route, '`params`');\n                        }\n                    }\n                }\n                break;\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createPrerenderParamsForClientSegment should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E734\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'prerender-runtime':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // We're prerendering in a mode that does not abort. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve(underlyingParams);\n}\nfunction createStaticPrerenderParams(underlyingParams, workStore, prerenderStore) {\n    switch(prerenderStore.type){\n        case 'prerender':\n        case 'prerender-client':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(const key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            // This params object has one or more fallback params, so we need\n                            // to consider the awaiting of this params object \"dynamic\". Since\n                            // we are in cacheComponents mode we encode this as a promise that never\n                            // resolves.\n                            return makeHangingParams(underlyingParams, workStore, prerenderStore);\n                        }\n                    }\n                }\n                break;\n            }\n        case 'prerender-ppr':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(const key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            return makeErroringParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n                        }\n                    }\n                }\n                break;\n            }\n        case 'prerender-legacy':\n            break;\n        default:\n            prerenderStore;\n    }\n    return makeUntrackedParams(underlyingParams);\n}\nfunction createRuntimePrerenderParams(underlyingParams, workUnitStore) {\n    return delayUntilRuntimeStage(workUnitStore, makeUntrackedParams(underlyingParams));\n}\nfunction createRenderParamsInProd(underlyingParams) {\n    return makeUntrackedParams(underlyingParams);\n}\nfunction createRenderParamsInDev(underlyingParams, devFallbackParams, workStore, requestStore) {\n    let hasFallbackParams = false;\n    if (devFallbackParams) {\n        for(let key in underlyingParams){\n            if (devFallbackParams.has(key)) {\n                hasFallbackParams = true;\n                break;\n            }\n        }\n    }\n    return makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore, requestStore);\n}\nconst CachedParams = new WeakMap();\nconst fallbackParamsProxyHandler = {\n    get: function get(target, prop, receiver) {\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n            const originalMethod = ReflectAdapter.get(target, prop, receiver);\n            return ({\n                [prop]: (...args)=>{\n                    const store = dynamicAccessAsyncStorage.getStore();\n                    if (store) {\n                        store.abortController.abort(Object.defineProperty(new Error(`Accessed fallback \\`params\\` during prerendering.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E691\",\n                            enumerable: false,\n                            configurable: true\n                        }));\n                    }\n                    return new Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);\n                }\n            })[prop];\n        }\n        return ReflectAdapter.get(target, prop, receiver);\n    }\n};\nfunction makeHangingParams(underlyingParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = new Proxy(makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`params`'), fallbackParamsProxyHandler);\n    CachedParams.set(underlyingParams, promise);\n    return promise;\n}\nfunction makeErroringParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const augmentedUnderlying = {\n        ...underlyingParams\n    };\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(augmentedUnderlying);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            if (fallbackParams.has(prop)) {\n                Object.defineProperty(augmentedUnderlying, prop, {\n                    get () {\n                        const expression = describeStringPropertyAccess('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when cacheComponents is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                    },\n                    enumerable: true\n                });\n            }\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedParams(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = Promise.resolve(underlyingParams);\n    CachedParams.set(underlyingParams, promise);\n    return promise;\n}\nfunction makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore, requestStore) {\n    if (requestStore.asyncApiPromises && hasFallbackParams) {\n        // We wrap each instance of params in a `new Promise()`, because deduping\n        // them across requests doesn't work anyway and this let us show each\n        // await a different set of values. This is important when all awaits\n        // are in third party which would otherwise track all the way to the\n        // internal params.\n        const sharedParamsParent = requestStore.asyncApiPromises.sharedParamsParent;\n        const promise = new Promise((resolve, reject)=>{\n            sharedParamsParent.then(()=>resolve(underlyingParams), reject);\n        });\n        // @ts-expect-error\n        promise.displayName = 'params';\n        return instrumentParamsPromiseWithDevWarnings(underlyingParams, promise, workStore);\n    }\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = hasFallbackParams ? makeDevtoolsIOAwarePromise(underlyingParams, requestStore, RenderStage.Runtime) : Promise.resolve(underlyingParams);\n    const proxiedPromise = instrumentParamsPromiseWithDevWarnings(underlyingParams, promise, workStore);\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction instrumentParamsPromiseWithDevWarnings(underlyingParams, promise, workStore) {\n    // Track which properties we should warn for.\n    const proxiedProperties = new Set();\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            proxiedProperties.add(prop);\n        }\n    });\n    return new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (// We are accessing a property that was proxied to the promise instance\n                proxiedProperties.has(prop)) {\n                    const expression = describeStringPropertyAccess('params', prop);\n                    warnForSyncAccess(workStore.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            const expression = '`...params` or similar expression';\n            warnForSyncAccess(workStore.route, expression);\n            return Reflect.ownKeys(target);\n        }\n    });\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createParamsAccessError);\nfunction createParamsAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E834\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=params.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 1429, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 1436, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 1444, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactJsxRuntime\n"],"names":["module","exports","require","vendored","ReactJsxRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,oIACRC,QAAQ,CAAC,YAAY,CAAEC,eAAe","ignoreList":[0]}},
    {"offset": {"line": 1449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/non-nullable.js"],"sourcesContent":["export function nonNullable(value) {\n    return value !== null && value !== undefined;\n}\n\n//# sourceMappingURL=non-nullable.js.map"],"names":[],"mappings":";;;;AAAO,SAAS,YAAY,KAAK;IAC7B,OAAO,UAAU,QAAQ,UAAU;AACvC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 1460, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/meta.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport React from 'react';\nimport { nonNullable } from '../../non-nullable';\nexport function Meta({ name, property, content, media }) {\n    if (typeof content !== 'undefined' && content !== null && content !== '') {\n        return /*#__PURE__*/ _jsx(\"meta\", {\n            ...name ? {\n                name\n            } : {\n                property\n            },\n            ...media ? {\n                media\n            } : undefined,\n            content: typeof content === 'string' ? content : content.toString()\n        });\n    }\n    return null;\n}\nexport function MetaFilter(items) {\n    const acc = [];\n    for (const item of items){\n        if (Array.isArray(item)) {\n            acc.push(...item.filter(nonNullable));\n        } else if (nonNullable(item)) {\n            acc.push(item);\n        }\n    }\n    return acc;\n}\nfunction camelToSnake(camelCaseStr) {\n    return camelCaseStr.replace(/([A-Z])/g, function(match) {\n        return '_' + match.toLowerCase();\n    });\n}\nconst aliasPropPrefixes = new Set([\n    'og:image',\n    'twitter:image',\n    'og:video',\n    'og:audio'\n]);\nfunction getMetaKey(prefix, key) {\n    // Use `twitter:image` and `og:image` instead of `twitter:image:url` and `og:image:url`\n    // to be more compatible as it's a more common format.\n    // `og:video` & `og:audio` do not have a `:url` suffix alias\n    if (aliasPropPrefixes.has(prefix) && key === 'url') {\n        return prefix;\n    }\n    if (prefix.startsWith('og:') || prefix.startsWith('twitter:')) {\n        key = camelToSnake(key);\n    }\n    return prefix + ':' + key;\n}\nfunction ExtendMeta({ content, namePrefix, propertyPrefix }) {\n    if (!content) return null;\n    return MetaFilter(Object.entries(content).map(([k, v])=>{\n        return typeof v === 'undefined' ? null : Meta({\n            ...propertyPrefix && {\n                property: getMetaKey(propertyPrefix, k)\n            },\n            ...namePrefix && {\n                name: getMetaKey(namePrefix, k)\n            },\n            content: typeof v === 'string' ? v : v == null ? void 0 : v.toString()\n        });\n    }));\n}\nexport function MultiMeta({ propertyPrefix, namePrefix, contents }) {\n    if (typeof contents === 'undefined' || contents === null) {\n        return null;\n    }\n    return MetaFilter(contents.map((content)=>{\n        if (typeof content === 'string' || typeof content === 'number' || content instanceof URL) {\n            return Meta({\n                ...propertyPrefix ? {\n                    property: propertyPrefix\n                } : {\n                    name: namePrefix\n                },\n                content\n            });\n        } else {\n            return ExtendMeta({\n                namePrefix,\n                propertyPrefix,\n                content\n            });\n        }\n    }));\n}\n\n//# sourceMappingURL=meta.js.map"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AACO,SAAS,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;IACnD,IAAI,OAAO,YAAY,eAAe,YAAY,QAAQ,YAAY,IAAI;QACtE,OAAO,WAAW,GAAG,IAAA,yOAAI,EAAC,QAAQ;YAC9B,GAAG,OAAO;gBACN;YACJ,IAAI;gBACA;YACJ,CAAC;YACD,GAAG,QAAQ;gBACP;YACJ,IAAI,SAAS;YACb,SAAS,OAAO,YAAY,WAAW,UAAU,QAAQ,QAAQ;QACrE;IACJ;IACA,OAAO;AACX;AACO,SAAS,WAAW,KAAK;IAC5B,MAAM,MAAM,EAAE;IACd,KAAK,MAAM,QAAQ,MAAM;QACrB,IAAI,MAAM,OAAO,CAAC,OAAO;YACrB,IAAI,IAAI,IAAI,KAAK,MAAM,CAAC,kMAAW;QACvC,OAAO,IAAI,IAAA,kMAAW,EAAC,OAAO;YAC1B,IAAI,IAAI,CAAC;QACb;IACJ;IACA,OAAO;AACX;AACA,SAAS,aAAa,YAAY;IAC9B,OAAO,aAAa,OAAO,CAAC,YAAY,SAAS,KAAK;QAClD,OAAO,MAAM,MAAM,WAAW;IAClC;AACJ;AACA,MAAM,oBAAoB,IAAI,IAAI;IAC9B;IACA;IACA;IACA;CACH;AACD,SAAS,WAAW,MAAM,EAAE,GAAG;IAC3B,uFAAuF;IACvF,sDAAsD;IACtD,4DAA4D;IAC5D,IAAI,kBAAkB,GAAG,CAAC,WAAW,QAAQ,OAAO;QAChD,OAAO;IACX;IACA,IAAI,OAAO,UAAU,CAAC,UAAU,OAAO,UAAU,CAAC,aAAa;QAC3D,MAAM,aAAa;IACvB;IACA,OAAO,SAAS,MAAM;AAC1B;AACA,SAAS,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE;IACvD,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,WAAW,OAAO,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE;QACjD,OAAO,OAAO,MAAM,cAAc,OAAO,KAAK;YAC1C,GAAG,kBAAkB;gBACjB,UAAU,WAAW,gBAAgB;YACzC,CAAC;YACD,GAAG,cAAc;gBACb,MAAM,WAAW,YAAY;YACjC,CAAC;YACD,SAAS,OAAO,MAAM,WAAW,IAAI,KAAK,OAAO,KAAK,IAAI,EAAE,QAAQ;QACxE;IACJ;AACJ;AACO,SAAS,UAAU,EAAE,cAAc,EAAE,UAAU,EAAE,QAAQ,EAAE;IAC9D,IAAI,OAAO,aAAa,eAAe,aAAa,MAAM;QACtD,OAAO;IACX;IACA,OAAO,WAAW,SAAS,GAAG,CAAC,CAAC;QAC5B,IAAI,OAAO,YAAY,YAAY,OAAO,YAAY,YAAY,mBAAmB,KAAK;YACtF,OAAO,KAAK;gBACR,GAAG,iBAAiB;oBAChB,UAAU;gBACd,IAAI;oBACA,MAAM;gBACV,CAAC;gBACD;YACJ;QACJ,OAAO;YACH,OAAO,WAAW;gBACd;gBACA;gBACA;YACJ;QACJ;IACJ;AACJ,EAEA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 1565, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/constants.js"],"sourcesContent":["export const ViewportMetaKeys = {\n    width: 'width',\n    height: 'height',\n    initialScale: 'initial-scale',\n    minimumScale: 'minimum-scale',\n    maximumScale: 'maximum-scale',\n    viewportFit: 'viewport-fit',\n    userScalable: 'user-scalable',\n    interactiveWidget: 'interactive-widget'\n};\nexport const IconKeys = [\n    'icon',\n    'shortcut',\n    'apple',\n    'other'\n];\n\n//# sourceMappingURL=constants.js.map"],"names":[],"mappings":";;;;;;AAAO,MAAM,mBAAmB;IAC5B,OAAO;IACP,QAAQ;IACR,cAAc;IACd,cAAc;IACd,cAAc;IACd,aAAa;IACb,cAAc;IACd,mBAAmB;AACvB;AACO,MAAM,WAAW;IACpB;IACA;IACA;IACA;CACH,EAED,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 1591, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/basic.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Meta, MetaFilter, MultiMeta } from './meta';\nimport { ViewportMetaKeys } from '../constants';\nimport { getOrigin } from './utils';\n// convert viewport object to string for viewport meta tag\nfunction resolveViewportLayout(viewport) {\n    let resolved = null;\n    if (viewport && typeof viewport === 'object') {\n        resolved = '';\n        for(const viewportKey_ in ViewportMetaKeys){\n            const viewportKey = viewportKey_;\n            if (viewportKey in viewport) {\n                let value = viewport[viewportKey];\n                if (typeof value === 'boolean') {\n                    value = value ? 'yes' : 'no';\n                } else if (!value && viewportKey === 'initialScale') {\n                    value = undefined;\n                }\n                if (value) {\n                    if (resolved) resolved += ', ';\n                    resolved += `${ViewportMetaKeys[viewportKey]}=${value}`;\n                }\n            }\n        }\n    }\n    return resolved;\n}\nexport function ViewportMeta({ viewport }) {\n    return MetaFilter([\n        /*#__PURE__*/ _jsx(\"meta\", {\n            charSet: \"utf-8\"\n        }),\n        Meta({\n            name: 'viewport',\n            content: resolveViewportLayout(viewport)\n        }),\n        ...viewport.themeColor ? viewport.themeColor.map((themeColor)=>Meta({\n                name: 'theme-color',\n                content: themeColor.color,\n                media: themeColor.media\n            })) : [],\n        Meta({\n            name: 'color-scheme',\n            content: viewport.colorScheme\n        })\n    ]);\n}\nexport function BasicMeta({ metadata }) {\n    var _metadata_keywords, _metadata_robots, _metadata_robots1;\n    const manifestOrigin = metadata.manifest ? getOrigin(metadata.manifest) : undefined;\n    return MetaFilter([\n        metadata.title !== null && metadata.title.absolute ? /*#__PURE__*/ _jsx(\"title\", {\n            children: metadata.title.absolute\n        }) : null,\n        Meta({\n            name: 'description',\n            content: metadata.description\n        }),\n        Meta({\n            name: 'application-name',\n            content: metadata.applicationName\n        }),\n        ...metadata.authors ? metadata.authors.map((author)=>[\n                author.url ? /*#__PURE__*/ _jsx(\"link\", {\n                    rel: \"author\",\n                    href: author.url.toString()\n                }) : null,\n                Meta({\n                    name: 'author',\n                    content: author.name\n                })\n            ]) : [],\n        metadata.manifest ? /*#__PURE__*/ _jsx(\"link\", {\n            rel: \"manifest\",\n            href: metadata.manifest.toString(),\n            // If it's same origin, and it's a preview deployment,\n            // including credentials for manifest request.\n            crossOrigin: !manifestOrigin && process.env.VERCEL_ENV === 'preview' ? 'use-credentials' : undefined\n        }) : null,\n        Meta({\n            name: 'generator',\n            content: metadata.generator\n        }),\n        Meta({\n            name: 'keywords',\n            content: (_metadata_keywords = metadata.keywords) == null ? void 0 : _metadata_keywords.join(',')\n        }),\n        Meta({\n            name: 'referrer',\n            content: metadata.referrer\n        }),\n        Meta({\n            name: 'creator',\n            content: metadata.creator\n        }),\n        Meta({\n            name: 'publisher',\n            content: metadata.publisher\n        }),\n        Meta({\n            name: 'robots',\n            content: (_metadata_robots = metadata.robots) == null ? void 0 : _metadata_robots.basic\n        }),\n        Meta({\n            name: 'googlebot',\n            content: (_metadata_robots1 = metadata.robots) == null ? void 0 : _metadata_robots1.googleBot\n        }),\n        Meta({\n            name: 'abstract',\n            content: metadata.abstract\n        }),\n        ...metadata.archives ? metadata.archives.map((archive)=>/*#__PURE__*/ _jsx(\"link\", {\n                rel: \"archives\",\n                href: archive\n            })) : [],\n        ...metadata.assets ? metadata.assets.map((asset)=>/*#__PURE__*/ _jsx(\"link\", {\n                rel: \"assets\",\n                href: asset\n            })) : [],\n        ...metadata.bookmarks ? metadata.bookmarks.map((bookmark)=>/*#__PURE__*/ _jsx(\"link\", {\n                rel: \"bookmarks\",\n                href: bookmark\n            })) : [],\n        ...metadata.pagination ? [\n            metadata.pagination.previous ? /*#__PURE__*/ _jsx(\"link\", {\n                rel: \"prev\",\n                href: metadata.pagination.previous\n            }) : null,\n            metadata.pagination.next ? /*#__PURE__*/ _jsx(\"link\", {\n                rel: \"next\",\n                href: metadata.pagination.next\n            }) : null\n        ] : [],\n        Meta({\n            name: 'category',\n            content: metadata.category\n        }),\n        Meta({\n            name: 'classification',\n            content: metadata.classification\n        }),\n        ...metadata.other ? Object.entries(metadata.other).map(([name, content])=>{\n            if (Array.isArray(content)) {\n                return content.map((contentItem)=>Meta({\n                        name,\n                        content: contentItem\n                    }));\n            } else {\n                return Meta({\n                    name,\n                    content\n                });\n            }\n        }) : []\n    ]);\n}\nexport function ItunesMeta({ itunes }) {\n    if (!itunes) return null;\n    const { appId, appArgument } = itunes;\n    let content = `app-id=${appId}`;\n    if (appArgument) {\n        content += `, app-argument=${appArgument}`;\n    }\n    return /*#__PURE__*/ _jsx(\"meta\", {\n        name: \"apple-itunes-app\",\n        content: content\n    });\n}\nexport function FacebookMeta({ facebook }) {\n    if (!facebook) return null;\n    const { appId, admins } = facebook;\n    return MetaFilter([\n        appId ? /*#__PURE__*/ _jsx(\"meta\", {\n            property: \"fb:app_id\",\n            content: appId\n        }) : null,\n        ...admins ? admins.map((admin)=>/*#__PURE__*/ _jsx(\"meta\", {\n                property: \"fb:admins\",\n                content: admin\n            })) : []\n    ]);\n}\nexport function PinterestMeta({ pinterest }) {\n    if (!pinterest || pinterest.richPin === undefined) return null;\n    const { richPin } = pinterest;\n    return /*#__PURE__*/ _jsx(\"meta\", {\n        property: \"pinterest-rich-pin\",\n        content: richPin.toString()\n    });\n}\nconst formatDetectionKeys = [\n    'telephone',\n    'date',\n    'address',\n    'email',\n    'url'\n];\nexport function FormatDetectionMeta({ formatDetection }) {\n    if (!formatDetection) return null;\n    let content = '';\n    for (const key of formatDetectionKeys){\n        if (formatDetection[key] === false) {\n            if (content) content += ', ';\n            content += `${key}=no`;\n        }\n    }\n    return content ? /*#__PURE__*/ _jsx(\"meta\", {\n        name: \"format-detection\",\n        content: content\n    }) : null;\n}\nexport function AppleWebAppMeta({ appleWebApp }) {\n    if (!appleWebApp) return null;\n    const { capable, title, startupImage, statusBarStyle } = appleWebApp;\n    return MetaFilter([\n        capable ? Meta({\n            name: 'mobile-web-app-capable',\n            content: 'yes'\n        }) : null,\n        Meta({\n            name: 'apple-mobile-web-app-title',\n            content: title\n        }),\n        startupImage ? startupImage.map((image)=>/*#__PURE__*/ _jsx(\"link\", {\n                href: image.url,\n                media: image.media,\n                rel: \"apple-touch-startup-image\"\n            })) : null,\n        statusBarStyle ? Meta({\n            name: 'apple-mobile-web-app-status-bar-style',\n            content: statusBarStyle\n        }) : null\n    ]);\n}\nexport function VerificationMeta({ verification }) {\n    if (!verification) return null;\n    return MetaFilter([\n        MultiMeta({\n            namePrefix: 'google-site-verification',\n            contents: verification.google\n        }),\n        MultiMeta({\n            namePrefix: 'y_key',\n            contents: verification.yahoo\n        }),\n        MultiMeta({\n            namePrefix: 'yandex-verification',\n            contents: verification.yandex\n        }),\n        MultiMeta({\n            namePrefix: 'me',\n            contents: verification.me\n        }),\n        ...verification.other ? Object.entries(verification.other).map(([key, value])=>MultiMeta({\n                namePrefix: key,\n                contents: value\n            })) : []\n    ]);\n}\n\n//# sourceMappingURL=basic.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1880, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/alternate.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport React from 'react';\nimport { MetaFilter } from './meta';\nfunction AlternateLink({ descriptor, ...props }) {\n    if (!descriptor.url) return null;\n    return /*#__PURE__*/ _jsx(\"link\", {\n        ...props,\n        ...descriptor.title && {\n            title: descriptor.title\n        },\n        href: descriptor.url.toString()\n    });\n}\nexport function AlternatesMetadata({ alternates }) {\n    if (!alternates) return null;\n    const { canonical, languages, media, types } = alternates;\n    return MetaFilter([\n        canonical ? AlternateLink({\n            rel: 'canonical',\n            descriptor: canonical\n        }) : null,\n        languages ? Object.entries(languages).flatMap(([locale, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({\n                    rel: 'alternate',\n                    hrefLang: locale,\n                    descriptor\n                }))) : null,\n        media ? Object.entries(media).flatMap(([mediaName, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({\n                    rel: 'alternate',\n                    media: mediaName,\n                    descriptor\n                }))) : null,\n        types ? Object.entries(types).flatMap(([type, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({\n                    rel: 'alternate',\n                    type,\n                    descriptor\n                }))) : null\n    ]);\n}\n\n//# sourceMappingURL=alternate.js.map"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,SAAS,cAAc,EAAE,UAAU,EAAE,GAAG,OAAO;IAC3C,IAAI,CAAC,WAAW,GAAG,EAAE,OAAO;IAC5B,OAAO,WAAW,GAAG,IAAA,yOAAI,EAAC,QAAQ;QAC9B,GAAG,KAAK;QACR,GAAG,WAAW,KAAK,IAAI;YACnB,OAAO,WAAW,KAAK;QAC3B,CAAC;QACD,MAAM,WAAW,GAAG,CAAC,QAAQ;IACjC;AACJ;AACO,SAAS,mBAAmB,EAAE,UAAU,EAAE;IAC7C,IAAI,CAAC,YAAY,OAAO;IACxB,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG;IAC/C,OAAO,IAAA,8MAAU,EAAC;QACd,YAAY,cAAc;YACtB,KAAK;YACL,YAAY;QAChB,KAAK;QACL,YAAY,OAAO,OAAO,CAAC,WAAW,OAAO,CAAC,CAAC,CAAC,QAAQ,YAAY,GAAG,eAAe,OAAO,KAAK,IAAI,YAAY,GAAG,CAAC,CAAC,aAAa,cAAc;oBACtI,KAAK;oBACL,UAAU;oBACV;gBACJ,OAAO;QACf,QAAQ,OAAO,OAAO,CAAC,OAAO,OAAO,CAAC,CAAC,CAAC,WAAW,YAAY,GAAG,eAAe,OAAO,KAAK,IAAI,YAAY,GAAG,CAAC,CAAC,aAAa,cAAc;oBACjI,KAAK;oBACL,OAAO;oBACP;gBACJ,OAAO;QACf,QAAQ,OAAO,OAAO,CAAC,OAAO,OAAO,CAAC,CAAC,CAAC,MAAM,YAAY,GAAG,eAAe,OAAO,KAAK,IAAI,YAAY,GAAG,CAAC,CAAC,aAAa,cAAc;oBAC5H,KAAK;oBACL;oBACA;gBACJ,OAAO;KAClB;AACL,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 1929, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/opengraph.js"],"sourcesContent":["import { Meta, MetaFilter, MultiMeta } from './meta';\nexport function OpenGraphMetadata({ openGraph }) {\n    var _openGraph_title, _openGraph_url, _openGraph_ttl;\n    if (!openGraph) {\n        return null;\n    }\n    let typedOpenGraph;\n    if ('type' in openGraph) {\n        const openGraphType = openGraph.type;\n        switch(openGraphType){\n            case 'website':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'website'\n                    })\n                ];\n                break;\n            case 'article':\n                var _openGraph_publishedTime, _openGraph_modifiedTime, _openGraph_expirationTime;\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'article'\n                    }),\n                    Meta({\n                        property: 'article:published_time',\n                        content: (_openGraph_publishedTime = openGraph.publishedTime) == null ? void 0 : _openGraph_publishedTime.toString()\n                    }),\n                    Meta({\n                        property: 'article:modified_time',\n                        content: (_openGraph_modifiedTime = openGraph.modifiedTime) == null ? void 0 : _openGraph_modifiedTime.toString()\n                    }),\n                    Meta({\n                        property: 'article:expiration_time',\n                        content: (_openGraph_expirationTime = openGraph.expirationTime) == null ? void 0 : _openGraph_expirationTime.toString()\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'article:author',\n                        contents: openGraph.authors\n                    }),\n                    Meta({\n                        property: 'article:section',\n                        content: openGraph.section\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'article:tag',\n                        contents: openGraph.tags\n                    })\n                ];\n                break;\n            case 'book':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'book'\n                    }),\n                    Meta({\n                        property: 'book:isbn',\n                        content: openGraph.isbn\n                    }),\n                    Meta({\n                        property: 'book:release_date',\n                        content: openGraph.releaseDate\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'book:author',\n                        contents: openGraph.authors\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'book:tag',\n                        contents: openGraph.tags\n                    })\n                ];\n                break;\n            case 'profile':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'profile'\n                    }),\n                    Meta({\n                        property: 'profile:first_name',\n                        content: openGraph.firstName\n                    }),\n                    Meta({\n                        property: 'profile:last_name',\n                        content: openGraph.lastName\n                    }),\n                    Meta({\n                        property: 'profile:username',\n                        content: openGraph.username\n                    }),\n                    Meta({\n                        property: 'profile:gender',\n                        content: openGraph.gender\n                    })\n                ];\n                break;\n            case 'music.song':\n                var _openGraph_duration;\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'music.song'\n                    }),\n                    Meta({\n                        property: 'music:duration',\n                        content: (_openGraph_duration = openGraph.duration) == null ? void 0 : _openGraph_duration.toString()\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:album',\n                        contents: openGraph.albums\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:musician',\n                        contents: openGraph.musicians\n                    })\n                ];\n                break;\n            case 'music.album':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'music.album'\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:song',\n                        contents: openGraph.songs\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:musician',\n                        contents: openGraph.musicians\n                    }),\n                    Meta({\n                        property: 'music:release_date',\n                        content: openGraph.releaseDate\n                    })\n                ];\n                break;\n            case 'music.playlist':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'music.playlist'\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:song',\n                        contents: openGraph.songs\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:creator',\n                        contents: openGraph.creators\n                    })\n                ];\n                break;\n            case 'music.radio_station':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'music.radio_station'\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'music:creator',\n                        contents: openGraph.creators\n                    })\n                ];\n                break;\n            case 'video.movie':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'video.movie'\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:actor',\n                        contents: openGraph.actors\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:director',\n                        contents: openGraph.directors\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:writer',\n                        contents: openGraph.writers\n                    }),\n                    Meta({\n                        property: 'video:duration',\n                        content: openGraph.duration\n                    }),\n                    Meta({\n                        property: 'video:release_date',\n                        content: openGraph.releaseDate\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:tag',\n                        contents: openGraph.tags\n                    })\n                ];\n                break;\n            case 'video.episode':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'video.episode'\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:actor',\n                        contents: openGraph.actors\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:director',\n                        contents: openGraph.directors\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:writer',\n                        contents: openGraph.writers\n                    }),\n                    Meta({\n                        property: 'video:duration',\n                        content: openGraph.duration\n                    }),\n                    Meta({\n                        property: 'video:release_date',\n                        content: openGraph.releaseDate\n                    }),\n                    MultiMeta({\n                        propertyPrefix: 'video:tag',\n                        contents: openGraph.tags\n                    }),\n                    Meta({\n                        property: 'video:series',\n                        content: openGraph.series\n                    })\n                ];\n                break;\n            case 'video.tv_show':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'video.tv_show'\n                    })\n                ];\n                break;\n            case 'video.other':\n                typedOpenGraph = [\n                    Meta({\n                        property: 'og:type',\n                        content: 'video.other'\n                    })\n                ];\n                break;\n            default:\n                const _exhaustiveCheck = openGraphType;\n                throw Object.defineProperty(new Error(`Invalid OpenGraph type: ${_exhaustiveCheck}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E237\",\n                    enumerable: false,\n                    configurable: true\n                });\n        }\n    }\n    return MetaFilter([\n        Meta({\n            property: 'og:determiner',\n            content: openGraph.determiner\n        }),\n        Meta({\n            property: 'og:title',\n            content: (_openGraph_title = openGraph.title) == null ? void 0 : _openGraph_title.absolute\n        }),\n        Meta({\n            property: 'og:description',\n            content: openGraph.description\n        }),\n        Meta({\n            property: 'og:url',\n            content: (_openGraph_url = openGraph.url) == null ? void 0 : _openGraph_url.toString()\n        }),\n        Meta({\n            property: 'og:site_name',\n            content: openGraph.siteName\n        }),\n        Meta({\n            property: 'og:locale',\n            content: openGraph.locale\n        }),\n        Meta({\n            property: 'og:country_name',\n            content: openGraph.countryName\n        }),\n        Meta({\n            property: 'og:ttl',\n            content: (_openGraph_ttl = openGraph.ttl) == null ? void 0 : _openGraph_ttl.toString()\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:image',\n            contents: openGraph.images\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:video',\n            contents: openGraph.videos\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:audio',\n            contents: openGraph.audio\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:email',\n            contents: openGraph.emails\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:phone_number',\n            contents: openGraph.phoneNumbers\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:fax_number',\n            contents: openGraph.faxNumbers\n        }),\n        MultiMeta({\n            propertyPrefix: 'og:locale:alternate',\n            contents: openGraph.alternateLocale\n        }),\n        ...typedOpenGraph ? typedOpenGraph : []\n    ]);\n}\nfunction TwitterAppItem({ app, type }) {\n    var _app_url_type, _app_url;\n    return [\n        Meta({\n            name: `twitter:app:name:${type}`,\n            content: app.name\n        }),\n        Meta({\n            name: `twitter:app:id:${type}`,\n            content: app.id[type]\n        }),\n        Meta({\n            name: `twitter:app:url:${type}`,\n            content: (_app_url = app.url) == null ? void 0 : (_app_url_type = _app_url[type]) == null ? void 0 : _app_url_type.toString()\n        })\n    ];\n}\nexport function TwitterMetadata({ twitter }) {\n    var _twitter_title;\n    if (!twitter) return null;\n    const { card } = twitter;\n    return MetaFilter([\n        Meta({\n            name: 'twitter:card',\n            content: card\n        }),\n        Meta({\n            name: 'twitter:site',\n            content: twitter.site\n        }),\n        Meta({\n            name: 'twitter:site:id',\n            content: twitter.siteId\n        }),\n        Meta({\n            name: 'twitter:creator',\n            content: twitter.creator\n        }),\n        Meta({\n            name: 'twitter:creator:id',\n            content: twitter.creatorId\n        }),\n        Meta({\n            name: 'twitter:title',\n            content: (_twitter_title = twitter.title) == null ? void 0 : _twitter_title.absolute\n        }),\n        Meta({\n            name: 'twitter:description',\n            content: twitter.description\n        }),\n        MultiMeta({\n            namePrefix: 'twitter:image',\n            contents: twitter.images\n        }),\n        ...card === 'player' ? twitter.players.flatMap((player)=>[\n                Meta({\n                    name: 'twitter:player',\n                    content: player.playerUrl.toString()\n                }),\n                Meta({\n                    name: 'twitter:player:stream',\n                    content: player.streamUrl.toString()\n                }),\n                Meta({\n                    name: 'twitter:player:width',\n                    content: player.width\n                }),\n                Meta({\n                    name: 'twitter:player:height',\n                    content: player.height\n                })\n            ]) : [],\n        ...card === 'app' ? [\n            TwitterAppItem({\n                app: twitter.app,\n                type: 'iphone'\n            }),\n            TwitterAppItem({\n                app: twitter.app,\n                type: 'ipad'\n            }),\n            TwitterAppItem({\n                app: twitter.app,\n                type: 'googleplay'\n            })\n        ] : []\n    ]);\n}\nexport function AppLinksMeta({ appLinks }) {\n    if (!appLinks) return null;\n    return MetaFilter([\n        MultiMeta({\n            propertyPrefix: 'al:ios',\n            contents: appLinks.ios\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:iphone',\n            contents: appLinks.iphone\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:ipad',\n            contents: appLinks.ipad\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:android',\n            contents: appLinks.android\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:windows_phone',\n            contents: appLinks.windows_phone\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:windows',\n            contents: appLinks.windows\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:windows_universal',\n            contents: appLinks.windows_universal\n        }),\n        MultiMeta({\n            propertyPrefix: 'al:web',\n            contents: appLinks.web\n        })\n    ]);\n}\n\n//# sourceMappingURL=opengraph.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2391, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 2397, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 2404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2412, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/generate/icons.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { IconMark } from './icon-mark';\nimport { MetaFilter } from './meta';\nfunction IconDescriptorLink({ icon }) {\n    const { url, rel = 'icon', ...props } = icon;\n    return /*#__PURE__*/ _jsx(\"link\", {\n        rel: rel,\n        href: url.toString(),\n        ...props\n    });\n}\nfunction IconLink({ rel, icon }) {\n    if (typeof icon === 'object' && !(icon instanceof URL)) {\n        if (!icon.rel && rel) icon.rel = rel;\n        return IconDescriptorLink({\n            icon\n        });\n    } else {\n        const href = icon.toString();\n        return /*#__PURE__*/ _jsx(\"link\", {\n            rel: rel,\n            href: href\n        });\n    }\n}\nexport function IconsMetadata({ icons }) {\n    if (!icons) return null;\n    const shortcutList = icons.shortcut;\n    const iconList = icons.icon;\n    const appleList = icons.apple;\n    const otherList = icons.other;\n    const hasIcon = Boolean((shortcutList == null ? void 0 : shortcutList.length) || (iconList == null ? void 0 : iconList.length) || (appleList == null ? void 0 : appleList.length) || (otherList == null ? void 0 : otherList.length));\n    if (!hasIcon) return null;\n    return MetaFilter([\n        shortcutList ? shortcutList.map((icon)=>IconLink({\n                rel: 'shortcut icon',\n                icon\n            })) : null,\n        iconList ? iconList.map((icon)=>IconLink({\n                rel: 'icon',\n                icon\n            })) : null,\n        appleList ? appleList.map((icon)=>IconLink({\n                rel: 'apple-touch-icon',\n                icon\n            })) : null,\n        otherList ? otherList.map((icon)=>IconDescriptorLink({\n                icon\n            })) : null,\n        hasIcon ? /*#__PURE__*/ _jsx(IconMark, {}) : null\n    ]);\n}\n\n//# sourceMappingURL=icons.js.map"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,SAAS,mBAAmB,EAAE,IAAI,EAAE;IAChC,MAAM,EAAE,GAAG,EAAE,MAAM,MAAM,EAAE,GAAG,OAAO,GAAG;IACxC,OAAO,WAAW,GAAG,IAAA,yOAAI,EAAC,QAAQ;QAC9B,KAAK;QACL,MAAM,IAAI,QAAQ;QAClB,GAAG,KAAK;IACZ;AACJ;AACA,SAAS,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE;IAC3B,IAAI,OAAO,SAAS,YAAY,CAAC,CAAC,gBAAgB,GAAG,GAAG;QACpD,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,GAAG;QACjC,OAAO,mBAAmB;YACtB;QACJ;IACJ,OAAO;QACH,MAAM,OAAO,KAAK,QAAQ;QAC1B,OAAO,WAAW,GAAG,IAAA,yOAAI,EAAC,QAAQ;YAC9B,KAAK;YACL,MAAM;QACV;IACJ;AACJ;AACO,SAAS,cAAc,EAAE,KAAK,EAAE;IACnC,IAAI,CAAC,OAAO,OAAO;IACnB,MAAM,eAAe,MAAM,QAAQ;IACnC,MAAM,WAAW,MAAM,IAAI;IAC3B,MAAM,YAAY,MAAM,KAAK;IAC7B,MAAM,YAAY,MAAM,KAAK;IAC7B,MAAM,UAAU,QAAQ,CAAC,gBAAgB,OAAO,KAAK,IAAI,aAAa,MAAM,KAAK,CAAC,YAAY,OAAO,KAAK,IAAI,SAAS,MAAM,KAAK,CAAC,aAAa,OAAO,KAAK,IAAI,UAAU,MAAM,KAAK,CAAC,aAAa,OAAO,KAAK,IAAI,UAAU,MAAM;IACnO,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,IAAA,8MAAU,EAAC;QACd,eAAe,aAAa,GAAG,CAAC,CAAC,OAAO,SAAS;gBACzC,KAAK;gBACL;YACJ,MAAM;QACV,WAAW,SAAS,GAAG,CAAC,CAAC,OAAO,SAAS;gBACjC,KAAK;gBACL;YACJ,MAAM;QACV,YAAY,UAAU,GAAG,CAAC,CAAC,OAAO,SAAS;gBACnC,KAAK;gBACL;YACJ,MAAM;QACV,YAAY,UAAU,GAAG,CAAC,CAAC,OAAO,mBAAmB;gBAC7C;YACJ,MAAM;QACV,UAAU,WAAW,GAAG,IAAA,yOAAI,EAAC,oNAAQ,EAAE,CAAC,KAAK;KAChD;AACL,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 2475, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/http-access-fallback/http-access-fallback.js"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    UNAUTHORIZED: 401\n};\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */ export function isHTTPAccessFallbackError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const [prefix, httpStatus] = error.digest.split(';');\n    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));\n}\nexport function getAccessFallbackHTTPStatus(error) {\n    const httpStatus = error.digest.split(';')[1];\n    return Number(httpStatus);\n}\nexport function getAccessFallbackErrorTypeByStatus(status) {\n    switch(status){\n        case 401:\n            return 'unauthorized';\n        case 403:\n            return 'forbidden';\n        case 404:\n            return 'not-found';\n        default:\n            return;\n    }\n}\n\n//# sourceMappingURL=http-access-fallback.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,wBAAwB;IACjC,WAAW;IACX,WAAW;IACX,cAAc;AAClB;AACA,MAAM,gBAAgB,IAAI,IAAI,OAAO,MAAM,CAAC;AACrC,MAAM,iCAAiC;AAOnC,SAAS,0BAA0B,KAAK;IAC/C,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,YAAY,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,UAAU;QACzG,OAAO;IACX;IACA,MAAM,CAAC,QAAQ,WAAW,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC;IAChD,OAAO,WAAW,kCAAkC,cAAc,GAAG,CAAC,OAAO;AACjF;AACO,SAAS,4BAA4B,KAAK;IAC7C,MAAM,aAAa,MAAM,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAO,OAAO;AAClB;AACO,SAAS,mCAAmC,MAAM;IACrD,OAAO;QACH,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI;IACR;AACJ,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 2521, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/request/pathname.js"],"sourcesContent":["import { delayUntilRuntimeStage, postponeWithTracking } from '../app-render/dynamic-rendering';\nimport { throwInvariantForMissingStore, workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nexport function createServerPathnameForMetadata(underlyingPathname, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                {\n                    return createPrerenderPathname(underlyingPathname, workStore, workUnitStore);\n                }\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerPathnameForMetadata should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E740\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return delayUntilRuntimeStage(workUnitStore, createRenderPathname(underlyingPathname));\n            case 'request':\n                return createRenderPathname(underlyingPathname);\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nfunction createPrerenderPathname(underlyingPathname, workStore, prerenderStore) {\n    switch(prerenderStore.type){\n        case 'prerender-client':\n            throw Object.defineProperty(new InvariantError('createPrerenderPathname was called inside a client component scope.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E694\",\n                enumerable: false,\n                configurable: true\n            });\n        case 'prerender':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams && fallbackParams.size > 0) {\n                    return makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`pathname`');\n                }\n                break;\n            }\n        case 'prerender-ppr':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams && fallbackParams.size > 0) {\n                    return makeErroringPathname(workStore, prerenderStore.dynamicTracking);\n                }\n                break;\n            }\n        case 'prerender-legacy':\n            break;\n        default:\n            prerenderStore;\n    }\n    // We don't have any fallback params so we have an entirely static safe params object\n    return Promise.resolve(underlyingPathname);\n}\nfunction makeErroringPathname(workStore, dynamicTracking) {\n    let reject = null;\n    const promise = new Promise((_, re)=>{\n        reject = re;\n    });\n    const originalThen = promise.then.bind(promise);\n    // We instrument .then so that we can generate a tracking event only if you actually\n    // await this promise, not just that it is created.\n    promise.then = (onfulfilled, onrejected)=>{\n        if (reject) {\n            try {\n                postponeWithTracking(workStore.route, 'metadata relative url resolving', dynamicTracking);\n            } catch (error) {\n                reject(error);\n                reject = null;\n            }\n        }\n        return originalThen(onfulfilled, onrejected);\n    };\n    // We wrap in a noop proxy to trick the runtime into thinking it\n    // isn't a native promise (it's not really). This is so that awaiting\n    // the promise will call the `then` property triggering the lazy postpone\n    return new Proxy(promise, {});\n}\nfunction createRenderPathname(underlyingPathname) {\n    return Promise.resolve(underlyingPathname);\n}\n\n//# sourceMappingURL=pathname.js.map"],"names":[],"mappings":";;;;AAAA;;;;;;AAEA;AACA;;;;;AACO,SAAS,gCAAgC,kBAAkB,EAAE,SAAS;IACzE,MAAM,gBAAgB,qBAAqB,QAAQ;IACnD,IAAI,eAAe;QACf,OAAO,cAAc,IAAI;YACrB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACD;oBACI,OAAO,wBAAwB,oBAAoB,WAAW;gBAClE;YACJ,KAAK;YACL,KAAK;YACL,KAAK;gBACD,MAAM,OAAO,cAAc,CAAC,IAAI,kNAAc,CAAC,4EAA4E,qBAAqB;oBAC5I,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ,KAAK;gBACD,OAAO,IAAA,sOAAsB,EAAC,eAAe,qBAAqB;YACtE,KAAK;gBACD,OAAO,qBAAqB;YAChC;gBACI;QACR;IACJ;IACA;AACJ;AACA,SAAS,wBAAwB,kBAAkB,EAAE,SAAS,EAAE,cAAc;IAC1E,OAAO,eAAe,IAAI;QACtB,KAAK;YACD,MAAM,OAAO,cAAc,CAAC,IAAI,kNAAc,CAAC,wEAAwE,qBAAqB;gBACxI,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ,KAAK;YACD;gBACI,MAAM,iBAAiB,eAAe,mBAAmB;gBACzD,IAAI,kBAAkB,eAAe,IAAI,GAAG,GAAG;oBAC3C,OAAO,IAAA,0NAAkB,EAAC,eAAe,YAAY,EAAE,UAAU,KAAK,EAAE;gBAC5E;gBACA;YACJ;QACJ,KAAK;YACD;gBACI,MAAM,iBAAiB,eAAe,mBAAmB;gBACzD,IAAI,kBAAkB,eAAe,IAAI,GAAG,GAAG;oBAC3C,OAAO,qBAAqB,WAAW,eAAe,eAAe;gBACzE;gBACA;YACJ;QACJ,KAAK;YACD;QACJ;YACI;IACR;IACA,qFAAqF;IACrF,OAAO,QAAQ,OAAO,CAAC;AAC3B;AACA,SAAS,qBAAqB,SAAS,EAAE,eAAe;IACpD,IAAI,SAAS;IACb,MAAM,UAAU,IAAI,QAAQ,CAAC,GAAG;QAC5B,SAAS;IACb;IACA,MAAM,eAAe,QAAQ,IAAI,CAAC,IAAI,CAAC;IACvC,oFAAoF;IACpF,mDAAmD;IACnD,QAAQ,IAAI,GAAG,CAAC,aAAa;QACzB,IAAI,QAAQ;YACR,IAAI;gBACA,IAAA,oOAAoB,EAAC,UAAU,KAAK,EAAE,mCAAmC;YAC7E,EAAE,OAAO,OAAO;gBACZ,OAAO;gBACP,SAAS;YACb;QACJ;QACA,OAAO,aAAa,aAAa;IACrC;IACA,gEAAgE;IAChE,qEAAqE;IACrE,yEAAyE;IACzE,OAAO,IAAI,MAAM,SAAS,CAAC;AAC/B;AACA,SAAS,qBAAqB,kBAAkB;IAC5C,OAAO,QAAQ,OAAO,CAAC;AAC3B,EAEA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 2629, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/lib/router-utils/is-postpone.js"],"sourcesContent":["const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');\nexport function isPostpone(error) {\n    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;\n}\n\n//# sourceMappingURL=is-postpone.js.map"],"names":[],"mappings":";;;;AAAA,MAAM,sBAAsB,OAAO,GAAG,CAAC;AAChC,SAAS,WAAW,KAAK;IAC5B,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,QAAQ,KAAK;AAC7E,EAEA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 2640, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/framework/boundary-components.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/lib/framework/boundary-components.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 2646, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/framework/boundary-components.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/medical/node_modules/next/dist/esm/lib/framework/boundary-components.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 2653, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2661, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/metadata/metadata.js"],"sourcesContent":["import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport React, { Suspense, cache, cloneElement } from 'react';\nimport { AppleWebAppMeta, FormatDetectionMeta, ItunesMeta, BasicMeta, ViewportMeta, VerificationMeta, FacebookMeta, PinterestMeta } from './generate/basic';\nimport { AlternatesMetadata } from './generate/alternate';\nimport { OpenGraphMetadata, TwitterMetadata, AppLinksMeta } from './generate/opengraph';\nimport { IconsMetadata } from './generate/icons';\nimport { resolveMetadata, resolveViewport } from './resolve-metadata';\nimport { MetaFilter } from './generate/meta';\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback';\nimport { createServerSearchParamsForMetadata } from '../../server/request/search-params';\nimport { createServerPathnameForMetadata } from '../../server/request/pathname';\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone';\nimport { MetadataBoundary, ViewportBoundary, OutletBoundary } from '../framework/boundary-components';\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({ tree, pathname, parsedQuery, metadataContext, getDynamicParamFromSegment, errorType, workStore, serveStreamingMetadata }) {\n    const searchParams = createServerSearchParamsForMetadata(parsedQuery, workStore);\n    const pathnameForMetadata = createServerPathnameForMetadata(pathname, workStore);\n    function Viewport() {\n        const pendingViewportTags = getResolvedViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorType).catch((viewportErr)=>{\n            // When Legacy PPR is enabled viewport can reject with a Postpone type\n            // This will go away once Legacy PPR is removed and dynamic metadata will\n            // stay pending until after the prerender is complete when it is dynamic\n            if (isPostpone(viewportErr)) {\n                throw viewportErr;\n            }\n            if (!errorType && isHTTPAccessFallbackError(viewportErr)) {\n                return getNotFoundViewport(tree, searchParams, getDynamicParamFromSegment, workStore).catch(()=>null);\n            }\n            // We're going to throw the error from the metadata outlet so we just render null here instead\n            return null;\n        });\n        return /*#__PURE__*/ _jsx(ViewportBoundary, {\n            children: pendingViewportTags\n        });\n    }\n    Viewport.displayName = 'Next.Viewport';\n    function Metadata() {\n        const pendingMetadataTags = getResolvedMetadata(tree, pathnameForMetadata, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorType).catch((metadataErr)=>{\n            // When Legacy PPR is enabled metadata can reject with a Postpone type\n            // This will go away once Legacy PPR is removed and dynamic metadata will\n            // stay pending until after the prerender is complete when it is dynamic\n            if (isPostpone(metadataErr)) {\n                throw metadataErr;\n            }\n            if (!errorType && isHTTPAccessFallbackError(metadataErr)) {\n                return getNotFoundMetadata(tree, pathnameForMetadata, searchParams, getDynamicParamFromSegment, metadataContext, workStore).catch(()=>null);\n            }\n            // We're going to throw the error from the metadata outlet so we just render null here instead\n            return null;\n        });\n        // TODO: We shouldn't change what we render based on whether we are streaming or not.\n        // If we aren't streaming we should just block the response until we have resolved the\n        // metadata.\n        if (!serveStreamingMetadata) {\n            return /*#__PURE__*/ _jsx(MetadataBoundary, {\n                children: pendingMetadataTags\n            });\n        }\n        return /*#__PURE__*/ _jsx(\"div\", {\n            hidden: true,\n            children: /*#__PURE__*/ _jsx(MetadataBoundary, {\n                children: /*#__PURE__*/ _jsx(Suspense, {\n                    name: \"Next.Metadata\",\n                    children: pendingMetadataTags\n                })\n            })\n        });\n    }\n    Metadata.displayName = 'Next.Metadata';\n    function MetadataOutlet() {\n        const pendingOutlet = Promise.all([\n            getResolvedMetadata(tree, pathnameForMetadata, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorType),\n            getResolvedViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorType)\n        ]).then(()=>null);\n        // TODO: We shouldn't change what we render based on whether we are streaming or not.\n        // If we aren't streaming we should just block the response until we have resolved the\n        // metadata.\n        if (!serveStreamingMetadata) {\n            return /*#__PURE__*/ _jsx(OutletBoundary, {\n                children: pendingOutlet\n            });\n        }\n        return /*#__PURE__*/ _jsx(OutletBoundary, {\n            children: /*#__PURE__*/ _jsx(Suspense, {\n                name: \"Next.MetadataOutlet\",\n                children: pendingOutlet\n            })\n        });\n    }\n    MetadataOutlet.displayName = 'Next.MetadataOutlet';\n    return {\n        Viewport,\n        Metadata,\n        MetadataOutlet\n    };\n}\nconst getResolvedMetadata = cache(getResolvedMetadataImpl);\nasync function getResolvedMetadataImpl(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorType) {\n    const errorConvention = errorType === 'redirect' ? undefined : errorType;\n    return renderMetadata(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorConvention);\n}\nconst getNotFoundMetadata = cache(getNotFoundMetadataImpl);\nasync function getNotFoundMetadataImpl(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore) {\n    const notFoundErrorConvention = 'not-found';\n    return renderMetadata(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, notFoundErrorConvention);\n}\nconst getResolvedViewport = cache(getResolvedViewportImpl);\nasync function getResolvedViewportImpl(tree, searchParams, getDynamicParamFromSegment, workStore, errorType) {\n    const errorConvention = errorType === 'redirect' ? undefined : errorType;\n    return renderViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorConvention);\n}\nconst getNotFoundViewport = cache(getNotFoundViewportImpl);\nasync function getNotFoundViewportImpl(tree, searchParams, getDynamicParamFromSegment, workStore) {\n    const notFoundErrorConvention = 'not-found';\n    return renderViewport(tree, searchParams, getDynamicParamFromSegment, workStore, notFoundErrorConvention);\n}\nasync function renderMetadata(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorConvention) {\n    const resolvedMetadata = await resolveMetadata(tree, pathname, searchParams, errorConvention, getDynamicParamFromSegment, workStore, metadataContext);\n    const elements = createMetadataElements(resolvedMetadata);\n    return /*#__PURE__*/ _jsx(_Fragment, {\n        children: elements.map((el, index)=>{\n            return /*#__PURE__*/ cloneElement(el, {\n                key: index\n            });\n        })\n    });\n}\nasync function renderViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorConvention) {\n    const resolvedViewport = await resolveViewport(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore);\n    const elements = createViewportElements(resolvedViewport);\n    return /*#__PURE__*/ _jsx(_Fragment, {\n        children: elements.map((el, index)=>{\n            return /*#__PURE__*/ cloneElement(el, {\n                key: index\n            });\n        })\n    });\n}\nfunction createMetadataElements(metadata) {\n    return MetaFilter([\n        BasicMeta({\n            metadata\n        }),\n        AlternatesMetadata({\n            alternates: metadata.alternates\n        }),\n        ItunesMeta({\n            itunes: metadata.itunes\n        }),\n        FacebookMeta({\n            facebook: metadata.facebook\n        }),\n        PinterestMeta({\n            pinterest: metadata.pinterest\n        }),\n        FormatDetectionMeta({\n            formatDetection: metadata.formatDetection\n        }),\n        VerificationMeta({\n            verification: metadata.verification\n        }),\n        AppleWebAppMeta({\n            appleWebApp: metadata.appleWebApp\n        }),\n        OpenGraphMetadata({\n            openGraph: metadata.openGraph\n        }),\n        TwitterMetadata({\n            twitter: metadata.twitter\n        }),\n        AppLinksMeta({\n            appLinks: metadata.appLinks\n        }),\n        IconsMetadata({\n            icons: metadata.icons\n        })\n    ]);\n}\nfunction createViewportElements(viewport) {\n    return MetaFilter([\n        ViewportMeta({\n            viewport: viewport\n        })\n    ]);\n}\n\n//# sourceMappingURL=metadata.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2874, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-dom.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactDOM\n"],"names":["module","exports","require","vendored","ReactDOM"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,oIACRC,QAAQ,CAAC,YAAY,CAAEC,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 2879, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/app-render/rsc/preloads.js"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/ import ReactDOM from 'react-dom';\nexport function preloadStyle(href, crossOrigin, nonce) {\n    const opts = {\n        as: 'style'\n    };\n    if (typeof crossOrigin === 'string') {\n        opts.crossOrigin = crossOrigin;\n    }\n    if (typeof nonce === 'string') {\n        opts.nonce = nonce;\n    }\n    ReactDOM.preload(href, opts);\n}\nexport function preloadFont(href, type, crossOrigin, nonce) {\n    const opts = {\n        as: 'font',\n        type\n    };\n    if (typeof crossOrigin === 'string') {\n        opts.crossOrigin = crossOrigin;\n    }\n    if (typeof nonce === 'string') {\n        opts.nonce = nonce;\n    }\n    ReactDOM.preload(href, opts);\n}\nexport function preconnect(href, crossOrigin, nonce) {\n    const opts = {};\n    if (typeof crossOrigin === 'string') {\n        opts.crossOrigin = crossOrigin;\n    }\n    if (typeof nonce === 'string') {\n        opts.nonce = nonce;\n    }\n    ;\n    ReactDOM.preconnect(href, opts);\n}\n\n//# sourceMappingURL=preloads.js.map"],"names":[],"mappings":"AAAA;;;;AAIA;;;;;;;;AAAG;;AACI,SAAS,aAAa,IAAI,EAAE,WAAW,EAAE,KAAK;IACjD,MAAM,OAAO;QACT,IAAI;IACR;IACA,IAAI,OAAO,gBAAgB,UAAU;QACjC,KAAK,WAAW,GAAG;IACvB;IACA,IAAI,OAAO,UAAU,UAAU;QAC3B,KAAK,KAAK,GAAG;IACjB;IACA,kOAAQ,CAAC,OAAO,CAAC,MAAM;AAC3B;AACO,SAAS,YAAY,IAAI,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK;IACtD,MAAM,OAAO;QACT,IAAI;QACJ;IACJ;IACA,IAAI,OAAO,gBAAgB,UAAU;QACjC,KAAK,WAAW,GAAG;IACvB;IACA,IAAI,OAAO,UAAU,UAAU;QAC3B,KAAK,KAAK,GAAG;IACjB;IACA,kOAAQ,CAAC,OAAO,CAAC,MAAM;AAC3B;AACO,SAAS,WAAW,IAAI,EAAE,WAAW,EAAE,KAAK;IAC/C,MAAM,OAAO,CAAC;IACd,IAAI,OAAO,gBAAgB,UAAU;QACjC,KAAK,WAAW,GAAG;IACvB;IACA,IAAI,OAAO,UAAU,UAAU;QAC3B,KAAK,KAAK,GAAG;IACjB;;IAEA,kOAAQ,CAAC,UAAU,CAAC,MAAM;AAC9B,EAEA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 2933, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/app-render/rsc/postpone.js"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/ // When postpone is available in canary React we can switch to importing it directly\nexport { Postpone } from '../dynamic-rendering';\n\n//# sourceMappingURL=postpone.js.map"],"names":[],"mappings":"AAAA;;;;AAIA,GAAG,oFAAoF;;AACvF,kWAEA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 2945, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/compiled/react-server-dom-turbopack/client.node.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.node.production.js');\n} else {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.node.development.js');\n}\n"],"names":[],"mappings":"AAEA;;KAEO;IACL,OAAO,OAAO;;;;;AAChB","ignoreList":[0]}},
    {"offset": {"line": 2958, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/lib/trace/constants.js"],"sourcesContent":["/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/ // eslint typescript has a bug with TS enums\nvar BaseServerSpan = /*#__PURE__*/ function(BaseServerSpan) {\n    BaseServerSpan[\"handleRequest\"] = \"BaseServer.handleRequest\";\n    BaseServerSpan[\"run\"] = \"BaseServer.run\";\n    BaseServerSpan[\"pipe\"] = \"BaseServer.pipe\";\n    BaseServerSpan[\"getStaticHTML\"] = \"BaseServer.getStaticHTML\";\n    BaseServerSpan[\"render\"] = \"BaseServer.render\";\n    BaseServerSpan[\"renderToResponseWithComponents\"] = \"BaseServer.renderToResponseWithComponents\";\n    BaseServerSpan[\"renderToResponse\"] = \"BaseServer.renderToResponse\";\n    BaseServerSpan[\"renderToHTML\"] = \"BaseServer.renderToHTML\";\n    BaseServerSpan[\"renderError\"] = \"BaseServer.renderError\";\n    BaseServerSpan[\"renderErrorToResponse\"] = \"BaseServer.renderErrorToResponse\";\n    BaseServerSpan[\"renderErrorToHTML\"] = \"BaseServer.renderErrorToHTML\";\n    BaseServerSpan[\"render404\"] = \"BaseServer.render404\";\n    return BaseServerSpan;\n}(BaseServerSpan || {});\nvar LoadComponentsSpan = /*#__PURE__*/ function(LoadComponentsSpan) {\n    LoadComponentsSpan[\"loadDefaultErrorComponents\"] = \"LoadComponents.loadDefaultErrorComponents\";\n    LoadComponentsSpan[\"loadComponents\"] = \"LoadComponents.loadComponents\";\n    return LoadComponentsSpan;\n}(LoadComponentsSpan || {});\nvar NextServerSpan = /*#__PURE__*/ function(NextServerSpan) {\n    NextServerSpan[\"getRequestHandler\"] = \"NextServer.getRequestHandler\";\n    NextServerSpan[\"getRequestHandlerWithMetadata\"] = \"NextServer.getRequestHandlerWithMetadata\";\n    NextServerSpan[\"getServer\"] = \"NextServer.getServer\";\n    NextServerSpan[\"getServerRequestHandler\"] = \"NextServer.getServerRequestHandler\";\n    NextServerSpan[\"createServer\"] = \"createServer.createServer\";\n    return NextServerSpan;\n}(NextServerSpan || {});\nvar NextNodeServerSpan = /*#__PURE__*/ function(NextNodeServerSpan) {\n    NextNodeServerSpan[\"compression\"] = \"NextNodeServer.compression\";\n    NextNodeServerSpan[\"getBuildId\"] = \"NextNodeServer.getBuildId\";\n    NextNodeServerSpan[\"createComponentTree\"] = \"NextNodeServer.createComponentTree\";\n    NextNodeServerSpan[\"clientComponentLoading\"] = \"NextNodeServer.clientComponentLoading\";\n    NextNodeServerSpan[\"getLayoutOrPageModule\"] = \"NextNodeServer.getLayoutOrPageModule\";\n    NextNodeServerSpan[\"generateStaticRoutes\"] = \"NextNodeServer.generateStaticRoutes\";\n    NextNodeServerSpan[\"generateFsStaticRoutes\"] = \"NextNodeServer.generateFsStaticRoutes\";\n    NextNodeServerSpan[\"generatePublicRoutes\"] = \"NextNodeServer.generatePublicRoutes\";\n    NextNodeServerSpan[\"generateImageRoutes\"] = \"NextNodeServer.generateImageRoutes.route\";\n    NextNodeServerSpan[\"sendRenderResult\"] = \"NextNodeServer.sendRenderResult\";\n    NextNodeServerSpan[\"proxyRequest\"] = \"NextNodeServer.proxyRequest\";\n    NextNodeServerSpan[\"runApi\"] = \"NextNodeServer.runApi\";\n    NextNodeServerSpan[\"render\"] = \"NextNodeServer.render\";\n    NextNodeServerSpan[\"renderHTML\"] = \"NextNodeServer.renderHTML\";\n    NextNodeServerSpan[\"imageOptimizer\"] = \"NextNodeServer.imageOptimizer\";\n    NextNodeServerSpan[\"getPagePath\"] = \"NextNodeServer.getPagePath\";\n    NextNodeServerSpan[\"getRoutesManifest\"] = \"NextNodeServer.getRoutesManifest\";\n    NextNodeServerSpan[\"findPageComponents\"] = \"NextNodeServer.findPageComponents\";\n    NextNodeServerSpan[\"getFontManifest\"] = \"NextNodeServer.getFontManifest\";\n    NextNodeServerSpan[\"getServerComponentManifest\"] = \"NextNodeServer.getServerComponentManifest\";\n    NextNodeServerSpan[\"getRequestHandler\"] = \"NextNodeServer.getRequestHandler\";\n    NextNodeServerSpan[\"renderToHTML\"] = \"NextNodeServer.renderToHTML\";\n    NextNodeServerSpan[\"renderError\"] = \"NextNodeServer.renderError\";\n    NextNodeServerSpan[\"renderErrorToHTML\"] = \"NextNodeServer.renderErrorToHTML\";\n    NextNodeServerSpan[\"render404\"] = \"NextNodeServer.render404\";\n    NextNodeServerSpan[\"startResponse\"] = \"NextNodeServer.startResponse\";\n    // nested inner span, does not require parent scope name\n    NextNodeServerSpan[\"route\"] = \"route\";\n    NextNodeServerSpan[\"onProxyReq\"] = \"onProxyReq\";\n    NextNodeServerSpan[\"apiResolver\"] = \"apiResolver\";\n    NextNodeServerSpan[\"internalFetch\"] = \"internalFetch\";\n    return NextNodeServerSpan;\n}(NextNodeServerSpan || {});\nvar StartServerSpan = /*#__PURE__*/ function(StartServerSpan) {\n    StartServerSpan[\"startServer\"] = \"startServer.startServer\";\n    return StartServerSpan;\n}(StartServerSpan || {});\nvar RenderSpan = /*#__PURE__*/ function(RenderSpan) {\n    RenderSpan[\"getServerSideProps\"] = \"Render.getServerSideProps\";\n    RenderSpan[\"getStaticProps\"] = \"Render.getStaticProps\";\n    RenderSpan[\"renderToString\"] = \"Render.renderToString\";\n    RenderSpan[\"renderDocument\"] = \"Render.renderDocument\";\n    RenderSpan[\"createBodyResult\"] = \"Render.createBodyResult\";\n    return RenderSpan;\n}(RenderSpan || {});\nvar AppRenderSpan = /*#__PURE__*/ function(AppRenderSpan) {\n    AppRenderSpan[\"renderToString\"] = \"AppRender.renderToString\";\n    AppRenderSpan[\"renderToReadableStream\"] = \"AppRender.renderToReadableStream\";\n    AppRenderSpan[\"getBodyResult\"] = \"AppRender.getBodyResult\";\n    AppRenderSpan[\"fetch\"] = \"AppRender.fetch\";\n    return AppRenderSpan;\n}(AppRenderSpan || {});\nvar RouterSpan = /*#__PURE__*/ function(RouterSpan) {\n    RouterSpan[\"executeRoute\"] = \"Router.executeRoute\";\n    return RouterSpan;\n}(RouterSpan || {});\nvar NodeSpan = /*#__PURE__*/ function(NodeSpan) {\n    NodeSpan[\"runHandler\"] = \"Node.runHandler\";\n    return NodeSpan;\n}(NodeSpan || {});\nvar AppRouteRouteHandlersSpan = /*#__PURE__*/ function(AppRouteRouteHandlersSpan) {\n    AppRouteRouteHandlersSpan[\"runHandler\"] = \"AppRouteRouteHandlers.runHandler\";\n    return AppRouteRouteHandlersSpan;\n}(AppRouteRouteHandlersSpan || {});\nvar ResolveMetadataSpan = /*#__PURE__*/ function(ResolveMetadataSpan) {\n    ResolveMetadataSpan[\"generateMetadata\"] = \"ResolveMetadata.generateMetadata\";\n    ResolveMetadataSpan[\"generateViewport\"] = \"ResolveMetadata.generateViewport\";\n    return ResolveMetadataSpan;\n}(ResolveMetadataSpan || {});\nvar MiddlewareSpan = /*#__PURE__*/ function(MiddlewareSpan) {\n    MiddlewareSpan[\"execute\"] = \"Middleware.execute\";\n    return MiddlewareSpan;\n}(MiddlewareSpan || {});\n// This list is used to filter out spans that are not relevant to the user\nexport const NextVanillaSpanAllowlist = new Set([\n    \"Middleware.execute\",\n    \"BaseServer.handleRequest\",\n    \"Render.getServerSideProps\",\n    \"Render.getStaticProps\",\n    \"AppRender.fetch\",\n    \"AppRender.getBodyResult\",\n    \"Render.renderDocument\",\n    \"Node.runHandler\",\n    \"AppRouteRouteHandlers.runHandler\",\n    \"ResolveMetadata.generateMetadata\",\n    \"ResolveMetadata.generateViewport\",\n    \"NextNodeServer.createComponentTree\",\n    \"NextNodeServer.findPageComponents\",\n    \"NextNodeServer.getLayoutOrPageModule\",\n    \"NextNodeServer.startResponse\",\n    \"NextNodeServer.clientComponentLoading\"\n]);\n// These Spans are allowed to be always logged\n// when the otel log prefix env is set\nexport const LogSpanAllowList = new Set([\n    \"NextNodeServer.findPageComponents\",\n    \"NextNodeServer.createComponentTree\",\n    \"NextNodeServer.clientComponentLoading\"\n]);\nexport { BaseServerSpan, LoadComponentsSpan, NextServerSpan, NextNodeServerSpan, StartServerSpan, RenderSpan, RouterSpan, AppRenderSpan, NodeSpan, AppRouteRouteHandlersSpan, ResolveMetadataSpan, MiddlewareSpan,  };\n\n//# sourceMappingURL=constants.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3125, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/detached-promise.js"],"sourcesContent":["/**\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\n * `reject` functions on a `Promise`.\n *\n * @see https://tc39.es/proposal-promise-with-resolvers/\n */ export class DetachedPromise {\n    constructor(){\n        let resolve;\n        let reject;\n        // Create the promise and assign the resolvers to the object.\n        this.promise = new Promise((res, rej)=>{\n            resolve = res;\n            reject = rej;\n        });\n        // We know that resolvers is defined because the Promise constructor runs\n        // synchronously.\n        this.resolve = resolve;\n        this.reject = reject;\n    }\n}\n\n//# sourceMappingURL=detached-promise.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAAU,MAAM;IACb,aAAa;QACT,IAAI;QACJ,IAAI;QACJ,6DAA6D;QAC7D,IAAI,CAAC,OAAO,GAAG,IAAI,QAAQ,CAAC,KAAK;YAC7B,UAAU;YACV,SAAS;QACb;QACA,yEAAyE;QACzE,iBAAiB;QACjB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,MAAM,GAAG;IAClB;AACJ,EAEA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 3153, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/stream-utils/encoded-tags.js"],"sourcesContent":["export const ENCODED_TAGS = {\n    // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n    OPENING: {\n        // <html\n        HTML: new Uint8Array([\n            60,\n            104,\n            116,\n            109,\n            108\n        ]),\n        // <body\n        BODY: new Uint8Array([\n            60,\n            98,\n            111,\n            100,\n            121\n        ])\n    },\n    CLOSED: {\n        // </head>\n        HEAD: new Uint8Array([\n            60,\n            47,\n            104,\n            101,\n            97,\n            100,\n            62\n        ]),\n        // </body>\n        BODY: new Uint8Array([\n            60,\n            47,\n            98,\n            111,\n            100,\n            121,\n            62\n        ]),\n        // </html>\n        HTML: new Uint8Array([\n            60,\n            47,\n            104,\n            116,\n            109,\n            108,\n            62\n        ]),\n        // </body></html>\n        BODY_AND_HTML: new Uint8Array([\n            60,\n            47,\n            98,\n            111,\n            100,\n            121,\n            62,\n            60,\n            47,\n            104,\n            116,\n            109,\n            108,\n            62\n        ])\n    },\n    META: {\n        // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n        // <meta name=\"nxt-icon\"\n        // This is a special mark that will be replaced by the icon insertion script tag.\n        ICON_MARK: new Uint8Array([\n            60,\n            109,\n            101,\n            116,\n            97,\n            32,\n            110,\n            97,\n            109,\n            101,\n            61,\n            34,\n            194,\n            171,\n            110,\n            120,\n            116,\n            45,\n            105,\n            99,\n            111,\n            110,\n            194,\n            187,\n            34\n        ])\n    }\n};\n\n//# sourceMappingURL=encoded-tags.js.map"],"names":[],"mappings":";;;;AAAO,MAAM,eAAe;IACxB,iHAAiH;IACjH,SAAS;QACL,QAAQ;QACR,MAAM,IAAI,WAAW;YACjB;YACA;YACA;YACA;YACA;SACH;QACD,QAAQ;QACR,MAAM,IAAI,WAAW;YACjB;YACA;YACA;YACA;YACA;SACH;IACL;IACA,QAAQ;QACJ,UAAU;QACV,MAAM,IAAI,WAAW;YACjB;YACA;YACA;YACA;YACA;YACA;YACA;SACH;QACD,UAAU;QACV,MAAM,IAAI,WAAW;YACjB;YACA;YACA;YACA;YACA;YACA;YACA;SACH;QACD,UAAU;QACV,MAAM,IAAI,WAAW;YACjB;YACA;YACA;YACA;YACA;YACA;YACA;SACH;QACD,iBAAiB;QACjB,eAAe,IAAI,WAAW;YAC1B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACH;IACL;IACA,MAAM;QACF,4GAA4G;QAC5G,0BAA0B;QAC1B,iFAAiF;QACjF,WAAW,IAAI,WAAW;YACtB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACH;IACL;AACJ,GAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 3263, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/errors/constants.js"],"sourcesContent":["export const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';\n\n//# sourceMappingURL=constants.js.map"],"names":[],"mappings":";;;;AAAO,MAAM,0BAA0B,0BAEvC,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 3272, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/segment-cache/output-export-prefetch-encoding.js"],"sourcesContent":["// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\n;\nconst MAX_BUILD_ID_LENGTH = 24;\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63';\nfunction escapeBuildId(buildId) {\n    // If the build id is longer than the given limit, it's OK for our purposes\n    // to only match the beginning.\n    const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH);\n    // Replace hyphens with underscores so it doesn't break the HTML comment.\n    // (Unlikely, but if this did happen it would break the whole document.)\n    return truncated.replace(/-/g, '_');\n}\nexport function insertBuildIdComment(originalHtml, buildId) {\n    if (// Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') || // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)) {\n        // Return the original HTML unchanged. This means the document will not\n        // be prefetched.\n        // TODO: The build id comment is currently only used during prefetches, but\n        // if we eventually use this mechanism for regular navigations, we may need\n        // to error during build if we fail to insert it for some reason.\n        return originalHtml;\n    }\n    // The comment must be inserted after the doctype.\n    return originalHtml.replace(DOCTYPE_PREFIX, DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');\n}\nexport function doesExportedHtmlMatchBuildId(partialHtmlDocument, buildId) {\n    // Check whether the document starts with the expected buildId.\n    return partialHtmlDocument.startsWith(DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');\n}\n\n//# sourceMappingURL=output-export-prefetch-encoding.js.map"],"names":[],"mappings":"AAAA,yEAAyE;AACzE,2EAA2E;AAC3E,+EAA+E;AAC/E,6CAA6C;AAC7C,EAAE;AACF,2EAA2E;AAC3E,6EAA6E;AAC7E,sEAAsE;AACtE,mBAAmB;AACnB,EAAE;AACF,yEAAyE;AACzE,2EAA2E;AAC3E,6EAA6E;AAC7E,oBAAoB;;;;;;;;;AACpB,MAAM,iBAAiB,kBAAkB,WAAW;;AAEpD,MAAM,sBAAsB;AAErB,MAAM,kCAAkC;AAC/C,SAAS,cAAc,OAAO;IAC1B,2EAA2E;IAC3E,+BAA+B;IAC/B,MAAM,YAAY,QAAQ,KAAK,CAAC,GAAG;IACnC,yEAAyE;IACzE,wEAAwE;IACxE,OAAO,UAAU,OAAO,CAAC,MAAM;AACnC;AACO,SAAS,qBAAqB,YAAY,EAAE,OAAO;IACtD,IACA,QAAQ,QAAQ,CAAC,UAAU,0EAA0E;IACrG,gEAAgE;IAChE,CAAC,aAAa,UAAU,CAAC,iBAAiB;QACtC,uEAAuE;QACvE,iBAAiB;QACjB,2EAA2E;QAC3E,2EAA2E;QAC3E,iEAAiE;QACjE,OAAO;IACX;IACA,kDAAkD;IAClD,OAAO,aAAa,OAAO,CAAC,gBAAgB,iBAAiB,SAAS,cAAc,WAAW;AACnG;AACO,SAAS,6BAA6B,mBAAmB,EAAE,OAAO;IACrE,+DAA+D;IAC/D,OAAO,oBAAoB,UAAU,CAAC,iBAAiB,SAAS,cAAc,WAAW;AAC7F,EAEA,2DAA2D","ignoreList":[0]}},
    {"offset": {"line": 3328, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/app-router-headers.js"],"sourcesContent":["export const RSC_HEADER = 'rsc';\nexport const ACTION_HEADER = 'next-action';\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\nexport const NEXT_URL = 'next-url';\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component';\nexport const FLIGHT_HEADERS = [\n    RSC_HEADER,\n    NEXT_ROUTER_STATE_TREE_HEADER,\n    NEXT_ROUTER_PREFETCH_HEADER,\n    NEXT_HMR_REFRESH_HEADER,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n];\nexport const NEXT_RSC_UNION_QUERY = '_rsc';\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id';\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id';\n\n//# sourceMappingURL=app-router-headers.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,aAAa;AACnB,MAAM,gBAAgB;AAItB,MAAM,gCAAgC;AACtC,MAAM,8BAA8B;AAKpC,MAAM,sCAAsC;AAC5C,MAAM,0BAA0B;AAChC,MAAM,+BAA+B;AACrC,MAAM,WAAW;AACjB,MAAM,0BAA0B;AAChC,MAAM,iBAAiB;IAC1B;IACA;IACA;IACA;IACA;CACH;AACM,MAAM,uBAAuB;AAC7B,MAAM,gCAAgC;AACtC,MAAM,2BAA2B;AACjC,MAAM,6BAA6B;AACnC,MAAM,8BAA8B;AACpC,MAAM,2BAA2B;AACjC,MAAM,+BAA+B;AACrC,MAAM,yBAAyB;AAC/B,MAAM,8BAA8B,4BAE3C,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 3397, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/hash.js"],"sourcesContent":["// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str) {\n    let hash = 5381;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) + hash + char & 0xffffffff;\n    }\n    return hash >>> 0;\n}\nexport function hexHash(str) {\n    return djb2Hash(str).toString(36).slice(0, 5);\n}\n\n//# sourceMappingURL=hash.js.map"],"names":[],"mappings":"AAAA,wCAAwC;AACxC,4CAA4C;AAC5C,iHAAiH;AACjH,wFAAwF;AACxF,gGAAgG;AAChG,wHAAwH;AACxH,wDAAwD;;;;;;;AACjD,SAAS,SAAS,GAAG;IACxB,IAAI,OAAO;IACX,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAI;QAC/B,MAAM,OAAO,IAAI,UAAU,CAAC;QAC5B,OAAO,CAAC,QAAQ,CAAC,IAAI,OAAO,OAAO;IACvC;IACA,OAAO,SAAS;AACpB;AACO,SAAS,QAAQ,GAAG;IACvB,OAAO,SAAS,KAAK,QAAQ,CAAC,IAAI,KAAK,CAAC,GAAG;AAC/C,EAEA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 3425, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/router/utils/cache-busting-search-param.js"],"sourcesContent":["import { hexHash } from '../../hash';\nexport function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {\n    if ((prefetchHeader === undefined || prefetchHeader === '0') && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {\n        return '';\n    }\n    return hexHash([\n        prefetchHeader || '0',\n        segmentPrefetchHeader || '0',\n        stateTreeHeader || '0',\n        nextUrlHeader || '0'\n    ].join(','));\n}\n\n//# sourceMappingURL=cache-busting-search-param.js.map"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,+BAA+B,cAAc,EAAE,qBAAqB,EAAE,eAAe,EAAE,aAAa;IAChH,IAAI,CAAC,mBAAmB,aAAa,mBAAmB,GAAG,KAAK,0BAA0B,aAAa,oBAAoB,aAAa,kBAAkB,WAAW;QACjK,OAAO;IACX;IACA,OAAO,IAAA,6LAAO,EAAC;QACX,kBAAkB;QAClB,yBAAyB;QACzB,mBAAmB;QACnB,iBAAiB;KACpB,CAAC,IAAI,CAAC;AACX,EAEA,sDAAsD","ignoreList":[0]}},
    {"offset": {"line": 3446, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js"],"sourcesContent":["import { getTracer } from '../lib/trace/tracer';\nimport { AppRenderSpan } from '../lib/trace/constants';\nimport { DetachedPromise } from '../../lib/detached-promise';\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler';\nimport { ENCODED_TAGS } from './encoded-tags';\nimport { indexOfUint8Array, isEquivalentUint8Arrays, removeFromUint8Array } from './uint8array-helpers';\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants';\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding';\nimport { RSC_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_RSC_UNION_QUERY } from '../../client/components/app-router-headers';\nimport { computeCacheBustingSearchParam } from '../../shared/lib/router/utils/cache-busting-search-param';\nfunction voidCatch() {\n// this catcher is designed to be used with pipeTo where we expect the underlying\n// pipe implementation to forward errors but we don't want the pipeTo promise to reject\n// and be unhandled\n}\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder();\nexport function chainStreams(...streams) {\n    // If we have no streams, return an empty stream. This behavior is\n    // intentional as we're now providing the `RenderResult.EMPTY` value.\n    if (streams.length === 0) {\n        return new ReadableStream({\n            start (controller) {\n                controller.close();\n            }\n        });\n    }\n    // If we only have 1 stream we fast path it by returning just this stream\n    if (streams.length === 1) {\n        return streams[0];\n    }\n    const { readable, writable } = new TransformStream();\n    // We always initiate pipeTo immediately. We know we have at least 2 streams\n    // so we need to avoid closing the writable when this one finishes.\n    let promise = streams[0].pipeTo(writable, {\n        preventClose: true\n    });\n    let i = 1;\n    for(; i < streams.length - 1; i++){\n        const nextStream = streams[i];\n        promise = promise.then(()=>nextStream.pipeTo(writable, {\n                preventClose: true\n            }));\n    }\n    // We can omit the length check because we halted before the last stream and there\n    // is at least two streams so the lastStream here will always be defined\n    const lastStream = streams[i];\n    promise = promise.then(()=>lastStream.pipeTo(writable));\n    // Catch any errors from the streams and ignore them, they will be handled\n    // by whatever is consuming the readable stream.\n    promise.catch(voidCatch);\n    return readable;\n}\nexport function streamFromString(str) {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(encoder.encode(str));\n            controller.close();\n        }\n    });\n}\nexport function streamFromBuffer(chunk) {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(chunk);\n            controller.close();\n        }\n    });\n}\nexport async function streamToBuffer(stream) {\n    const reader = stream.getReader();\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n    }\n    return Buffer.concat(chunks);\n}\nexport async function streamToString(stream, signal) {\n    const decoder = new TextDecoder('utf-8', {\n        fatal: true\n    });\n    let string = '';\n    for await (const chunk of stream){\n        if (signal == null ? void 0 : signal.aborted) {\n            return string;\n        }\n        string += decoder.decode(chunk, {\n            stream: true\n        });\n    }\n    string += decoder.decode();\n    return string;\n}\nexport function createBufferedTransformStream(options = {}) {\n    const { maxBufferByteLength = Infinity } = options;\n    let bufferedChunks = [];\n    let bufferByteLength = 0;\n    let pending;\n    const flush = (controller)=>{\n        try {\n            if (bufferedChunks.length === 0) {\n                return;\n            }\n            const chunk = new Uint8Array(bufferByteLength);\n            let copiedBytes = 0;\n            for(let i = 0; i < bufferedChunks.length; i++){\n                const bufferedChunk = bufferedChunks[i];\n                chunk.set(bufferedChunk, copiedBytes);\n                copiedBytes += bufferedChunk.byteLength;\n            }\n            // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n            // and our bufferByteLength to prepare for the next round of buffered chunks\n            bufferedChunks.length = 0;\n            bufferByteLength = 0;\n            controller.enqueue(chunk);\n        } catch  {\n        // If an error occurs while enqueuing, it can't be due to this\n        // transformer. It's most likely caused by the controller having been\n        // errored (for example, if the stream was cancelled).\n        }\n    };\n    const scheduleFlush = (controller)=>{\n        if (pending) {\n            return;\n        }\n        const detached = new DetachedPromise();\n        pending = detached;\n        scheduleImmediate(()=>{\n            try {\n                flush(controller);\n            } finally{\n                pending = undefined;\n                detached.resolve();\n            }\n        });\n    };\n    return new TransformStream({\n        transform (chunk, controller) {\n            // Combine the previous buffer with the new chunk.\n            bufferedChunks.push(chunk);\n            bufferByteLength += chunk.byteLength;\n            if (bufferByteLength >= maxBufferByteLength) {\n                flush(controller);\n            } else {\n                scheduleFlush(controller);\n            }\n        },\n        flush () {\n            return pending == null ? void 0 : pending.promise;\n        }\n    });\n}\nfunction createPrefetchCommentStream(isBuildTimePrerendering, buildId) {\n    // Insert an extra comment at the beginning of the HTML document. This must\n    // come after the DOCTYPE, which is inserted by React.\n    //\n    // The first chunk sent by React will contain the doctype. After that, we can\n    // pass through the rest of the chunks as-is.\n    let didTransformFirstChunk = false;\n    return new TransformStream({\n        transform (chunk, controller) {\n            if (isBuildTimePrerendering && !didTransformFirstChunk) {\n                didTransformFirstChunk = true;\n                const decoder = new TextDecoder('utf-8', {\n                    fatal: true\n                });\n                const chunkStr = decoder.decode(chunk, {\n                    stream: true\n                });\n                const updatedChunkStr = insertBuildIdComment(chunkStr, buildId);\n                controller.enqueue(encoder.encode(updatedChunkStr));\n                return;\n            }\n            controller.enqueue(chunk);\n        }\n    });\n}\nexport function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {\n    return getTracer().trace(AppRenderSpan.renderToReadableStream, async ()=>ReactDOMServer.renderToReadableStream(element, streamOptions));\n}\nfunction createMetadataTransformStream(insert) {\n    let chunkIndex = -1;\n    let isMarkRemoved = false;\n    return new TransformStream({\n        async transform (chunk, controller) {\n            let iconMarkIndex = -1;\n            let closedHeadIndex = -1;\n            chunkIndex++;\n            if (isMarkRemoved) {\n                controller.enqueue(chunk);\n                return;\n            }\n            let iconMarkLength = 0;\n            // Only search for the closed head tag once\n            if (iconMarkIndex === -1) {\n                iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK);\n                if (iconMarkIndex === -1) {\n                    controller.enqueue(chunk);\n                    return;\n                } else {\n                    // When we found the `<meta name=\"nxt-icon\"` tag prefix, we will remove it from the chunk.\n                    // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n                    iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length;\n                    // Check if next char is /, this is for xml mode.\n                    if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n                        iconMarkLength += 2;\n                    } else {\n                        // The last char is `>`\n                        iconMarkLength++;\n                    }\n                }\n            }\n            // Check if icon mark is inside <head> tag in the first chunk.\n            if (chunkIndex === 0) {\n                closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD);\n                if (iconMarkIndex !== -1) {\n                    // The mark icon is located in the 1st chunk before the head tag.\n                    // We do not need to insert the script tag in this case because it's in the head.\n                    // Just remove the icon mark from the chunk.\n                    if (iconMarkIndex < closedHeadIndex) {\n                        const replaced = new Uint8Array(chunk.length - iconMarkLength);\n                        // Remove the icon mark from the chunk.\n                        replaced.set(chunk.subarray(0, iconMarkIndex));\n                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex);\n                        chunk = replaced;\n                    } else {\n                        // The icon mark is after the head tag, replace and insert the script tag at that position.\n                        const insertion = await insert();\n                        const encodedInsertion = encoder.encode(insertion);\n                        const insertionLength = encodedInsertion.length;\n                        const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);\n                        replaced.set(chunk.subarray(0, iconMarkIndex));\n                        replaced.set(encodedInsertion, iconMarkIndex);\n                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);\n                        chunk = replaced;\n                    }\n                    isMarkRemoved = true;\n                }\n            // If there's no icon mark located, it will be handled later when if present in the following chunks.\n            } else {\n                // When it's appeared in the following chunks, we'll need to\n                // remove the mark and then insert the script tag at that position.\n                const insertion = await insert();\n                const encodedInsertion = encoder.encode(insertion);\n                const insertionLength = encodedInsertion.length;\n                // Replace the icon mark with the hoist script or empty string.\n                const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);\n                // Set the first part of the chunk, before the icon mark.\n                replaced.set(chunk.subarray(0, iconMarkIndex));\n                // Set the insertion after the icon mark.\n                replaced.set(encodedInsertion, iconMarkIndex);\n                // Set the rest of the chunk after the icon mark.\n                replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);\n                chunk = replaced;\n                isMarkRemoved = true;\n            }\n            controller.enqueue(chunk);\n        }\n    });\n}\nfunction createHeadInsertionTransformStream(insert) {\n    let inserted = false;\n    // We need to track if this transform saw any bytes because if it didn't\n    // we won't want to insert any server HTML at all\n    let hasBytes = false;\n    return new TransformStream({\n        async transform (chunk, controller) {\n            hasBytes = true;\n            const insertion = await insert();\n            if (inserted) {\n                if (insertion) {\n                    const encodedInsertion = encoder.encode(insertion);\n                    controller.enqueue(encodedInsertion);\n                }\n                controller.enqueue(chunk);\n            } else {\n                // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n                const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD);\n                // In fully static rendering or non PPR rendering cases:\n                // `/head>` will always be found in the chunk in first chunk rendering.\n                if (index !== -1) {\n                    if (insertion) {\n                        const encodedInsertion = encoder.encode(insertion);\n                        // Get the total count of the bytes in the chunk and the insertion\n                        // e.g.\n                        // chunk = <head><meta charset=\"utf-8\"></head>\n                        // insertion = <script>...</script>\n                        // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n                        const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);\n                        // Append the first part of the chunk, before the head tag\n                        insertedHeadContent.set(chunk.slice(0, index));\n                        // Append the server inserted content\n                        insertedHeadContent.set(encodedInsertion, index);\n                        // Append the rest of the chunk\n                        insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);\n                        controller.enqueue(insertedHeadContent);\n                    } else {\n                        controller.enqueue(chunk);\n                    }\n                    inserted = true;\n                } else {\n                    // This will happens in PPR rendering during next start, when the page is partially rendered.\n                    // When the page resumes, the head tag will be found in the middle of the chunk.\n                    // Where we just need to append the insertion and chunk to the current stream.\n                    // e.g.\n                    // PPR-static: <head>...</head><body> [ resume content ] </body>\n                    // PPR-resume: [ insertion ] [ rest content ]\n                    if (insertion) {\n                        controller.enqueue(encoder.encode(insertion));\n                    }\n                    controller.enqueue(chunk);\n                    inserted = true;\n                }\n            }\n        },\n        async flush (controller) {\n            // Check before closing if there's anything remaining to insert.\n            if (hasBytes) {\n                const insertion = await insert();\n                if (insertion) {\n                    controller.enqueue(encoder.encode(insertion));\n                }\n            }\n        }\n    });\n}\nfunction createClientResumeScriptInsertionTransformStream() {\n    const segmentPath = '/_full';\n    const cacheBustingHeader = computeCacheBustingSearchParam('1', '/_full', undefined, undefined //       headers[NEXT_URL]\n    );\n    const searchStr = `${NEXT_RSC_UNION_QUERY}=${cacheBustingHeader}`;\n    const NEXT_CLIENT_RESUME_SCRIPT = `<script>__NEXT_CLIENT_RESUME=fetch(location.pathname+'?${searchStr}',{credentials:'same-origin',headers:{'${RSC_HEADER}': '1','${NEXT_ROUTER_PREFETCH_HEADER}': '1','${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}': '${segmentPath}'}})</script>`;\n    let didAlreadyInsert = false;\n    return new TransformStream({\n        transform (chunk, controller) {\n            if (didAlreadyInsert) {\n                // Already inserted the script into the head. Pass through.\n                controller.enqueue(chunk);\n                return;\n            }\n            // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n            const headClosingTagIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD);\n            if (headClosingTagIndex === -1) {\n                // In fully static rendering or non PPR rendering cases:\n                // `/head>` will always be found in the chunk in first chunk rendering.\n                controller.enqueue(chunk);\n                return;\n            }\n            const encodedInsertion = encoder.encode(NEXT_CLIENT_RESUME_SCRIPT);\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, headClosingTagIndex));\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, headClosingTagIndex);\n            // Append the rest of the chunk\n            insertedHeadContent.set(chunk.slice(headClosingTagIndex), headClosingTagIndex + encodedInsertion.length);\n            controller.enqueue(insertedHeadContent);\n            didAlreadyInsert = true;\n        }\n    });\n}\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(suffix) {\n    let flushed = false;\n    let pending;\n    const flush = (controller)=>{\n        const detached = new DetachedPromise();\n        pending = detached;\n        scheduleImmediate(()=>{\n            try {\n                controller.enqueue(encoder.encode(suffix));\n            } catch  {\n            // If an error occurs while enqueuing it can't be due to this\n            // transformers fault. It's likely due to the controller being\n            // errored due to the stream being cancelled.\n            } finally{\n                pending = undefined;\n                detached.resolve();\n            }\n        });\n    };\n    return new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(chunk);\n            // If we've already flushed, we're done.\n            if (flushed) return;\n            // Schedule the flush to happen.\n            flushed = true;\n            flush(controller);\n        },\n        flush (controller) {\n            if (pending) return pending.promise;\n            if (flushed) return;\n            // Flush now.\n            controller.enqueue(encoder.encode(suffix));\n        }\n    });\n}\nfunction createFlightDataInjectionTransformStream(stream, delayDataUntilFirstHtmlChunk) {\n    let htmlStreamFinished = false;\n    let pull = null;\n    let donePulling = false;\n    function startOrContinuePulling(controller) {\n        if (!pull) {\n            pull = startPulling(controller);\n        }\n        return pull;\n    }\n    async function startPulling(controller) {\n        const reader = stream.getReader();\n        if (delayDataUntilFirstHtmlChunk) {\n            // NOTE: streaming flush\n            // We are buffering here for the inlined data stream because the\n            // \"shell\" stream might be chunkenized again by the underlying stream\n            // implementation, e.g. with a specific high-water mark. To ensure it's\n            // the safe timing to pipe the data stream, this extra tick is\n            // necessary.\n            // We don't start reading until we've left the current Task to ensure\n            // that it's inserted after flushing the shell. Note that this implementation\n            // might get stale if impl details of Fizz change in the future.\n            await atLeastOneTask();\n        }\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    donePulling = true;\n                    return;\n                }\n                // We want to prioritize HTML over RSC data.\n                // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n                // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n                if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n                    await atLeastOneTask();\n                }\n                controller.enqueue(value);\n            }\n        } catch (err) {\n            controller.error(err);\n        }\n    }\n    return new TransformStream({\n        start (controller) {\n            if (!delayDataUntilFirstHtmlChunk) {\n                startOrContinuePulling(controller);\n            }\n        },\n        transform (chunk, controller) {\n            controller.enqueue(chunk);\n            // Start the streaming if it hasn't already been started yet.\n            if (delayDataUntilFirstHtmlChunk) {\n                startOrContinuePulling(controller);\n            }\n        },\n        flush (controller) {\n            htmlStreamFinished = true;\n            if (donePulling) {\n                return;\n            }\n            return startOrContinuePulling(controller);\n        }\n    });\n}\nconst CLOSE_TAG = '</body></html>';\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */ function createMoveSuffixStream() {\n    let foundSuffix = false;\n    return new TransformStream({\n        transform (chunk, controller) {\n            if (foundSuffix) {\n                return controller.enqueue(chunk);\n            }\n            const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n            if (index > -1) {\n                foundSuffix = true;\n                // If the whole chunk is the suffix, then don't write anything, it will\n                // be written in the flush.\n                if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n                    return;\n                }\n                // Write out the part before the suffix.\n                const before = chunk.slice(0, index);\n                controller.enqueue(before);\n                // In the case where the suffix is in the middle of the chunk, we need\n                // to split the chunk into two parts.\n                if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n                    // Write out the part after the suffix.\n                    const after = chunk.slice(index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length);\n                    controller.enqueue(after);\n                }\n            } else {\n                controller.enqueue(chunk);\n            }\n        },\n        flush (controller) {\n            // Even if we didn't find the suffix, the HTML is not valid if we don't\n            // add it, so insert it at the end.\n            controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n        }\n    });\n}\nfunction createStripDocumentClosingTagsTransform() {\n    return new TransformStream({\n        transform (chunk, controller) {\n            // We rely on the assumption that chunks will never break across a code unit.\n            // This is reasonable because we currently concat all of React's output from a single\n            // flush into one chunk before streaming it forward which means the chunk will represent\n            // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n            // longer do this large buffered chunk\n            if (isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) || isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) || isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)) {\n                // the entire chunk is the closing tags; return without enqueueing anything.\n                return;\n            }\n            // We assume these tags will go at together at the end of the document and that\n            // they won't appear anywhere else in the document. This is not really a safe assumption\n            // but until we revamp our streaming infra this is a performant way to string the tags\n            chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY);\n            chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML);\n            controller.enqueue(chunk);\n        }\n    });\n}\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */ export function createRootLayoutValidatorStream() {\n    let foundHtml = false;\n    let foundBody = false;\n    return new TransformStream({\n        async transform (chunk, controller) {\n            // Peek into the streamed chunk to see if the tags are present.\n            if (!foundHtml && indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1) {\n                foundHtml = true;\n            }\n            if (!foundBody && indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1) {\n                foundBody = true;\n            }\n            controller.enqueue(chunk);\n        },\n        flush (controller) {\n            const missingTags = [];\n            if (!foundHtml) missingTags.push('html');\n            if (!foundBody) missingTags.push('body');\n            if (!missingTags.length) return;\n            controller.enqueue(encoder.encode(`<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags.map((c)=>`<${c}>`).join(missingTags.length > 1 ? ' and ' : '')} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `));\n        }\n    });\n}\nfunction chainTransformers(readable, transformers) {\n    let stream = readable;\n    for (const transformer of transformers){\n        if (!transformer) continue;\n        stream = stream.pipeThrough(transformer);\n    }\n    return stream;\n}\nexport async function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, isBuildTimePrerendering, buildId, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {\n    // Suffix itself might contain close tags at the end, so we need to split it.\n    const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;\n    // If we're generating static HTML we need to wait for it to resolve before continuing.\n    if (isStaticGeneration) {\n        await renderStream.allReady;\n    }\n    return chainTransformers(renderStream, [\n        // Buffer everything to avoid flushing too frequently\n        createBufferedTransformStream(),\n        // Add build id comment to start of the HTML document (in export mode)\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n        // Transform metadata\n        createMetadataTransformStream(getServerInsertedMetadata),\n        // Insert suffix content\n        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,\n        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n        inlinedDataStream ? createFlightDataInjectionTransformStream(inlinedDataStream, true) : null,\n        // Validate the root layout for missing html or body tags\n        validateRootLayout ? createRootLayoutValidatorStream() : null,\n        // Close tags should always be deferred to the end\n        createMoveSuffixStream(),\n        // Special head insertions\n        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n        // hydration errors. Remove this once it's ready to be handled by react itself.\n        createHeadInsertionTransformStream(getServerInsertedHTML)\n    ]);\n}\nexport async function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {\n    return prerenderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform())// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Transform metadata\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata));\n}\nexport async function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {\n    return prerenderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream())// Add build id comment to start of the HTML document (in export mode)\n    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId))// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Transform metadata\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, true))// Close tags should always be deferred to the end\n    .pipeThrough(createMoveSuffixStream());\n}\nexport async function continueStaticFallbackPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {\n    // Same as `continueStaticPrerender`, but also inserts an additional script\n    // to instruct the client to start fetching the hydration data as early\n    // as possible.\n    return prerenderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream())// Add build id comment to start of the HTML document (in export mode)\n    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId))// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Insert the client resume script into the head\n    .pipeThrough(createClientResumeScriptInsertionTransformStream())// Transform metadata\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, true))// Close tags should always be deferred to the end\n    .pipeThrough(createMoveSuffixStream());\n}\nexport async function continueDynamicHTMLResume(renderStream, { delayDataUntilFirstHtmlChunk, inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {\n    return renderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream())// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Transform metadata\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, delayDataUntilFirstHtmlChunk))// Close tags should always be deferred to the end\n    .pipeThrough(createMoveSuffixStream());\n}\nexport function createDocumentClosingStream() {\n    return streamFromString(CLOSE_TAG);\n}\n\n//# sourceMappingURL=node-web-streams-helper.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4142, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/compiled/string-hash/index.js"],"sourcesContent":["(()=>{\"use strict\";var e={328:e=>{function hash(e){var r=5381,_=e.length;while(_){r=r*33^e.charCodeAt(--_)}return r>>>0}e.exports=hash}};var r={};function __nccwpck_require__(_){var a=r[_];if(a!==undefined){return a.exports}var t=r[_]={exports:{}};var i=true;try{e[_](t,t.exports,__nccwpck_require__);i=false}finally{if(i)delete r[_]}return t.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var _=__nccwpck_require__(328);module.exports=_})();"],"names":[],"mappings":"AAAA,CAAC;IAAK;IAAa,IAAI,IAAE;QAAC,KAAI,CAAA;YAAI,SAAS,KAAK,CAAC;gBAAE,IAAI,IAAE,MAAK,IAAE,EAAE,MAAM;gBAAC,MAAM,EAAE;oBAAC,IAAE,IAAE,KAAG,EAAE,UAAU,CAAC,EAAE;gBAAE;gBAAC,OAAO,MAAI;YAAC;YAAC,EAAE,OAAO,GAAC;QAAI;IAAC;IAAE,IAAI,IAAE,CAAC;IAAE,SAAS,oBAAoB,CAAC;QAAE,IAAI,IAAE,CAAC,CAAC,EAAE;QAAC,IAAG,MAAI,WAAU;YAAC,OAAO,EAAE,OAAO;QAAA;QAAC,IAAI,IAAE,CAAC,CAAC,EAAE,GAAC;YAAC,SAAQ,CAAC;QAAC;QAAE,IAAI,IAAE;QAAK,IAAG;YAAC,CAAC,CAAC,EAAE,CAAC,GAAE,EAAE,OAAO,EAAC;YAAqB,IAAE;QAAK,SAAQ;YAAC,IAAG,GAAE,OAAO,CAAC,CAAC,EAAE;QAAA;QAAC,OAAO,EAAE,OAAO;IAAA;IAAC,IAAG,OAAO,wBAAsB,aAAY,oBAAoB,EAAE,GAAC,wGAAU;IAAI,IAAI,IAAE,oBAAoB;IAAK,OAAO,OAAO,GAAC;AAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4182, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/format-server-error.js"],"sourcesContent":["const invalidServerComponentReactHooks = [\n    'useDeferredValue',\n    'useEffect',\n    'useImperativeHandle',\n    'useInsertionEffect',\n    'useLayoutEffect',\n    'useReducer',\n    'useRef',\n    'useState',\n    'useSyncExternalStore',\n    'useTransition',\n    'experimental_useOptimistic',\n    'useOptimistic'\n];\nfunction setMessage(error, message) {\n    error.message = message;\n    if (error.stack) {\n        const lines = error.stack.split('\\n');\n        lines[0] = message;\n        error.stack = lines.join('\\n');\n    }\n}\n/**\n * Input:\n * Error: Something went wrong\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10)\n \n * Output:\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10) \n */ export function getStackWithoutErrorMessage(error) {\n    const stack = error.stack;\n    if (!stack) return '';\n    return stack.replace(/^[^\\n]*\\n/, '');\n}\nexport function formatServerError(error) {\n    if (typeof (error == null ? void 0 : error.message) !== 'string') return;\n    if (error.message.includes('Class extends value undefined is not a constructor or null')) {\n        const addedMessage = 'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component';\n        // If this error instance already has the message, don't add it again\n        if (error.message.includes(addedMessage)) return;\n        setMessage(error, `${error.message}\n\n${addedMessage}`);\n        return;\n    }\n    if (error.message.includes('createContext is not a function')) {\n        setMessage(error, 'createContext only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');\n        return;\n    }\n    for (const clientHook of invalidServerComponentReactHooks){\n        const regex = new RegExp(`\\\\b${clientHook}\\\\b.*is not a function`);\n        if (regex.test(error.message)) {\n            setMessage(error, `${clientHook} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);\n            return;\n        }\n    }\n}\n\n//# sourceMappingURL=format-server-error.js.map"],"names":[],"mappings":";;;;;;AAAA,MAAM,mCAAmC;IACrC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACD,SAAS,WAAW,KAAK,EAAE,OAAO;IAC9B,MAAM,OAAO,GAAG;IAChB,IAAI,MAAM,KAAK,EAAE;QACb,MAAM,QAAQ,MAAM,KAAK,CAAC,KAAK,CAAC;QAChC,KAAK,CAAC,EAAE,GAAG;QACX,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC;IAC7B;AACJ;AAUW,SAAS,4BAA4B,KAAK;IACjD,MAAM,QAAQ,MAAM,KAAK;IACzB,IAAI,CAAC,OAAO,OAAO;IACnB,OAAO,MAAM,OAAO,CAAC,aAAa;AACtC;AACO,SAAS,kBAAkB,KAAK;IACnC,IAAI,OAAO,CAAC,SAAS,OAAO,KAAK,IAAI,MAAM,OAAO,MAAM,UAAU;IAClE,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,+DAA+D;QACtF,MAAM,eAAe;QACrB,qEAAqE;QACrE,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,eAAe;QAC1C,WAAW,OAAO,GAAG,MAAM,OAAO,CAAC;;AAE3C,EAAE,cAAc;QACR;IACJ;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,oCAAoC;QAC3D,WAAW,OAAO;QAClB;IACJ;IACA,KAAK,MAAM,cAAc,iCAAiC;QACtD,MAAM,QAAQ,IAAI,OAAO,CAAC,GAAG,EAAE,WAAW,sBAAsB,CAAC;QACjE,IAAI,MAAM,IAAI,CAAC,MAAM,OAAO,GAAG;YAC3B,WAAW,OAAO,GAAG,WAAW,oLAAoL,CAAC;YACrN;QACJ;IACJ;AACJ,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 4242, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/base-http/helpers.js"],"sourcesContent":["/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */ /**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */ export const isWebNextRequest = (req)=>process.env.NEXT_RUNTIME === 'edge';\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */ export const isWebNextResponse = (res)=>process.env.NEXT_RUNTIME === 'edge';\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */ export const isNodeNextRequest = (req)=>process.env.NEXT_RUNTIME !== 'edge';\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */ export const isNodeNextResponse = (res)=>process.env.NEXT_RUNTIME !== 'edge';\n\n//# sourceMappingURL=helpers.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC,GAAG;;;;;CAKH;;;;;;;;;;AAAU,MAAM,mBAAmB,CAAC,MAAM,+CAA6B;AAM7D,MAAM,oBAAoB,CAAC,MAAM,+CAA6B;AAM9D,MAAM,oBAAoB,CAAC,MAAM,+CAA6B;AAM9D,MAAM,qBAAqB,CAAC,MAAM,+CAA6B,QAE1E,mCAAmC","ignoreList":[0]}},
    {"offset": {"line": 4270, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/web/spec-extension/adapters/next-request.js"],"sourcesContent":["import { getRequestMeta } from '../../../request-meta';\nimport { fromNodeOutgoingHttpHeaders } from '../../utils';\nimport { NextRequest } from '../request';\nimport { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers';\nexport const ResponseAbortedName = 'ResponseAborted';\nexport class ResponseAborted extends Error {\n    constructor(...args){\n        super(...args), this.name = ResponseAbortedName;\n    }\n}\n/**\n * Creates an AbortController tied to the closing of a ServerResponse (or other\n * appropriate Writable).\n *\n * If the `close` event is fired before the `finish` event, then we'll send the\n * `abort` signal.\n */ export function createAbortController(response) {\n    const controller = new AbortController();\n    // If `finish` fires first, then `res.end()` has been called and the close is\n    // just us finishing the stream on our side. If `close` fires first, then we\n    // know the client disconnected before we finished.\n    response.once('close', ()=>{\n        if (response.writableFinished) return;\n        controller.abort(new ResponseAborted());\n    });\n    return controller;\n}\n/**\n * Creates an AbortSignal tied to the closing of a ServerResponse (or other\n * appropriate Writable).\n *\n * This cannot be done with the request (IncomingMessage or Readable) because\n * the `abort` event will not fire if to data has been fully read (because that\n * will \"close\" the readable stream and nothing fires after that).\n */ export function signalFromNodeResponse(response) {\n    const { errored, destroyed } = response;\n    if (errored || destroyed) {\n        return AbortSignal.abort(errored ?? new ResponseAborted());\n    }\n    const { signal } = createAbortController(response);\n    return signal;\n}\nexport class NextRequestAdapter {\n    static fromBaseNextRequest(request, signal) {\n        if (// The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME === 'edge' && isWebNextRequest(request)) {\n            return NextRequestAdapter.fromWebNextRequest(request);\n        } else if (// The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' && isNodeNextRequest(request)) {\n            return NextRequestAdapter.fromNodeNextRequest(request, signal);\n        } else {\n            throw Object.defineProperty(new Error('Invariant: Unsupported NextRequest type'), \"__NEXT_ERROR_CODE\", {\n                value: \"E345\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    static fromNodeNextRequest(request, signal) {\n        // HEAD and GET requests can not have a body.\n        let body = null;\n        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {\n            // @ts-expect-error - this is handled by undici, when streams/web land use it instead\n            body = request.body;\n        }\n        let url;\n        if (request.url.startsWith('http')) {\n            url = new URL(request.url);\n        } else {\n            // Grab the full URL from the request metadata.\n            const base = getRequestMeta(request, 'initURL');\n            if (!base || !base.startsWith('http')) {\n                // Because the URL construction relies on the fact that the URL provided\n                // is absolute, we need to provide a base URL. We can't use the request\n                // URL because it's relative, so we use a dummy URL instead.\n                url = new URL(request.url, 'http://n');\n            } else {\n                url = new URL(request.url, base);\n            }\n        }\n        return new NextRequest(url, {\n            method: request.method,\n            headers: fromNodeOutgoingHttpHeaders(request.headers),\n            duplex: 'half',\n            signal,\n            // geo\n            // ip\n            // nextConfig\n            // body can not be passed if request was aborted\n            // or we get a Request body was disturbed error\n            ...signal.aborted ? {} : {\n                body\n            }\n        });\n    }\n    static fromWebNextRequest(request) {\n        // HEAD and GET requests can not have a body.\n        let body = null;\n        if (request.method !== 'GET' && request.method !== 'HEAD') {\n            body = request.body;\n        }\n        return new NextRequest(request.url, {\n            method: request.method,\n            headers: fromNodeOutgoingHttpHeaders(request.headers),\n            duplex: 'half',\n            signal: request.request.signal,\n            // geo\n            // ip\n            // nextConfig\n            // body can not be passed if request was aborted\n            // or we get a Request body was disturbed error\n            ...request.request.signal.aborted ? {} : {\n                body\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=next-request.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;AACO,MAAM,sBAAsB;AAC5B,MAAM,wBAAwB;IACjC,YAAY,GAAG,IAAI,CAAC;QAChB,KAAK,IAAI,OAAO,IAAI,CAAC,IAAI,GAAG;IAChC;AACJ;AAOW,SAAS,sBAAsB,QAAQ;IAC9C,MAAM,aAAa,IAAI;IACvB,6EAA6E;IAC7E,4EAA4E;IAC5E,mDAAmD;IACnD,SAAS,IAAI,CAAC,SAAS;QACnB,IAAI,SAAS,gBAAgB,EAAE;QAC/B,WAAW,KAAK,CAAC,IAAI;IACzB;IACA,OAAO;AACX;AAQW,SAAS,uBAAuB,QAAQ;IAC/C,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;IAC/B,IAAI,WAAW,WAAW;QACtB,OAAO,YAAY,KAAK,CAAC,WAAW,IAAI;IAC5C;IACA,MAAM,EAAE,MAAM,EAAE,GAAG,sBAAsB;IACzC,OAAO;AACX;AACO,MAAM;IACT,OAAO,oBAAoB,OAAO,EAAE,MAAM,EAAE;QACxC,IACA,6DAA6D;QAC7D,+CAA6B,UAAU,IAAA,kNAAgB,EAAC;;aAEjD,IACP,6DAA6D;QAC7D,+CAA6B,UAAU,IAAA,mNAAiB,EAAC,UAAU;YAC/D,OAAO,mBAAmB,mBAAmB,CAAC,SAAS;QAC3D,OAAO;YACH,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,4CAA4C,qBAAqB;gBACnG,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;IACJ;IACA,OAAO,oBAAoB,OAAO,EAAE,MAAM,EAAE;QACxC,6CAA6C;QAC7C,IAAI,OAAO;QACX,IAAI,QAAQ,MAAM,KAAK,SAAS,QAAQ,MAAM,KAAK,UAAU,QAAQ,IAAI,EAAE;YACvE,qFAAqF;YACrF,OAAO,QAAQ,IAAI;QACvB;QACA,IAAI;QACJ,IAAI,QAAQ,GAAG,CAAC,UAAU,CAAC,SAAS;YAChC,MAAM,IAAI,IAAI,QAAQ,GAAG;QAC7B,OAAO;YACH,+CAA+C;YAC/C,MAAM,OAAO,eAAe,SAAS;YACrC,IAAI,CAAC,QAAQ,CAAC,KAAK,UAAU,CAAC,SAAS;gBACnC,wEAAwE;gBACxE,uEAAuE;gBACvE,4DAA4D;gBAC5D,MAAM,IAAI,IAAI,QAAQ,GAAG,EAAE;YAC/B,OAAO;gBACH,MAAM,IAAI,IAAI,QAAQ,GAAG,EAAE;YAC/B;QACJ;QACA,OAAO,IAAI,YAAY,KAAK;YACxB,QAAQ,QAAQ,MAAM;YACtB,SAAS,4BAA4B,QAAQ,OAAO;YACpD,QAAQ;YACR;YACA,MAAM;YACN,KAAK;YACL,aAAa;YACb,gDAAgD;YAChD,+CAA+C;YAC/C,GAAG,OAAO,OAAO,GAAG,CAAC,IAAI;gBACrB;YACJ,CAAC;QACL;IACJ;IACA,OAAO,mBAAmB,OAAO,EAAE;QAC/B,6CAA6C;QAC7C,IAAI,OAAO;QACX,IAAI,QAAQ,MAAM,KAAK,SAAS,QAAQ,MAAM,KAAK,QAAQ;YACvD,OAAO,QAAQ,IAAI;QACvB;QACA,OAAO,IAAI,YAAY,QAAQ,GAAG,EAAE;YAChC,QAAQ,QAAQ,MAAM;YACtB,SAAS,4BAA4B,QAAQ,OAAO;YACpD,QAAQ;YACR,QAAQ,QAAQ,OAAO,CAAC,MAAM;YAC9B,MAAM;YACN,KAAK;YACL,aAAa;YACb,gDAAgD;YAChD,+CAA+C;YAC/C,GAAG,QAAQ,OAAO,CAAC,MAAM,CAAC,OAAO,GAAG,CAAC,IAAI;gBACrC;YACJ,CAAC;QACL;IACJ;AACJ,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 4406, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/client-component-renderer-logger.js"],"sourcesContent":["// Combined load times for loading client components\nlet clientComponentLoadStart = 0;\nlet clientComponentLoadTimes = 0;\nlet clientComponentLoadCount = 0;\nexport function wrapClientComponentLoader(ComponentMod) {\n    if (!('performance' in globalThis)) {\n        return ComponentMod.__next_app__;\n    }\n    return {\n        require: (...args)=>{\n            const startTime = performance.now();\n            if (clientComponentLoadStart === 0) {\n                clientComponentLoadStart = startTime;\n            }\n            try {\n                clientComponentLoadCount += 1;\n                return ComponentMod.__next_app__.require(...args);\n            } finally{\n                clientComponentLoadTimes += performance.now() - startTime;\n            }\n        },\n        loadChunk: (...args)=>{\n            const startTime = performance.now();\n            const result = ComponentMod.__next_app__.loadChunk(...args);\n            // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n            // We only need to know when it's settled.\n            result.finally(()=>{\n                clientComponentLoadTimes += performance.now() - startTime;\n            });\n            return result;\n        }\n    };\n}\nexport function getClientComponentLoaderMetrics(options = {}) {\n    const metrics = clientComponentLoadStart === 0 ? undefined : {\n        clientComponentLoadStart,\n        clientComponentLoadTimes,\n        clientComponentLoadCount\n    };\n    if (options.reset) {\n        clientComponentLoadStart = 0;\n        clientComponentLoadTimes = 0;\n        clientComponentLoadCount = 0;\n    }\n    return metrics;\n}\n\n//# sourceMappingURL=client-component-renderer-logger.js.map"],"names":[],"mappings":"AAAA,oDAAoD;;;;;;;AACpD,IAAI,2BAA2B;AAC/B,IAAI,2BAA2B;AAC/B,IAAI,2BAA2B;AACxB,SAAS,0BAA0B,YAAY;IAClD,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;QAChC,OAAO,aAAa,YAAY;IACpC;IACA,OAAO;QACH,SAAS,CAAC,GAAG;YACT,MAAM,YAAY,YAAY,GAAG;YACjC,IAAI,6BAA6B,GAAG;gBAChC,2BAA2B;YAC/B;YACA,IAAI;gBACA,4BAA4B;gBAC5B,OAAO,aAAa,YAAY,CAAC,OAAO,IAAI;YAChD,SAAS;gBACL,4BAA4B,YAAY,GAAG,KAAK;YACpD;QACJ;QACA,WAAW,CAAC,GAAG;YACX,MAAM,YAAY,YAAY,GAAG;YACjC,MAAM,SAAS,aAAa,YAAY,CAAC,SAAS,IAAI;YACtD,gHAAgH;YAChH,0CAA0C;YAC1C,OAAO,OAAO,CAAC;gBACX,4BAA4B,YAAY,GAAG,KAAK;YACpD;YACA,OAAO;QACX;IACJ;AACJ;AACO,SAAS,gCAAgC,UAAU,CAAC,CAAC;IACxD,MAAM,UAAU,6BAA6B,IAAI,YAAY;QACzD;QACA;QACA;IACJ;IACA,IAAI,QAAQ,KAAK,EAAE;QACf,2BAA2B;QAC3B,2BAA2B;QAC3B,2BAA2B;IAC/B;IACA,OAAO;AACX,EAEA,4DAA4D","ignoreList":[0]}},
    {"offset": {"line": 4462, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/pipe-readable.js"],"sourcesContent":["import { ResponseAbortedName, createAbortController } from './web/spec-extension/adapters/next-request';\nimport { DetachedPromise } from '../lib/detached-promise';\nimport { getTracer } from './lib/trace/tracer';\nimport { NextNodeServerSpan } from './lib/trace/constants';\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger';\nexport function isAbortError(e) {\n    return (e == null ? void 0 : e.name) === 'AbortError' || (e == null ? void 0 : e.name) === ResponseAbortedName;\n}\nfunction createWriterFromResponse(res, waitUntilForEnd) {\n    let started = false;\n    // Create a promise that will resolve once the response has drained. See\n    // https://nodejs.org/api/stream.html#stream_event_drain\n    let drained = new DetachedPromise();\n    function onDrain() {\n        drained.resolve();\n    }\n    res.on('drain', onDrain);\n    // If the finish event fires, it means we shouldn't block and wait for the\n    // drain event.\n    res.once('close', ()=>{\n        res.off('drain', onDrain);\n        drained.resolve();\n    });\n    // Create a promise that will resolve once the response has finished. See\n    // https://nodejs.org/api/http.html#event-finish_1\n    const finished = new DetachedPromise();\n    res.once('finish', ()=>{\n        finished.resolve();\n    });\n    // Create a writable stream that will write to the response.\n    return new WritableStream({\n        write: async (chunk)=>{\n            // You'd think we'd want to use `start` instead of placing this in `write`\n            // but this ensures that we don't actually flush the headers until we've\n            // started writing chunks.\n            if (!started) {\n                started = true;\n                if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {\n                    const metrics = getClientComponentLoaderMetrics();\n                    if (metrics) {\n                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {\n                            start: metrics.clientComponentLoadStart,\n                            end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes\n                        });\n                    }\n                }\n                res.flushHeaders();\n                getTracer().trace(NextNodeServerSpan.startResponse, {\n                    spanName: 'start response'\n                }, ()=>undefined);\n            }\n            try {\n                const ok = res.write(chunk);\n                // Added by the `compression` middleware, this is a function that will\n                // flush the partially-compressed response to the client.\n                if ('flush' in res && typeof res.flush === 'function') {\n                    res.flush();\n                }\n                // If the write returns false, it means there's some backpressure, so\n                // wait until it's streamed before continuing.\n                if (!ok) {\n                    await drained.promise;\n                    // Reset the drained promise so that we can wait for the next drain event.\n                    drained = new DetachedPromise();\n                }\n            } catch (err) {\n                res.end();\n                throw Object.defineProperty(new Error('failed to write chunk to response', {\n                    cause: err\n                }), \"__NEXT_ERROR_CODE\", {\n                    value: \"E321\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        },\n        abort: (err)=>{\n            if (res.writableFinished) return;\n            res.destroy(err);\n        },\n        close: async ()=>{\n            // if a waitUntil promise was passed, wait for it to resolve before\n            // ending the response.\n            if (waitUntilForEnd) {\n                await waitUntilForEnd;\n            }\n            if (res.writableFinished) return;\n            res.end();\n            return finished.promise;\n        }\n    });\n}\nexport async function pipeToNodeResponse(readable, res, waitUntilForEnd) {\n    try {\n        // If the response has already errored, then just return now.\n        const { errored, destroyed } = res;\n        if (errored || destroyed) return;\n        // Create a new AbortController so that we can abort the readable if the\n        // client disconnects.\n        const controller = createAbortController(res);\n        const writer = createWriterFromResponse(res, waitUntilForEnd);\n        await readable.pipeTo(writer, {\n            signal: controller.signal\n        });\n    } catch (err) {\n        // If this isn't related to an abort error, re-throw it.\n        if (isAbortError(err)) return;\n        throw Object.defineProperty(new Error('failed to pipe response', {\n            cause: err\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E180\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n\n//# sourceMappingURL=pipe-readable.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4597, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/client/components/is-next-router-error.js"],"sourcesContent":["import { isHTTPAccessFallbackError } from './http-access-fallback/http-access-fallback';\nimport { isRedirectError } from './redirect-error';\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */ export function isNextRouterError(error) {\n    return isRedirectError(error) || isHTTPAccessFallbackError(error);\n}\n\n//# sourceMappingURL=is-next-router-error.js.map"],"names":[],"mappings":";;;;AAAA;;;;;;;;AAMW,SAAS,kBAAkB,KAAK;IACvC,OAAO,gBAAgB,UAAU,IAAA,0QAAyB,EAAC;AAC/D,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 4616, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/shared/lib/is-plain-object.js"],"sourcesContent":["export function getObjectClassLabel(value) {\n    return Object.prototype.toString.call(value);\n}\nexport function isPlainObject(value) {\n    if (getObjectClassLabel(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');\n}\n\n//# sourceMappingURL=is-plain-object.js.map"],"names":[],"mappings":";;;;;;AAAO,SAAS,oBAAoB,KAAK;IACrC,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;AAC1C;AACO,SAAS,cAAc,KAAK;IAC/B,IAAI,oBAAoB,WAAW,mBAAmB;QAClD,OAAO;IACX;IACA,MAAM,YAAY,OAAO,cAAc,CAAC;IACxC;;;;;;;;GAQD,GAAG,OAAO,cAAc,QAAQ,UAAU,cAAc,CAAC;AAC5D,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 4644, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/is-error.js"],"sourcesContent":["import { isPlainObject } from '../shared/lib/is-plain-object';\n/**\n * This is a safe stringify function that handles circular references.\n * We're using a simpler version here to avoid introducing\n * the dependency `safe-stable-stringify` into production bundle.\n *\n * This helper is used both in development and production.\n */ function safeStringifyLite(obj) {\n    const seen = new WeakSet();\n    return JSON.stringify(obj, (_key, value)=>{\n        // If value is an object and already seen, replace with \"[Circular]\"\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n                return '[Circular]';\n            }\n            seen.add(value);\n        }\n        return value;\n    });\n}\n/**\n * Checks whether the given value is a NextError.\n * This can be used to print a more detailed error message with properties like `code` & `digest`.\n */ export default function isError(err) {\n    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;\n}\nexport function getProperError(err) {\n    if (isError(err)) {\n        return err;\n    }\n    if (process.env.NODE_ENV === 'development') {\n        // provide better error for case where `throw undefined`\n        // is called in development\n        if (typeof err === 'undefined') {\n            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), \"__NEXT_ERROR_CODE\", {\n                value: \"E98\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (err === null) {\n            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), \"__NEXT_ERROR_CODE\", {\n                value: \"E336\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    return Object.defineProperty(new Error(isPlainObject(err) ? safeStringifyLite(err) : err + ''), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=is-error.js.map"],"names":[],"mappings":";;;;;;AAAA;;AACA;;;;;;CAMC,GAAG,SAAS,kBAAkB,GAAG;IAC9B,MAAM,OAAO,IAAI;IACjB,OAAO,KAAK,SAAS,CAAC,KAAK,CAAC,MAAM;QAC9B,oEAAoE;QACpE,IAAI,OAAO,UAAU,YAAY,UAAU,MAAM;YAC7C,IAAI,KAAK,GAAG,CAAC,QAAQ;gBACjB,OAAO;YACX;YACA,KAAK,GAAG,CAAC;QACb;QACA,OAAO;IACX;AACJ;AAImB,SAAS,QAAQ,GAAG;IACnC,OAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,UAAU,OAAO,aAAa;AACpF;AACO,SAAS,eAAe,GAAG;IAC9B,IAAI,QAAQ,MAAM;QACd,OAAO;IACX;IACA,wCAA4C;QACxC,wDAAwD;QACxD,2BAA2B;QAC3B,IAAI,OAAO,QAAQ,aAAa;YAC5B,OAAO,OAAO,cAAc,CAAC,IAAI,MAAM,oCAAoC,6EAA6E,qBAAqB;gBACzK,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;QACA,IAAI,QAAQ,MAAM;YACd,OAAO,OAAO,cAAc,CAAC,IAAI,MAAM,8BAA8B,6EAA6E,qBAAqB;gBACnK,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;IACJ;IACA,OAAO,OAAO,cAAc,CAAC,IAAI,MAAM,IAAA,oNAAa,EAAC,OAAO,kBAAkB,OAAO,MAAM,KAAK,qBAAqB;QACjH,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;AACJ,EAEA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 4706, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/error-telemetry-utils.js"],"sourcesContent":["const ERROR_CODE_DELIMITER = '@';\n/**\n * Augments the digest field of errors thrown in React Server Components (RSC) with an error code.\n * Since RSC errors can only be serialized through the digest field, this provides a way to include\n * an additional error code that can be extracted client-side via `extractNextErrorCode`.\n *\n * The error code is appended to the digest string with a semicolon separator, allowing it to be\n * parsed out later while preserving the original digest value.\n */ export const createDigestWithErrorCode = (thrownValue, originalDigest)=>{\n    if (typeof thrownValue === 'object' && thrownValue !== null && '__NEXT_ERROR_CODE' in thrownValue) {\n        return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`;\n    }\n    return originalDigest;\n};\nexport const extractNextErrorCode = (error)=>{\n    if (typeof error === 'object' && error !== null && '__NEXT_ERROR_CODE' in error && typeof error.__NEXT_ERROR_CODE === 'string') {\n        return error.__NEXT_ERROR_CODE;\n    }\n    if (typeof error === 'object' && error !== null && 'digest' in error && typeof error.digest === 'string') {\n        const segments = error.digest.split(ERROR_CODE_DELIMITER);\n        const errorCode = segments.find((segment)=>segment.startsWith('E'));\n        return errorCode;\n    }\n    return undefined;\n};\n\n//# sourceMappingURL=error-telemetry-utils.js.map"],"names":[],"mappings":";;;;;;AAAA,MAAM,uBAAuB;AAQlB,MAAM,4BAA4B,CAAC,aAAa;IACvD,IAAI,OAAO,gBAAgB,YAAY,gBAAgB,QAAQ,uBAAuB,aAAa;QAC/F,OAAO,GAAG,iBAAiB,uBAAuB,YAAY,iBAAiB,EAAE;IACrF;IACA,OAAO;AACX;AACO,MAAM,uBAAuB,CAAC;IACjC,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,uBAAuB,SAAS,OAAO,MAAM,iBAAiB,KAAK,UAAU;QAC5H,OAAO,MAAM,iBAAiB;IAClC;IACA,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY,SAAS,OAAO,MAAM,MAAM,KAAK,UAAU;QACtG,MAAM,WAAW,MAAM,MAAM,CAAC,KAAK,CAAC;QACpC,MAAM,YAAY,SAAS,IAAI,CAAC,CAAC,UAAU,QAAQ,UAAU,CAAC;QAC9D,OAAO;IACX;IACA,OAAO;AACX,GAEA,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 4734, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/app-render/create-error-handler.js"],"sourcesContent":["import stringHash from 'next/dist/compiled/string-hash';\nimport { formatServerError } from '../../lib/format-server-error';\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer';\nimport { isAbortError } from '../pipe-readable';\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { isDynamicServerError } from '../../client/components/hooks-server-context';\nimport { isNextRouterError } from '../../client/components/is-next-router-error';\nimport { isPrerenderInterruptedError } from './dynamic-rendering';\nimport { getProperError } from '../../lib/is-error';\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils';\nimport { isReactLargeShellError } from './react-large-shell-error';\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */ export function getDigestForWellKnownError(error) {\n    // If we're bailing out to CSR, we don't need to log the error.\n    if (isBailoutToCSRError(error)) return error.digest;\n    // If this is a navigation error, we don't need to log the error.\n    if (isNextRouterError(error)) return error.digest;\n    // If this error occurs, we know that we should be stopping the static\n    // render. This is only thrown in static generation when PPR is not enabled,\n    // which causes the whole page to be marked as dynamic. We don't need to\n    // tell the user about this error, as it's not actionable.\n    if (isDynamicServerError(error)) return error.digest;\n    // If this is a prerender interrupted error, we don't need to log the error.\n    if (isPrerenderInterruptedError(error)) return error.digest;\n    return undefined;\n}\nexport function createFlightReactServerErrorHandler(shouldFormatError, onReactServerRenderError) {\n    return (thrownValue)=>{\n        if (typeof thrownValue === 'string') {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            return stringHash(thrownValue).toString();\n        }\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (!err.digest) {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            err.digest = stringHash(err.message + err.stack || '').toString();\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Record exception in an active span, if available.\n        const span = getTracer().getActiveScopeSpan();\n        if (span) {\n            span.recordException(err);\n            span.setAttribute('error.type', err.name);\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message\n            });\n        }\n        onReactServerRenderError(err);\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function createHTMLReactServerErrorHandler(shouldFormatError, isNextExport, reactServerErrors, silenceLogger, onReactServerRenderError) {\n    return (thrownValue)=>{\n        var _err_message;\n        if (typeof thrownValue === 'string') {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            return stringHash(thrownValue).toString();\n        }\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (!err.digest) {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            err.digest = stringHash(err.message + (err.stack || '')).toString();\n        }\n        // @TODO by putting this here and not at the top it is possible that\n        // we don't error the build in places we actually expect to\n        if (!reactServerErrors.has(err.digest)) {\n            reactServerErrors.set(err.digest, err);\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Don't log the suppressed error during export\n        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {\n            // Record exception in an active span, if available.\n            const span = getTracer().getActiveScopeSpan();\n            if (span) {\n                span.recordException(err);\n                span.setAttribute('error.type', err.name);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message\n                });\n            }\n            if (!silenceLogger) {\n                onReactServerRenderError == null ? void 0 : onReactServerRenderError(err);\n            }\n        }\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function createHTMLErrorHandler(shouldFormatError, isNextExport, reactServerErrors, allCapturedErrors, silenceLogger, onHTMLRenderSSRError) {\n    return (thrownValue, errorInfo)=>{\n        var _err_message;\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        let isSSRError = true;\n        allCapturedErrors.push(thrownValue);\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (err.digest) {\n            if (reactServerErrors.has(err.digest)) {\n                // This error is likely an obfuscated error from react-server.\n                // We recover the original error here.\n                thrownValue = reactServerErrors.get(err.digest);\n                isSSRError = false;\n            } else {\n            // The error is not from react-server but has a digest\n            // from other means so we don't need to produce a new one\n            }\n        } else {\n            err.digest = stringHash(err.message + ((errorInfo == null ? void 0 : errorInfo.componentStack) || err.stack || '')).toString();\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Don't log the suppressed error during export\n        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {\n            // Record exception in an active span, if available.\n            const span = getTracer().getActiveScopeSpan();\n            if (span) {\n                span.recordException(err);\n                span.setAttribute('error.type', err.name);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message\n                });\n            }\n            if (!silenceLogger && // HTML errors contain RSC errors as well, filter them out before reporting\n            isSSRError) {\n                onHTMLRenderSSRError(err, errorInfo);\n            }\n        }\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function isUserLandError(err) {\n    return !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err);\n}\n\n//# sourceMappingURL=create-error-handler.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4948, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/app-render/collect-segment-data.js"],"sourcesContent":["/* eslint-disable @next/internal/no-ambiguous-jsx -- Bundled in entry-base so it gets the right JSX runtime. */ import { jsx as _jsx } from \"react/jsx-runtime\";\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { prerender } from 'react-server-dom-webpack/static';\nimport { streamFromBuffer, streamToBuffer } from '../stream-utils/node-web-streams-helper';\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\nimport { createSegmentRequestKeyPart, appendSegmentRequestKeyPart, ROOT_SEGMENT_REQUEST_KEY, HEAD_REQUEST_KEY } from '../../shared/lib/segment-cache/segment-value-encoding';\nimport { getDigestForWellKnownError } from './create-error-handler';\nconst filterStackFrame = process.env.NODE_ENV !== 'production' ? require('../lib/source-maps').filterStackFrameDEV : undefined;\nconst findSourceMapURL = process.env.NODE_ENV !== 'production' ? require('../lib/source-maps').findSourceMapURLDEV : undefined;\nfunction onSegmentPrerenderError(error) {\n    const digest = getDigestForWellKnownError(error);\n    if (digest) {\n        return digest;\n    }\n// We don't need to log the errors because we would have already done that\n// when generating the original Flight stream for the whole page.\n}\nexport async function collectSegmentData(isCacheComponentsEnabled, fullPageDataBuffer, staleTime, clientModules, serverConsumerManifest) {\n    // Traverse the router tree and generate a prefetch response for each segment.\n    // A mutable map to collect the results as we traverse the route tree.\n    const resultMap = new Map();\n    // Before we start, warm up the module cache by decoding the page data once.\n    // Then we can assume that any remaining async tasks that occur the next time\n    // are due to hanging promises caused by dynamic data access. Note we only\n    // have to do this once per page, not per individual segment.\n    //\n    try {\n        await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n            findSourceMapURL,\n            serverConsumerManifest\n        });\n        await waitAtLeastOneReactRenderTask();\n    } catch  {}\n    // Create an abort controller that we'll use to stop the stream.\n    const abortController = new AbortController();\n    const onCompletedProcessingRouteTree = async ()=>{\n        // Since all we're doing is decoding and re-encoding a cached prerender, if\n        // serializing the stream takes longer than a microtask, it must because of\n        // hanging promises caused by dynamic data.\n        await waitAtLeastOneReactRenderTask();\n        abortController.abort();\n    };\n    // Generate a stream for the route tree prefetch. While we're walking the\n    // tree, we'll also spawn additional tasks to generate the segment prefetches.\n    // The promises for these tasks are pushed to a mutable array that we will\n    // await once the route tree is fully rendered.\n    const segmentTasks = [];\n    const { prelude: treeStream } = await prerender(// RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    /*#__PURE__*/ _jsx(PrefetchTreeData, {\n        isClientParamParsingEnabled: isCacheComponentsEnabled,\n        fullPageDataBuffer: fullPageDataBuffer,\n        serverConsumerManifest: serverConsumerManifest,\n        clientModules: clientModules,\n        staleTime: staleTime,\n        segmentTasks: segmentTasks,\n        onCompletedProcessingRouteTree: onCompletedProcessingRouteTree\n    }), clientModules, {\n        filterStackFrame,\n        signal: abortController.signal,\n        onError: onSegmentPrerenderError\n    });\n    // Write the route tree to a special `/_tree` segment.\n    const treeBuffer = await streamToBuffer(treeStream);\n    resultMap.set('/_tree', treeBuffer);\n    // Also output the entire full page data response\n    resultMap.set('/_full', fullPageDataBuffer);\n    // Now that we've finished rendering the route tree, all the segment tasks\n    // should have been spawned. Await them in parallel and write the segment\n    // prefetches to the result map.\n    for (const [segmentPath, buffer] of (await Promise.all(segmentTasks))){\n        resultMap.set(segmentPath, buffer);\n    }\n    return resultMap;\n}\nasync function PrefetchTreeData({ isClientParamParsingEnabled, fullPageDataBuffer, serverConsumerManifest, clientModules, staleTime, segmentTasks, onCompletedProcessingRouteTree }) {\n    // We're currently rendering a Flight response for the route tree prefetch.\n    // Inside this component, decode the Flight stream for the whole page. This is\n    // a hack to transfer the side effects from the original Flight stream (e.g.\n    // Float preloads) onto the Flight stream for the tree prefetch.\n    // TODO: React needs a better way to do this. Needed for Server Actions, too.\n    const initialRSCPayload = await createFromReadableStream(createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)), {\n        findSourceMapURL,\n        serverConsumerManifest\n    });\n    const buildId = initialRSCPayload.b;\n    // FlightDataPath is an unsound type, hence the additional checks.\n    const flightDataPaths = initialRSCPayload.f;\n    if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n        console.error('Internal Next.js error: InitialRSCPayload does not match the expected ' + 'shape for a prerendered page during segment prefetch generation.');\n        return null;\n    }\n    const flightRouterState = flightDataPaths[0][0];\n    const seedData = flightDataPaths[0][1];\n    const head = flightDataPaths[0][2];\n    // Compute the route metadata tree by traversing the FlightRouterState. As we\n    // walk the tree, we will also spawn a task to produce a prefetch response for\n    // each segment.\n    const tree = collectSegmentDataImpl(isClientParamParsingEnabled, flightRouterState, buildId, seedData, clientModules, ROOT_SEGMENT_REQUEST_KEY, segmentTasks);\n    // Also spawn a task to produce a prefetch response for the \"head\" segment.\n    // The head contains metadata, like the title; it's not really a route\n    // segment, but it contains RSC data, so it's treated like a segment by\n    // the client cache.\n    segmentTasks.push(waitAtLeastOneReactRenderTask().then(()=>renderSegmentPrefetch(buildId, head, null, HEAD_REQUEST_KEY, clientModules)));\n    // Notify the abort controller that we're done processing the route tree.\n    // Anything async that happens after this point must be due to hanging\n    // promises in the original stream.\n    onCompletedProcessingRouteTree();\n    // Render the route tree to a special `/_tree` segment.\n    const treePrefetch = {\n        buildId,\n        tree,\n        staleTime\n    };\n    return treePrefetch;\n}\nfunction collectSegmentDataImpl(isClientParamParsingEnabled, route, buildId, seedData, clientModules, requestKey, segmentTasks) {\n    // Metadata about the segment. Sent as part of the tree prefetch. Null if\n    // there are no children.\n    let slotMetadata = null;\n    const children = route[1];\n    const seedDataChildren = seedData !== null ? seedData[1] : null;\n    for(const parallelRouteKey in children){\n        const childRoute = children[parallelRouteKey];\n        const childSegment = childRoute[0];\n        const childSeedData = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;\n        const childRequestKey = appendSegmentRequestKeyPart(requestKey, parallelRouteKey, createSegmentRequestKeyPart(childSegment));\n        const childTree = collectSegmentDataImpl(isClientParamParsingEnabled, childRoute, buildId, childSeedData, clientModules, childRequestKey, segmentTasks);\n        if (slotMetadata === null) {\n            slotMetadata = {};\n        }\n        slotMetadata[parallelRouteKey] = childTree;\n    }\n    const hasRuntimePrefetch = seedData !== null ? seedData[4] : false;\n    if (seedData !== null) {\n        // Spawn a task to write the segment data to a new Flight stream.\n        segmentTasks.push(// Since we're already in the middle of a render, wait until after the\n        // current task to escape the current rendering context.\n        waitAtLeastOneReactRenderTask().then(()=>renderSegmentPrefetch(buildId, seedData[0], seedData[2], requestKey, clientModules)));\n    } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n    }\n    const segment = route[0];\n    let name;\n    let paramType = null;\n    let paramKey = null;\n    if (typeof segment === 'string') {\n        name = segment;\n        paramKey = segment;\n        paramType = null;\n    } else {\n        name = segment[0];\n        paramKey = segment[1];\n        paramType = segment[2];\n    }\n    // Metadata about the segment. Sent to the client as part of the\n    // tree prefetch.\n    return {\n        name,\n        paramType,\n        // This value is ommitted from the prefetch response when cacheComponents\n        // is enabled.\n        paramKey: isClientParamParsingEnabled ? null : paramKey,\n        hasRuntimePrefetch,\n        slots: slotMetadata,\n        isRootLayout: route[4] === true\n    };\n}\nasync function renderSegmentPrefetch(buildId, rsc, loading, requestKey, clientModules) {\n    // Render the segment data to a stream.\n    // In the future, this is where we can include additional metadata, like the\n    // stale time and cache tags.\n    const segmentPrefetch = {\n        buildId,\n        rsc,\n        loading,\n        isPartial: await isPartialRSCData(rsc, clientModules)\n    };\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // it takes longer than a microtask, it must because of hanging promises\n    // caused by dynamic data. Abort the stream at the end of the current task.\n    const abortController = new AbortController();\n    waitAtLeastOneReactRenderTask().then(()=>abortController.abort());\n    const { prelude: segmentStream } = await prerender(segmentPrefetch, clientModules, {\n        filterStackFrame,\n        signal: abortController.signal,\n        onError: onSegmentPrerenderError\n    });\n    const segmentBuffer = await streamToBuffer(segmentStream);\n    if (requestKey === ROOT_SEGMENT_REQUEST_KEY) {\n        return [\n            '/_index',\n            segmentBuffer\n        ];\n    } else {\n        return [\n            requestKey,\n            segmentBuffer\n        ];\n    }\n}\nasync function isPartialRSCData(rsc, clientModules) {\n    // We can determine if a segment contains only partial data if it takes longer\n    // than a task to encode, because dynamic data is encoded as an infinite\n    // promise. We must do this in a separate Flight prerender from the one that\n    // actually generates the prefetch stream because we need to include\n    // `isPartial` in the stream itself.\n    let isPartial = false;\n    const abortController = new AbortController();\n    waitAtLeastOneReactRenderTask().then(()=>{\n        // If we haven't yet finished the outer task, then it must be because we\n        // accessed dynamic data.\n        isPartial = true;\n        abortController.abort();\n    });\n    await prerender(rsc, clientModules, {\n        filterStackFrame,\n        signal: abortController.signal,\n        onError () {}\n    });\n    return isPartial;\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\n\n//# sourceMappingURL=collect-segment-data.js.map"],"names":[],"mappings":"AAAA,6GAA6G;;;;AAAG;AAChH,6DAA6D;AAC7D;AACA,6DAA6D;AAC7D;AACA;;;;;;;;;;;AAGA;;;;;;;;AACA,MAAM,mBAAmB,uCAAwC;;;;KAA8B,mBAAmB,GAAG;AACrH,MAAM,mBAAmB,uCAAwC;;;;KAA8B,mBAAmB,GAAG;AACrH,SAAS,wBAAwB,KAAK;IAClC,MAAM,SAAS,IAAA,gPAA0B,EAAC;IAC1C,IAAI,QAAQ;QACR,OAAO;IACX;AACJ,0EAA0E;AAC1E,iEAAiE;AACjE;AACO,eAAe,mBAAmB,wBAAwB,EAAE,kBAAkB,EAAE,SAAS,EAAE,aAAa,EAAE,sBAAsB;IACnI,8EAA8E;IAC9E,sEAAsE;IACtE,MAAM,YAAY,IAAI;IACtB,4EAA4E;IAC5E,6EAA6E;IAC7E,0EAA0E;IAC1E,6DAA6D;IAC7D,EAAE;IACF,IAAI;QACA,MAAM,IAAA,mPAAwB,EAAC,IAAA,8OAAgB,EAAC,qBAAqB;YACjE;YACA;QACJ;QACA,MAAM;IACV,EAAE,OAAO,CAAC;IACV,gEAAgE;IAChE,MAAM,kBAAkB,IAAI;IAC5B,MAAM,iCAAiC;QACnC,2EAA2E;QAC3E,2EAA2E;QAC3E,2CAA2C;QAC3C,MAAM;QACN,gBAAgB,KAAK;IACzB;IACA,yEAAyE;IACzE,8EAA8E;IAC9E,0EAA0E;IAC1E,+CAA+C;IAC/C,MAAM,eAAe,EAAE;IACvB,MAAM,EAAE,SAAS,UAAU,EAAE,GAAG,MAAM,IAAA,qQAAS,EAC/C,wEAAwE;IACxE,oEAAoE;IACpE,mBAAmB;IACnB,WAAW,GAAG,IAAA,yOAAI,EAAC,kBAAkB;QACjC,6BAA6B;QAC7B,oBAAoB;QACpB,wBAAwB;QACxB,eAAe;QACf,WAAW;QACX,cAAc;QACd,gCAAgC;IACpC,IAAI,eAAe;QACf;QACA,QAAQ,gBAAgB,MAAM;QAC9B,SAAS;IACb;IACA,sDAAsD;IACtD,MAAM,aAAa,MAAM,IAAA,4OAAc,EAAC;IACxC,UAAU,GAAG,CAAC,UAAU;IACxB,iDAAiD;IACjD,UAAU,GAAG,CAAC,UAAU;IACxB,0EAA0E;IAC1E,yEAAyE;IACzE,gCAAgC;IAChC,KAAK,MAAM,CAAC,aAAa,OAAO,IAAI,CAAC,MAAM,QAAQ,GAAG,CAAC,aAAa,EAAE;QAClE,UAAU,GAAG,CAAC,aAAa;IAC/B;IACA,OAAO;AACX;AACA,eAAe,iBAAiB,EAAE,2BAA2B,EAAE,kBAAkB,EAAE,sBAAsB,EAAE,aAAa,EAAE,SAAS,EAAE,YAAY,EAAE,8BAA8B,EAAE;IAC/K,2EAA2E;IAC3E,8EAA8E;IAC9E,4EAA4E;IAC5E,gEAAgE;IAChE,6EAA6E;IAC7E,MAAM,oBAAoB,MAAM,IAAA,mPAAwB,EAAC,8BAA8B,IAAA,8OAAgB,EAAC,sBAAsB;QAC1H;QACA;IACJ;IACA,MAAM,UAAU,kBAAkB,CAAC;IACnC,kEAAkE;IAClE,MAAM,kBAAkB,kBAAkB,CAAC;IAC3C,IAAI,gBAAgB,MAAM,KAAK,KAAK,eAAe,CAAC,EAAE,CAAC,MAAM,KAAK,GAAG;QACjE,QAAQ,KAAK,CAAC,2EAA2E;QACzF,OAAO;IACX;IACA,MAAM,oBAAoB,eAAe,CAAC,EAAE,CAAC,EAAE;IAC/C,MAAM,WAAW,eAAe,CAAC,EAAE,CAAC,EAAE;IACtC,MAAM,OAAO,eAAe,CAAC,EAAE,CAAC,EAAE;IAClC,6EAA6E;IAC7E,8EAA8E;IAC9E,gBAAgB;IAChB,MAAM,OAAO,uBAAuB,6BAA6B,mBAAmB,SAAS,UAAU,eAAe,0BAA0B;IAChJ,2EAA2E;IAC3E,sEAAsE;IACtE,uEAAuE;IACvE,oBAAoB;IACpB,aAAa,IAAI,CAAC,gCAAgC,IAAI,CAAC,IAAI,sBAAsB,SAAS,MAAM,MAAM,kBAAkB;IACxH,yEAAyE;IACzE,sEAAsE;IACtE,mCAAmC;IACnC;IACA,uDAAuD;IACvD,MAAM,eAAe;QACjB;QACA;QACA;IACJ;IACA,OAAO;AACX;AACA,SAAS,uBAAuB,2BAA2B,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE,UAAU,EAAE,YAAY;IAC1H,yEAAyE;IACzE,yBAAyB;IACzB,IAAI,eAAe;IACnB,MAAM,WAAW,KAAK,CAAC,EAAE;IACzB,MAAM,mBAAmB,aAAa,OAAO,QAAQ,CAAC,EAAE,GAAG;IAC3D,IAAI,MAAM,oBAAoB,SAAS;QACnC,MAAM,aAAa,QAAQ,CAAC,iBAAiB;QAC7C,MAAM,eAAe,UAAU,CAAC,EAAE;QAClC,MAAM,gBAAgB,qBAAqB,OAAO,gBAAgB,CAAC,iBAAiB,GAAG;QACvF,MAAM,kBAAkB,4BAA4B,YAAY,kBAAkB,4BAA4B;QAC9G,MAAM,YAAY,uBAAuB,6BAA6B,YAAY,SAAS,eAAe,eAAe,iBAAiB;QAC1I,IAAI,iBAAiB,MAAM;YACvB,eAAe,CAAC;QACpB;QACA,YAAY,CAAC,iBAAiB,GAAG;IACrC;IACA,MAAM,qBAAqB,aAAa,OAAO,QAAQ,CAAC,EAAE,GAAG;IAC7D,IAAI,aAAa,MAAM;QACnB,iEAAiE;QACjE,aAAa,IAAI,CACjB,wDAAwD;QACxD,gCAAgC,IAAI,CAAC,IAAI,sBAAsB,SAAS,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,EAAE,EAAE,YAAY;IAClH,OAAO;IACP,uEAAuE;IACvE,qEAAqE;IACrE,wEAAwE;IACxE,0EAA0E;IAC1E,mCAAmC;IACnC;IACA,MAAM,UAAU,KAAK,CAAC,EAAE;IACxB,IAAI;IACJ,IAAI,YAAY;IAChB,IAAI,WAAW;IACf,IAAI,OAAO,YAAY,UAAU;QAC7B,OAAO;QACP,WAAW;QACX,YAAY;IAChB,OAAO;QACH,OAAO,OAAO,CAAC,EAAE;QACjB,WAAW,OAAO,CAAC,EAAE;QACrB,YAAY,OAAO,CAAC,EAAE;IAC1B;IACA,gEAAgE;IAChE,iBAAiB;IACjB,OAAO;QACH;QACA;QACA,yEAAyE;QACzE,cAAc;QACd,UAAU,8BAA8B,OAAO;QAC/C;QACA,OAAO;QACP,cAAc,KAAK,CAAC,EAAE,KAAK;IAC/B;AACJ;AACA,eAAe,sBAAsB,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,UAAU,EAAE,aAAa;IACjF,uCAAuC;IACvC,4EAA4E;IAC5E,6BAA6B;IAC7B,MAAM,kBAAkB;QACpB;QACA;QACA;QACA,WAAW,MAAM,iBAAiB,KAAK;IAC3C;IACA,2EAA2E;IAC3E,wEAAwE;IACxE,2EAA2E;IAC3E,MAAM,kBAAkB,IAAI;IAC5B,gCAAgC,IAAI,CAAC,IAAI,gBAAgB,KAAK;IAC9D,MAAM,EAAE,SAAS,aAAa,EAAE,GAAG,MAAM,IAAA,qQAAS,EAAC,iBAAiB,eAAe;QAC/E;QACA,QAAQ,gBAAgB,MAAM;QAC9B,SAAS;IACb;IACA,MAAM,gBAAgB,MAAM,IAAA,4OAAc,EAAC;IAC3C,IAAI,eAAe,0BAA0B;QACzC,OAAO;YACH;YACA;SACH;IACL,OAAO;QACH,OAAO;YACH;YACA;SACH;IACL;AACJ;AACA,eAAe,iBAAiB,GAAG,EAAE,aAAa;IAC9C,8EAA8E;IAC9E,wEAAwE;IACxE,4EAA4E;IAC5E,oEAAoE;IACpE,oCAAoC;IACpC,IAAI,YAAY;IAChB,MAAM,kBAAkB,IAAI;IAC5B,gCAAgC,IAAI,CAAC;QACjC,wEAAwE;QACxE,yBAAyB;QACzB,YAAY;QACZ,gBAAgB,KAAK;IACzB;IACA,MAAM,IAAA,qQAAS,EAAC,KAAK,eAAe;QAChC;QACA,QAAQ,gBAAgB,MAAM;QAC9B,YAAY;IAChB;IACA,OAAO;AACX;AACA,SAAS,8BAA8B,oBAAoB;IACvD,0EAA0E;IAC1E,4EAA4E;IAC5E,uEAAuE;IACvE,0EAA0E;IAC1E,8DAA8D;IAC9D,2CAA2C;IAC3C,EAAE;IACF,2EAA2E;IAC3E,0EAA0E;IAC1E,8EAA8E;IAC9E,+BAA+B;IAC/B,MAAM,SAAS,qBAAqB,SAAS;IAC7C,OAAO,IAAI,eAAe;QACtB,MAAM,MAAM,UAAU;YAClB,MAAM,KAAK;gBACP,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO,IAAI;gBACzC,IAAI,CAAC,MAAM;oBACP,mEAAmE;oBACnE,mBAAmB;oBACnB,WAAW,OAAO,CAAC;oBACnB;gBACJ;gBACA,qEAAqE;gBACrE,qBAAqB;gBACrB;YACJ;QACJ;IACJ;AACJ,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 5237, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/constants.js"],"sourcesContent":["export const TEXT_PLAIN_CONTENT_TYPE_HEADER = 'text/plain';\nexport const HTML_CONTENT_TYPE_HEADER = 'text/html; charset=utf-8';\nexport const JSON_CONTENT_TYPE_HEADER = 'application/json; charset=utf-8';\nexport const NEXT_QUERY_PARAM_PREFIX = 'nxtP';\nexport const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';\nexport const MATCHED_PATH_HEADER = 'x-matched-path';\nexport const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';\nexport const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = 'x-prerender-revalidate-if-generated';\nexport const RSC_PREFETCH_SUFFIX = '.prefetch.rsc';\nexport const RSC_SEGMENTS_DIR_SUFFIX = '.segments';\nexport const RSC_SEGMENT_SUFFIX = '.segment.rsc';\nexport const RSC_SUFFIX = '.rsc';\nexport const ACTION_SUFFIX = '.action';\nexport const NEXT_DATA_SUFFIX = '.json';\nexport const NEXT_META_SUFFIX = '.meta';\nexport const NEXT_BODY_SUFFIX = '.body';\nexport const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';\nexport const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';\nexport const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';\nexport const NEXT_RESUME_HEADER = 'next-resume';\n// if these change make sure we update the related\n// documentation as well\nexport const NEXT_CACHE_TAG_MAX_ITEMS = 128;\nexport const NEXT_CACHE_TAG_MAX_LENGTH = 256;\nexport const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;\nexport const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';\n// in seconds\nexport const CACHE_ONE_YEAR = 31536000;\n// in seconds, represents revalidate=false. I.e. never revaliate.\n// We use this value since it can be represented as a V8 SMI for optimal performance.\n// It can also be serialized as JSON if it ever leaks accidentally as an actual value.\nexport const INFINITE_CACHE = 0xfffffffe;\n// Patterns to detect middleware files\nexport const MIDDLEWARE_FILENAME = 'middleware';\nexport const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;\n// Patterns to detect proxy files (replacement for middleware)\nexport const PROXY_FILENAME = 'proxy';\nexport const PROXY_LOCATION_REGEXP = `(?:src/)?${PROXY_FILENAME}`;\n// Pattern to detect instrumentation hooks file\nexport const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';\n// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,\n// we have to use a private alias\nexport const PAGES_DIR_ALIAS = 'private-next-pages';\nexport const DOT_NEXT_ALIAS = 'private-dot-next';\nexport const ROOT_DIR_ALIAS = 'private-next-root-dir';\nexport const APP_DIR_ALIAS = 'private-next-app-dir';\nexport const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy';\nexport const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';\nexport const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';\nexport const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';\nexport const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = 'private-next-rsc-track-dynamic-import';\nexport const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';\nexport const RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';\nexport const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;\nexport const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;\nexport const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;\nexport const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;\nexport const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;\nexport const SERVER_PROPS_EXPORT_ERROR = `pages with \\`getServerSideProps\\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;\nexport const GSP_NO_RETURNED_VALUE = 'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';\nexport const GSSP_NO_RETURNED_VALUE = 'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';\nexport const UNSTABLE_REVALIDATE_RENAME_ERROR = 'The `unstable_revalidate` property is available for general use.\\n' + 'Please use `revalidate` instead.';\nexport const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;\nexport const NON_STANDARD_NODE_ENV = `You are using a non-standard \"NODE_ENV\" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;\nexport const SSG_FALLBACK_EXPORT_ERROR = `Pages with \\`fallback\\` enabled in \\`getStaticPaths\\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;\nexport const ESLINT_DEFAULT_DIRS = [\n    'app',\n    'pages',\n    'components',\n    'lib',\n    'src'\n];\nexport const SERVER_RUNTIME = {\n    edge: 'edge',\n    experimentalEdge: 'experimental-edge',\n    nodejs: 'nodejs'\n};\nexport const WEB_SOCKET_MAX_RECONNECTIONS = 12;\n/**\n * The names of the webpack layers. These layers are the primitives for the\n * webpack chunks.\n */ const WEBPACK_LAYERS_NAMES = {\n    /**\n   * The layer for the shared code between the client and server bundles.\n   */ shared: 'shared',\n    /**\n   * The layer for server-only runtime and picking up `react-server` export conditions.\n   * Including app router RSC pages and app router custom routes and metadata routes.\n   */ reactServerComponents: 'rsc',\n    /**\n   * Server Side Rendering layer for app (ssr).\n   */ serverSideRendering: 'ssr',\n    /**\n   * The browser client bundle layer for actions.\n   */ actionBrowser: 'action-browser',\n    /**\n   * The Node.js bundle layer for the API routes.\n   */ apiNode: 'api-node',\n    /**\n   * The Edge Lite bundle layer for the API routes.\n   */ apiEdge: 'api-edge',\n    /**\n   * The layer for the middleware code.\n   */ middleware: 'middleware',\n    /**\n   * The layer for the instrumentation hooks.\n   */ instrument: 'instrument',\n    /**\n   * The layer for assets on the edge.\n   */ edgeAsset: 'edge-asset',\n    /**\n   * The browser client bundle layer for App directory.\n   */ appPagesBrowser: 'app-pages-browser',\n    /**\n   * The browser client bundle layer for Pages directory.\n   */ pagesDirBrowser: 'pages-dir-browser',\n    /**\n   * The Edge Lite bundle layer for Pages directory.\n   */ pagesDirEdge: 'pages-dir-edge',\n    /**\n   * The Node.js bundle layer for Pages directory.\n   */ pagesDirNode: 'pages-dir-node'\n};\nconst WEBPACK_LAYERS = {\n    ...WEBPACK_LAYERS_NAMES,\n    GROUP: {\n        builtinReact: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser\n        ],\n        serverOnly: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.instrument,\n            WEBPACK_LAYERS_NAMES.middleware\n        ],\n        neutralTarget: [\n            // pages api\n            WEBPACK_LAYERS_NAMES.apiNode,\n            WEBPACK_LAYERS_NAMES.apiEdge\n        ],\n        clientOnly: [\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser\n        ],\n        bundled: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\n            WEBPACK_LAYERS_NAMES.shared,\n            WEBPACK_LAYERS_NAMES.instrument,\n            WEBPACK_LAYERS_NAMES.middleware\n        ],\n        appPages: [\n            // app router pages and layouts\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\n            WEBPACK_LAYERS_NAMES.actionBrowser\n        ]\n    }\n};\nconst WEBPACK_RESOURCE_QUERIES = {\n    edgeSSREntry: '__next_edge_ssr_entry__',\n    metadata: '__next_metadata__',\n    metadataRoute: '__next_metadata_route__',\n    metadataImageMeta: '__next_metadata_image_meta__'\n};\nexport { WEBPACK_LAYERS, WEBPACK_RESOURCE_QUERIES };\n\n//# sourceMappingURL=constants.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5521, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/lib/clone-response.js"],"sourcesContent":["const noop = ()=>{};\nlet registry;\nif (globalThis.FinalizationRegistry) {\n    registry = new FinalizationRegistry((weakRef)=>{\n        const stream = weakRef.deref();\n        if (stream && !stream.locked) {\n            stream.cancel('Response object has been garbage collected').then(noop);\n        }\n    });\n}\n/**\n * Clones a response by teeing the body so we can return two independent\n * ReadableStreams from it. This avoids the bug in the undici library around\n * response cloning.\n *\n * After cloning, the original response's body will be consumed and closed.\n *\n * @see https://github.com/vercel/next.js/pull/73274\n *\n * @param original - The original response to clone.\n * @returns A tuple containing two independent clones of the original response.\n */ export function cloneResponse(original) {\n    // If the response has no body, then we can just return the original response\n    // twice because it's immutable.\n    if (!original.body) {\n        return [\n            original,\n            original\n        ];\n    }\n    const [body1, body2] = original.body.tee();\n    const cloned1 = new Response(body1, {\n        status: original.status,\n        statusText: original.statusText,\n        headers: original.headers\n    });\n    Object.defineProperty(cloned1, 'url', {\n        value: original.url,\n        // How the original response.url behaves\n        configurable: true,\n        enumerable: true,\n        writable: false\n    });\n    // The Fetch Standard allows users to skip consuming the response body by\n    // relying on garbage collection to release connection resources.\n    // https://github.com/nodejs/undici?tab=readme-ov-file#garbage-collection\n    //\n    // To cancel the stream you then need to cancel both resulting branches.\n    // Teeing a stream will generally lock it for the duration, preventing other\n    // readers from locking it.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/tee\n    // cloned2 is stored in a react cache and cloned for subsequent requests.\n    // It is the original request, and is is garbage collected by a\n    // FinalizationRegistry in Undici, but since we're tee-ing the stream\n    // ourselves, we need to cancel clone1's stream (the response returned from\n    // our dedupe fetch) when clone1 is reclaimed, otherwise we leak memory.\n    if (registry && cloned1.body) {\n        registry.register(cloned1, new WeakRef(cloned1.body));\n    }\n    const cloned2 = new Response(body2, {\n        status: original.status,\n        statusText: original.statusText,\n        headers: original.headers\n    });\n    Object.defineProperty(cloned2, 'url', {\n        value: original.url,\n        // How the original response.url behaves\n        configurable: true,\n        enumerable: true,\n        writable: false\n    });\n    return [\n        cloned1,\n        cloned2\n    ];\n}\n\n//# sourceMappingURL=clone-response.js.map"],"names":[],"mappings":";;;;AAAA,MAAM,OAAO,KAAK;AAClB,IAAI;AACJ,IAAI,WAAW,oBAAoB,EAAE;IACjC,WAAW,IAAI,qBAAqB,CAAC;QACjC,MAAM,SAAS,QAAQ,KAAK;QAC5B,IAAI,UAAU,CAAC,OAAO,MAAM,EAAE;YAC1B,OAAO,MAAM,CAAC,8CAA8C,IAAI,CAAC;QACrE;IACJ;AACJ;AAYW,SAAS,cAAc,QAAQ;IACtC,6EAA6E;IAC7E,gCAAgC;IAChC,IAAI,CAAC,SAAS,IAAI,EAAE;QAChB,OAAO;YACH;YACA;SACH;IACL;IACA,MAAM,CAAC,OAAO,MAAM,GAAG,SAAS,IAAI,CAAC,GAAG;IACxC,MAAM,UAAU,IAAI,SAAS,OAAO;QAChC,QAAQ,SAAS,MAAM;QACvB,YAAY,SAAS,UAAU;QAC/B,SAAS,SAAS,OAAO;IAC7B;IACA,OAAO,cAAc,CAAC,SAAS,OAAO;QAClC,OAAO,SAAS,GAAG;QACnB,wCAAwC;QACxC,cAAc;QACd,YAAY;QACZ,UAAU;IACd;IACA,yEAAyE;IACzE,iEAAiE;IACjE,yEAAyE;IACzE,EAAE;IACF,wEAAwE;IACxE,4EAA4E;IAC5E,2BAA2B;IAC3B,sEAAsE;IACtE,yEAAyE;IACzE,+DAA+D;IAC/D,qEAAqE;IACrE,2EAA2E;IAC3E,wEAAwE;IACxE,IAAI,YAAY,QAAQ,IAAI,EAAE;QAC1B,SAAS,QAAQ,CAAC,SAAS,IAAI,QAAQ,QAAQ,IAAI;IACvD;IACA,MAAM,UAAU,IAAI,SAAS,OAAO;QAChC,QAAQ,SAAS,MAAM;QACvB,YAAY,SAAS,UAAU;QAC/B,SAAS,SAAS,OAAO;IAC7B;IACA,OAAO,cAAc,CAAC,SAAS,OAAO;QAClC,OAAO,SAAS,GAAG;QACnB,wCAAwC;QACxC,cAAc;QACd,YAAY;QACZ,UAAU;IACd;IACA,OAAO;QACH;QACA;KACH;AACL,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 5594, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/lib/dedupe-fetch.js"],"sourcesContent":["/**\n * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js\n */ import * as React from 'react';\nimport { cloneResponse } from './clone-response';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nconst simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]' // generateCacheKey(new Request('https://blank'));\n;\n// Headers that should not affect deduplication\n// traceparent and tracestate are used for distributed tracing and should not affect cache keys\nconst headersToExcludeInCacheKey = new Set([\n    'traceparent',\n    'tracestate'\n]);\nfunction generateCacheKey(request) {\n    // We pick the fields that goes into the key used to dedupe requests.\n    // We don't include the `cache` field, because we end up using whatever\n    // caching resulted from the first request.\n    // Notably we currently don't consider non-standard (or future) options.\n    // This might not be safe. TODO: warn for non-standard extensions differing.\n    // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n    const filteredHeaders = Array.from(request.headers.entries()).filter(([key])=>!headersToExcludeInCacheKey.has(key.toLowerCase()));\n    return JSON.stringify([\n        request.method,\n        filteredHeaders,\n        request.mode,\n        request.redirect,\n        request.credentials,\n        request.referrer,\n        request.referrerPolicy,\n        request.integrity\n    ]);\n}\nexport function createDedupeFetch(originalFetch) {\n    const getCacheEntries = React.cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key\n    (url)=>[]);\n    return function dedupeFetch(resource, options) {\n        if (options && options.signal) {\n            // If we're passed a signal, then we assume that\n            // someone else controls the lifetime of this object and opts out of\n            // caching. It's effectively the opt-out mechanism.\n            // Ideally we should be able to check this on the Request but\n            // it always gets initialized with its own signal so we don't\n            // know if it's supposed to override - unless we also override the\n            // Request constructor.\n            return originalFetch(resource, options);\n        }\n        // Normalize the Request\n        let url;\n        let cacheKey;\n        if (typeof resource === 'string' && !options) {\n            // Fast path.\n            cacheKey = simpleCacheKey;\n            url = resource;\n        } else {\n            // Normalize the request.\n            // if resource is not a string or a URL (its an instance of Request)\n            // then do not instantiate a new Request but instead\n            // reuse the request as to not disturb the body in the event it's a ReadableStream.\n            const request = typeof resource === 'string' || resource instanceof URL ? new Request(resource, options) : resource;\n            if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {\n                // We currently don't dedupe requests that might have side-effects. Those\n                // have to be explicitly cached. We assume that the request doesn't have a\n                // body if it's GET or HEAD.\n                // keepalive gets treated the same as if you passed a custom cache signal.\n                return originalFetch(resource, options);\n            }\n            cacheKey = generateCacheKey(request);\n            url = request.url;\n        }\n        const cacheEntries = getCacheEntries(url);\n        for(let i = 0, j = cacheEntries.length; i < j; i += 1){\n            const [key, promise] = cacheEntries[i];\n            if (key === cacheKey) {\n                return promise.then(()=>{\n                    const response = cacheEntries[i][2];\n                    if (!response) throw Object.defineProperty(new InvariantError('No cached response'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E579\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    // We're cloning the response using this utility because there exists\n                    // a bug in the undici library around response cloning. See the\n                    // following pull request for more details:\n                    // https://github.com/vercel/next.js/pull/73274\n                    const [cloned1, cloned2] = cloneResponse(response);\n                    cacheEntries[i][2] = cloned2;\n                    return cloned1;\n                });\n            }\n        }\n        // We pass the original arguments here in case normalizing the Request\n        // doesn't include all the options in this environment.\n        const promise = originalFetch(resource, options);\n        const entry = [\n            cacheKey,\n            promise,\n            null\n        ];\n        cacheEntries.push(entry);\n        return promise.then((response)=>{\n            // We're cloning the response using this utility because there exists\n            // a bug in the undici library around response cloning. See the\n            // following pull request for more details:\n            // https://github.com/vercel/next.js/pull/73274\n            const [cloned1, cloned2] = cloneResponse(response);\n            entry[2] = cloned2;\n            return cloned1;\n        });\n    };\n}\n\n//# sourceMappingURL=dedupe-fetch.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AAAG;AACJ;AACA;;;;AACA,MAAM,iBAAiB,+CAA+C,kDAAkD;;AAExH,+CAA+C;AAC/C,+FAA+F;AAC/F,MAAM,6BAA6B,IAAI,IAAI;IACvC;IACA;CACH;AACD,SAAS,iBAAiB,OAAO;IAC7B,qEAAqE;IACrE,uEAAuE;IACvE,2CAA2C;IAC3C,wEAAwE;IACxE,4EAA4E;IAC5E,sDAAsD;IACtD,MAAM,kBAAkB,MAAM,IAAI,CAAC,QAAQ,OAAO,CAAC,OAAO,IAAI,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,2BAA2B,GAAG,CAAC,IAAI,WAAW;IAC7H,OAAO,KAAK,SAAS,CAAC;QAClB,QAAQ,MAAM;QACd;QACA,QAAQ,IAAI;QACZ,QAAQ,QAAQ;QAChB,QAAQ,WAAW;QACnB,QAAQ,QAAQ;QAChB,QAAQ,cAAc;QACtB,QAAQ,SAAS;KACpB;AACL;AACO,SAAS,kBAAkB,aAAa;IAC3C,MAAM,kBAAkB,yNAAW,CACnC,CAAC,MAAM,EAAE;IACT,OAAO,SAAS,YAAY,QAAQ,EAAE,OAAO;QACzC,IAAI,WAAW,QAAQ,MAAM,EAAE;YAC3B,gDAAgD;YAChD,oEAAoE;YACpE,mDAAmD;YACnD,6DAA6D;YAC7D,6DAA6D;YAC7D,kEAAkE;YAClE,uBAAuB;YACvB,OAAO,cAAc,UAAU;QACnC;QACA,wBAAwB;QACxB,IAAI;QACJ,IAAI;QACJ,IAAI,OAAO,aAAa,YAAY,CAAC,SAAS;YAC1C,aAAa;YACb,WAAW;YACX,MAAM;QACV,OAAO;YACH,yBAAyB;YACzB,oEAAoE;YACpE,oDAAoD;YACpD,mFAAmF;YACnF,MAAM,UAAU,OAAO,aAAa,YAAY,oBAAoB,MAAM,IAAI,QAAQ,UAAU,WAAW;YAC3G,IAAI,QAAQ,MAAM,KAAK,SAAS,QAAQ,MAAM,KAAK,UAAU,QAAQ,SAAS,EAAE;gBAC5E,yEAAyE;gBACzE,0EAA0E;gBAC1E,4BAA4B;gBAC5B,0EAA0E;gBAC1E,OAAO,cAAc,UAAU;YACnC;YACA,WAAW,iBAAiB;YAC5B,MAAM,QAAQ,GAAG;QACrB;QACA,MAAM,eAAe,gBAAgB;QACrC,IAAI,IAAI,IAAI,GAAG,IAAI,aAAa,MAAM,EAAE,IAAI,GAAG,KAAK,EAAE;YAClD,MAAM,CAAC,KAAK,QAAQ,GAAG,YAAY,CAAC,EAAE;YACtC,IAAI,QAAQ,UAAU;gBAClB,OAAO,QAAQ,IAAI,CAAC;oBAChB,MAAM,WAAW,YAAY,CAAC,EAAE,CAAC,EAAE;oBACnC,IAAI,CAAC,UAAU,MAAM,OAAO,cAAc,CAAC,IAAI,kNAAc,CAAC,uBAAuB,qBAAqB;wBACtG,OAAO;wBACP,YAAY;wBACZ,cAAc;oBAClB;oBACA,qEAAqE;oBACrE,+DAA+D;oBAC/D,2CAA2C;oBAC3C,+CAA+C;oBAC/C,MAAM,CAAC,SAAS,QAAQ,GAAG,IAAA,gNAAa,EAAC;oBACzC,YAAY,CAAC,EAAE,CAAC,EAAE,GAAG;oBACrB,OAAO;gBACX;YACJ;QACJ;QACA,sEAAsE;QACtE,uDAAuD;QACvD,MAAM,UAAU,cAAc,UAAU;QACxC,MAAM,QAAQ;YACV;YACA;YACA;SACH;QACD,aAAa,IAAI,CAAC;QAClB,OAAO,QAAQ,IAAI,CAAC,CAAC;YACjB,qEAAqE;YACrE,+DAA+D;YAC/D,2CAA2C;YAC3C,+CAA+C;YAC/C,MAAM,CAAC,SAAS,QAAQ,GAAG,IAAA,gNAAa,EAAC;YACzC,KAAK,CAAC,EAAE,GAAG;YACX,OAAO;QACX;IACJ;AACJ,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 5714, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/lib/batcher.js"],"sourcesContent":["import { DetachedPromise } from './detached-promise';\n/**\n * A wrapper for a function that will only allow one call to the function to\n * execute at a time.\n */ export class Batcher {\n    constructor(cacheKeyFn, /**\n     * A function that will be called to schedule the wrapped function to be\n     * executed. This defaults to a function that will execute the function\n     * immediately.\n     */ schedulerFn = (fn)=>fn()){\n        this.cacheKeyFn = cacheKeyFn;\n        this.schedulerFn = schedulerFn;\n        this.pending = new Map();\n    }\n    static create(options) {\n        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);\n    }\n    /**\n   * Wraps a function in a promise that will be resolved or rejected only once\n   * for a given key. This will allow multiple calls to the function to be\n   * made, but only one will be executed at a time. The result of the first\n   * call will be returned to all callers.\n   *\n   * @param key the key to use for the cache\n   * @param fn the function to wrap\n   * @returns a promise that resolves to the result of the function\n   */ async batch(key, fn) {\n        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;\n        if (cacheKey === null) {\n            return fn({\n                resolve: (value)=>Promise.resolve(value),\n                key\n            });\n        }\n        const pending = this.pending.get(cacheKey);\n        if (pending) return pending;\n        const { promise, resolve, reject } = new DetachedPromise();\n        this.pending.set(cacheKey, promise);\n        this.schedulerFn(async ()=>{\n            try {\n                const result = await fn({\n                    resolve,\n                    key\n                });\n                // Resolving a promise multiple times is a no-op, so we can safely\n                // resolve all pending promises with the same result.\n                resolve(result);\n            } catch (err) {\n                reject(err);\n            } finally{\n                this.pending.delete(cacheKey);\n            }\n        });\n        return promise;\n    }\n}\n\n//# sourceMappingURL=batcher.js.map"],"names":[],"mappings":";;;;AAAA;;AAIW,MAAM;IACb,YAAY,UAAU,EAAE;;;;KAIvB,GAAG,cAAc,CAAC,KAAK,IAAI,CAAC;QACzB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,OAAO,GAAG,IAAI;IACvB;IACA,OAAO,OAAO,OAAO,EAAE;QACnB,OAAO,IAAI,QAAQ,WAAW,OAAO,KAAK,IAAI,QAAQ,UAAU,EAAE,WAAW,OAAO,KAAK,IAAI,QAAQ,WAAW;IACpH;IACA;;;;;;;;;GASD,GAAG,MAAM,MAAM,GAAG,EAAE,EAAE,EAAE;QACnB,MAAM,WAAW,IAAI,CAAC,UAAU,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO;QAChE,IAAI,aAAa,MAAM;YACnB,OAAO,GAAG;gBACN,SAAS,CAAC,QAAQ,QAAQ,OAAO,CAAC;gBAClC;YACJ;QACJ;QACA,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;QACjC,IAAI,SAAS,OAAO;QACpB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,IAAI,0MAAe;QACxD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU;QAC3B,IAAI,CAAC,WAAW,CAAC;YACb,IAAI;gBACA,MAAM,SAAS,MAAM,GAAG;oBACpB;oBACA;gBACJ;gBACA,kEAAkE;gBAClE,qDAAqD;gBACrD,QAAQ;YACZ,EAAE,OAAO,KAAK;gBACV,OAAO;YACX,SAAS;gBACL,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YACxB;QACJ;QACA,OAAO;IACX;AACJ,EAEA,mCAAmC","ignoreList":[0]}},
    {"offset": {"line": 5776, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/response-cache/index.js"],"sourcesContent":["import { Batcher } from '../../lib/batcher';\nimport { scheduleOnNextTick } from '../../lib/scheduler';\nimport { fromResponseCacheEntry, routeKindToIncrementalCacheKind, toResponseCacheEntry } from './utils';\nexport * from './types';\nexport default class ResponseCache {\n    constructor(minimal_mode){\n        this.getBatcher = Batcher.create({\n            // Ensure on-demand revalidate doesn't block normal requests, it should be\n            // safe to run an on-demand revalidate for the same key as a normal request.\n            cacheKeyFn: ({ key, isOnDemandRevalidate })=>`${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n            // We wait to do any async work until after we've added our promise to\n            // `pendingResponses` to ensure that any any other calls will reuse the\n            // same promise until we've fully finished our work.\n            schedulerFn: scheduleOnNextTick\n        });\n        this.revalidateBatcher = Batcher.create({\n            // We wait to do any async work until after we've added our promise to\n            // `pendingResponses` to ensure that any any other calls will reuse the\n            // same promise until we've fully finished our work.\n            schedulerFn: scheduleOnNextTick\n        });\n        this.minimal_mode = minimal_mode;\n    }\n    /**\n   * Gets the response cache entry for the given key.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @returns The response cache entry.\n   */ async get(key, responseGenerator, context) {\n        var _this_previousCacheItem;\n        // If there is no key for the cache, we can't possibly look this up in the\n        // cache so just return the result of the response generator.\n        if (!key) {\n            return responseGenerator({\n                hasResolved: false,\n                previousCacheEntry: null\n            });\n        }\n        // Check minimal mode cache before doing any other work\n        if (this.minimal_mode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === key && this.previousCacheItem.expiresAt > Date.now()) {\n            return toResponseCacheEntry(this.previousCacheItem.entry);\n        }\n        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false, isPrefetch = false, waitUntil, routeKind } = context;\n        const response = await this.getBatcher.batch({\n            key,\n            isOnDemandRevalidate\n        }, ({ resolve })=>{\n            const promise = this.handleGet(key, responseGenerator, {\n                incrementalCache,\n                isOnDemandRevalidate,\n                isFallback,\n                isRoutePPREnabled,\n                isPrefetch,\n                routeKind\n            }, resolve);\n            // We need to ensure background revalidates are passed to waitUntil.\n            if (waitUntil) waitUntil(promise);\n            return promise;\n        });\n        return toResponseCacheEntry(response);\n    }\n    /**\n   * Handles the get request for the response cache.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @param resolve - The resolve function to use to resolve the response cache entry.\n   * @returns The response cache entry.\n   */ async handleGet(key, responseGenerator, context, resolve) {\n        let previousIncrementalCacheEntry = null;\n        let resolved = false;\n        try {\n            // Get the previous cache entry if not in minimal mode\n            previousIncrementalCacheEntry = !this.minimal_mode ? await context.incrementalCache.get(key, {\n                kind: routeKindToIncrementalCacheKind(context.routeKind),\n                isRoutePPREnabled: context.isRoutePPREnabled,\n                isFallback: context.isFallback\n            }) : null;\n            if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\n                resolve(previousIncrementalCacheEntry);\n                resolved = true;\n                if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\n                    // The cached value is still valid, so we don't need to update it yet.\n                    return previousIncrementalCacheEntry;\n                }\n            }\n            // Revalidate the cache entry\n            const incrementalResponseCacheEntry = await this.revalidate(key, context.incrementalCache, context.isRoutePPREnabled, context.isFallback, responseGenerator, previousIncrementalCacheEntry, previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate);\n            // Handle null response\n            if (!incrementalResponseCacheEntry) {\n                // Unset the previous cache item if it was set so we don't use it again.\n                if (this.minimal_mode) this.previousCacheItem = undefined;\n                return null;\n            }\n            // Resolve for on-demand revalidation or if not already resolved\n            if (context.isOnDemandRevalidate && !resolved) {\n                return incrementalResponseCacheEntry;\n            }\n            return incrementalResponseCacheEntry;\n        } catch (err) {\n            // If we've already resolved the cache entry, we can't reject as we\n            // already resolved the cache entry so log the error here.\n            if (resolved) {\n                console.error(err);\n                return null;\n            }\n            throw err;\n        }\n    }\n    /**\n   * Revalidates the cache entry for the given key.\n   *\n   * @param key - The key to revalidate the cache entry for.\n   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\n   * @param isRoutePPREnabled - Whether the route is PPR enabled.\n   * @param isFallback - Whether the route is a fallback.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\n   * @param hasResolved - Whether the response has been resolved.\n   * @returns The revalidated cache entry.\n   */ async revalidate(key, incrementalCache, isRoutePPREnabled, isFallback, responseGenerator, previousIncrementalCacheEntry, hasResolved, waitUntil) {\n        return this.revalidateBatcher.batch(key, ()=>{\n            const promise = this.handleRevalidate(key, incrementalCache, isRoutePPREnabled, isFallback, responseGenerator, previousIncrementalCacheEntry, hasResolved);\n            // We need to ensure background revalidates are passed to waitUntil.\n            if (waitUntil) waitUntil(promise);\n            return promise;\n        });\n    }\n    async handleRevalidate(key, incrementalCache, isRoutePPREnabled, isFallback, responseGenerator, previousIncrementalCacheEntry, hasResolved) {\n        try {\n            // Generate the response cache entry using the response generator.\n            const responseCacheEntry = await responseGenerator({\n                hasResolved,\n                previousCacheEntry: previousIncrementalCacheEntry,\n                isRevalidating: true\n            });\n            if (!responseCacheEntry) {\n                return null;\n            }\n            // Convert the response cache entry to an incremental response cache entry.\n            const incrementalResponseCacheEntry = await fromResponseCacheEntry({\n                ...responseCacheEntry,\n                isMiss: !previousIncrementalCacheEntry\n            });\n            // We want to persist the result only if it has a cache control value\n            // defined.\n            if (incrementalResponseCacheEntry.cacheControl) {\n                if (this.minimal_mode) {\n                    this.previousCacheItem = {\n                        key,\n                        entry: incrementalResponseCacheEntry,\n                        expiresAt: Date.now() + 1000\n                    };\n                } else {\n                    await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\n                        cacheControl: incrementalResponseCacheEntry.cacheControl,\n                        isRoutePPREnabled,\n                        isFallback\n                    });\n                }\n            }\n            return incrementalResponseCacheEntry;\n        } catch (err) {\n            // When a path is erroring we automatically re-set the existing cache\n            // with new revalidate and expire times to prevent non-stop retrying.\n            if (previousIncrementalCacheEntry == null ? void 0 : previousIncrementalCacheEntry.cacheControl) {\n                const revalidate = Math.min(Math.max(previousIncrementalCacheEntry.cacheControl.revalidate || 3, 3), 30);\n                const expire = previousIncrementalCacheEntry.cacheControl.expire === undefined ? undefined : Math.max(revalidate + 3, previousIncrementalCacheEntry.cacheControl.expire);\n                await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\n                    cacheControl: {\n                        revalidate: revalidate,\n                        expire: expire\n                    },\n                    isRoutePPREnabled,\n                    isFallback\n                });\n            }\n            // We haven't resolved yet, so let's throw to indicate an error.\n            throw err;\n        }\n    }\n}\n\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5999, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/lib/patch-fetch.js"],"sourcesContent":["import { AppRenderSpan, NextNodeServerSpan } from './trace/constants';\nimport { getTracer, SpanKind } from './trace/tracer';\nimport { CACHE_ONE_YEAR, INFINITE_CACHE, NEXT_CACHE_TAG_MAX_ITEMS, NEXT_CACHE_TAG_MAX_LENGTH } from '../../lib/constants';\nimport { markCurrentScopeAsDynamic } from '../app-render/dynamic-rendering';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupeFetch } from './dedupe-fetch';\nimport { getCacheSignal } from '../app-render/work-unit-async-storage.external';\nimport { CachedRouteKind, IncrementalCacheKind } from '../response-cache';\nimport { cloneResponse } from './clone-response';\nimport { RenderStage } from '../app-render/staged-rendering';\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge';\nexport const NEXT_PATCH_SYMBOL = Symbol.for('next-patch');\nfunction isFetchPatched() {\n    return globalThis[NEXT_PATCH_SYMBOL] === true;\n}\nexport function validateRevalidate(revalidateVal, route) {\n    try {\n        let normalizedRevalidate = undefined;\n        if (revalidateVal === false) {\n            normalizedRevalidate = INFINITE_CACHE;\n        } else if (typeof revalidateVal === 'number' && !isNaN(revalidateVal) && revalidateVal > -1) {\n            normalizedRevalidate = revalidateVal;\n        } else if (typeof revalidateVal !== 'undefined') {\n            throw Object.defineProperty(new Error(`Invalid revalidate value \"${revalidateVal}\" on \"${route}\", must be a non-negative number or false`), \"__NEXT_ERROR_CODE\", {\n                value: \"E179\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return normalizedRevalidate;\n    } catch (err) {\n        // handle client component error from attempting to check revalidate value\n        if (err instanceof Error && err.message.includes('Invalid revalidate')) {\n            throw err;\n        }\n        return undefined;\n    }\n}\nexport function validateTags(tags, description) {\n    const validTags = [];\n    const invalidTags = [];\n    for(let i = 0; i < tags.length; i++){\n        const tag = tags[i];\n        if (typeof tag !== 'string') {\n            invalidTags.push({\n                tag,\n                reason: 'invalid type, must be a string'\n            });\n        } else if (tag.length > NEXT_CACHE_TAG_MAX_LENGTH) {\n            invalidTags.push({\n                tag,\n                reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`\n            });\n        } else {\n            validTags.push(tag);\n        }\n        if (validTags.length > NEXT_CACHE_TAG_MAX_ITEMS) {\n            console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(', '));\n            break;\n        }\n    }\n    if (invalidTags.length > 0) {\n        console.warn(`Warning: invalid tags passed to ${description}: `);\n        for (const { tag, reason } of invalidTags){\n            console.log(`tag: \"${tag}\" ${reason}`);\n        }\n    }\n    return validTags;\n}\nfunction trackFetchMetric(workStore, ctx) {\n    if (!workStore.shouldTrackFetchMetrics) {\n        return;\n    }\n    workStore.fetchMetrics ??= [];\n    workStore.fetchMetrics.push({\n        ...ctx,\n        end: performance.timeOrigin + performance.now(),\n        idx: workStore.nextFetchId || 0\n    });\n}\nasync function createCachedPrerenderResponse(res, cacheKey, incrementalCacheContext, incrementalCache, revalidate, handleUnlock) {\n    // We are prerendering at build time or revalidate time with cacheComponents so we\n    // need to buffer the response so we can guarantee it can be read in a\n    // microtask.\n    const bodyBuffer = await res.arrayBuffer();\n    const fetchedData = {\n        headers: Object.fromEntries(res.headers.entries()),\n        body: Buffer.from(bodyBuffer).toString('base64'),\n        status: res.status,\n        url: res.url\n    };\n    // We can skip setting the serverComponentsHmrCache because we aren't in dev\n    // mode.\n    if (incrementalCacheContext) {\n        await incrementalCache.set(cacheKey, {\n            kind: CachedRouteKind.FETCH,\n            data: fetchedData,\n            revalidate\n        }, incrementalCacheContext);\n    }\n    await handleUnlock();\n    // We return a new Response to the caller.\n    return new Response(bodyBuffer, {\n        headers: res.headers,\n        status: res.status,\n        statusText: res.statusText\n    });\n}\nasync function createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheContext, incrementalCache, serverComponentsHmrCache, revalidate, input, handleUnlock) {\n    // We're cloning the response using this utility because there exists a bug in\n    // the undici library around response cloning. See the following pull request\n    // for more details: https://github.com/vercel/next.js/pull/73274\n    const [cloned1, cloned2] = cloneResponse(res);\n    // We are dynamically rendering including dev mode. We want to return the\n    // response to the caller as soon as possible because it might stream over a\n    // very long time.\n    const cacheSetPromise = cloned1.arrayBuffer().then(async (arrayBuffer)=>{\n        const bodyBuffer = Buffer.from(arrayBuffer);\n        const fetchedData = {\n            headers: Object.fromEntries(cloned1.headers.entries()),\n            body: bodyBuffer.toString('base64'),\n            status: cloned1.status,\n            url: cloned1.url\n        };\n        serverComponentsHmrCache == null ? void 0 : serverComponentsHmrCache.set(cacheKey, fetchedData);\n        if (incrementalCacheContext) {\n            await incrementalCache.set(cacheKey, {\n                kind: CachedRouteKind.FETCH,\n                data: fetchedData,\n                revalidate\n            }, incrementalCacheContext);\n        }\n    }).catch((error)=>console.warn(`Failed to set fetch cache`, input, error)).finally(handleUnlock);\n    const pendingRevalidateKey = `cache-set-${cacheKey}`;\n    workStore.pendingRevalidates ??= {};\n    if (pendingRevalidateKey in workStore.pendingRevalidates) {\n        // there is already a pending revalidate entry that we need to await to\n        // avoid race conditions\n        await workStore.pendingRevalidates[pendingRevalidateKey];\n    }\n    workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(()=>{\n        var _workStore_pendingRevalidates;\n        // If the pending revalidate is not present in the store, then we have\n        // nothing to delete.\n        if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {\n            return;\n        }\n        delete workStore.pendingRevalidates[pendingRevalidateKey];\n    });\n    return cloned2;\n}\nexport function createPatchedFetcher(originFetch, { workAsyncStorage, workUnitAsyncStorage }) {\n    // Create the patched fetch function.\n    const patched = async function fetch(input, init) {\n        var _init_method, _init_next;\n        let url;\n        try {\n            url = new URL(input instanceof Request ? input.url : input);\n            url.username = '';\n            url.password = '';\n        } catch  {\n            // Error caused by malformed URL should be handled by native fetch\n            url = undefined;\n        }\n        const fetchUrl = (url == null ? void 0 : url.href) ?? '';\n        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || 'GET';\n        // Do create a new span trace for internal fetches in the\n        // non-verbose mode.\n        const isInternal = (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) === true;\n        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1';\n        // We don't track fetch metrics for internal fetches\n        // so it's not critical that we have a start time, as it won't be recorded.\n        // This is to workaround a flaky issue where performance APIs might\n        // not be available and will require follow-up investigation.\n        const fetchStart = isInternal ? undefined : performance.timeOrigin + performance.now();\n        const workStore = workAsyncStorage.getStore();\n        const workUnitStore = workUnitAsyncStorage.getStore();\n        let cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null;\n        if (cacheSignal) {\n            cacheSignal.beginRead();\n        }\n        const result = getTracer().trace(isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch, {\n            hideSpan,\n            kind: SpanKind.CLIENT,\n            spanName: [\n                'fetch',\n                method,\n                fetchUrl\n            ].filter(Boolean).join(' '),\n            attributes: {\n                'http.url': fetchUrl,\n                'http.method': method,\n                'net.peer.name': url == null ? void 0 : url.hostname,\n                'net.peer.port': (url == null ? void 0 : url.port) || undefined\n            }\n        }, async ()=>{\n            var _getRequestMeta;\n            // If this is an internal fetch, we should not do any special treatment.\n            if (isInternal) {\n                return originFetch(input, init);\n            }\n            // If the workStore is not available, we can't do any\n            // special treatment of fetch, therefore fallback to the original\n            // fetch implementation.\n            if (!workStore) {\n                return originFetch(input, init);\n            }\n            // We should also fallback to the original fetch implementation if we\n            // are in draft mode, it does not constitute a static generation.\n            if (workStore.isDraftMode) {\n                return originFetch(input, init);\n            }\n            const isRequestInput = input && typeof input === 'object' && typeof input.method === 'string';\n            const getRequestMeta = (field)=>{\n                // If request input is present but init is not, retrieve from input first.\n                const value = init == null ? void 0 : init[field];\n                return value || (isRequestInput ? input[field] : null);\n            };\n            let finalRevalidate = undefined;\n            const getNextField = (field)=>{\n                var _init_next, _init_next1, _input_next;\n                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== 'undefined' ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;\n            };\n            // RequestInit doesn't keep extra fields e.g. next so it's\n            // only available if init is used separate\n            const originalFetchRevalidate = getNextField('revalidate');\n            let currentFetchRevalidate = originalFetchRevalidate;\n            const tags = validateTags(getNextField('tags') || [], `fetch ${input.toString()}`);\n            let revalidateStore;\n            if (workUnitStore) {\n                switch(workUnitStore.type){\n                    case 'prerender':\n                    case 'prerender-runtime':\n                    // TODO: Stop accumulating tags in client prerender. (fallthrough)\n                    case 'prerender-client':\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'cache':\n                    case 'private-cache':\n                        revalidateStore = workUnitStore;\n                        break;\n                    case 'request':\n                    case 'unstable-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            if (revalidateStore) {\n                if (Array.isArray(tags)) {\n                    // Collect tags onto parent caches or parent prerenders.\n                    const collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);\n                    for (const tag of tags){\n                        if (!collectedTags.includes(tag)) {\n                            collectedTags.push(tag);\n                        }\n                    }\n                }\n            }\n            const implicitTags = workUnitStore == null ? void 0 : workUnitStore.implicitTags;\n            let pageFetchCacheMode = workStore.fetchCache;\n            if (workUnitStore) {\n                switch(workUnitStore.type){\n                    case 'unstable-cache':\n                        // Inside unstable-cache we treat it the same as force-no-store on\n                        // the page.\n                        pageFetchCacheMode = 'force-no-store';\n                        break;\n                    case 'prerender':\n                    case 'prerender-client':\n                    case 'prerender-runtime':\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'request':\n                    case 'cache':\n                    case 'private-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            const isUsingNoStore = !!workStore.isUnstableNoStore;\n            let currentFetchCacheConfig = getRequestMeta('cache');\n            let cacheReason = '';\n            let cacheWarning;\n            if (typeof currentFetchCacheConfig === 'string' && typeof currentFetchRevalidate !== 'undefined') {\n                // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.\n                const isConflictingRevalidate = // revalidate: 0 and cache: force-cache\n                currentFetchCacheConfig === 'force-cache' && currentFetchRevalidate === 0 || // revalidate: >0 or revalidate: false and cache: no-store\n                currentFetchCacheConfig === 'no-store' && (currentFetchRevalidate > 0 || currentFetchRevalidate === false);\n                if (isConflictingRevalidate) {\n                    cacheWarning = `Specified \"cache: ${currentFetchCacheConfig}\" and \"revalidate: ${currentFetchRevalidate}\", only one should be specified.`;\n                    currentFetchCacheConfig = undefined;\n                    currentFetchRevalidate = undefined;\n                }\n            }\n            const hasExplicitFetchCacheOptOut = // fetch config itself signals not to cache\n            currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store' || // the fetch isn't explicitly caching and the segment level cache config signals not to cache\n            // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.\n            pageFetchCacheMode === 'force-no-store' || pageFetchCacheMode === 'only-no-store';\n            // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,\n            // we shouldn't consider caching the fetch. This is because the `dynamic` cache\n            // is considered a \"top-level\" cache mode, whereas something like `fetchCache` is more\n            // fine-grained. Top-level modes are responsible for setting reasonable defaults for the\n            // other configurations.\n            const noFetchConfigAndForceDynamic = !pageFetchCacheMode && !currentFetchCacheConfig && !currentFetchRevalidate && workStore.forceDynamic;\n            if (// force-cache was specified without a revalidate value. We set the revalidate value to false\n            // which will signal the cache to not revalidate\n            currentFetchCacheConfig === 'force-cache' && typeof currentFetchRevalidate === 'undefined') {\n                currentFetchRevalidate = false;\n            } else if (hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic) {\n                currentFetchRevalidate = 0;\n            }\n            if (currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store') {\n                cacheReason = `cache: ${currentFetchCacheConfig}`;\n            }\n            finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);\n            const _headers = getRequestMeta('headers');\n            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === 'function' ? _headers : new Headers(_headers || {});\n            const hasUnCacheableHeader = initHeaders.get('authorization') || initHeaders.get('cookie');\n            const isUnCacheableMethod = ![\n                'get',\n                'head'\n            ].includes(((_getRequestMeta = getRequestMeta('method')) == null ? void 0 : _getRequestMeta.toLowerCase()) || 'get');\n            /**\n         * We automatically disable fetch caching under the following conditions:\n         * - Fetch cache configs are not set. Specifically:\n         *    - A page fetch cache mode is not set (export const fetchCache=...)\n         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))\n         *      or the fetch cache mode is set to 'default'\n         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))\n         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())\n         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)\n         */ const hasNoExplicitCacheConfig = // eslint-disable-next-line eqeqeq\n            pageFetchCacheMode == undefined && // eslint-disable-next-line eqeqeq\n            (currentFetchCacheConfig == undefined || // when considering whether to opt into the default \"no-cache\" fetch semantics,\n            // a \"default\" cache config should be treated the same as no cache config\n            currentFetchCacheConfig === 'default') && // eslint-disable-next-line eqeqeq\n            currentFetchRevalidate == undefined;\n            let autoNoCache = Boolean((hasUnCacheableHeader || isUnCacheableMethod) && (revalidateStore == null ? void 0 : revalidateStore.revalidate) === 0);\n            let isImplicitBuildTimeCache = false;\n            if (!autoNoCache && hasNoExplicitCacheConfig) {\n                // We don't enable automatic no-cache behavior during build-time\n                // prerendering so that we can still leverage the fetch cache between\n                // export workers.\n                if (workStore.isBuildTimePrerendering) {\n                    isImplicitBuildTimeCache = true;\n                } else {\n                    autoNoCache = true;\n                }\n            }\n            // If we have no cache config, and we're in Dynamic I/O prerendering,\n            // it'll be a dynamic call. We don't have to issue that dynamic call.\n            if (hasNoExplicitCacheConfig && workUnitStore !== undefined) {\n                switch(workUnitStore.type){\n                    case 'prerender':\n                    case 'prerender-runtime':\n                    // While we don't want to do caching in the client scope we know the\n                    // fetch will be dynamic for cacheComponents so we may as well avoid the\n                    // call here. (fallthrough)\n                    case 'prerender-client':\n                        if (cacheSignal) {\n                            cacheSignal.endRead();\n                            cacheSignal = null;\n                        }\n                        return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                    case 'request':\n                        if (process.env.NODE_ENV === 'development' && workUnitStore.stagedRendering) {\n                            if (cacheSignal) {\n                                cacheSignal.endRead();\n                                cacheSignal = null;\n                            }\n                            await workUnitStore.stagedRendering.waitForStage(RenderStage.Dynamic);\n                        }\n                        break;\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'cache':\n                    case 'private-cache':\n                    case 'unstable-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            switch(pageFetchCacheMode){\n                case 'force-no-store':\n                    {\n                        cacheReason = 'fetchCache = force-no-store';\n                        break;\n                    }\n                case 'only-no-store':\n                    {\n                        if (currentFetchCacheConfig === 'force-cache' || typeof finalRevalidate !== 'undefined' && finalRevalidate > 0) {\n                            throw Object.defineProperty(new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E448\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheReason = 'fetchCache = only-no-store';\n                        break;\n                    }\n                case 'only-cache':\n                    {\n                        if (currentFetchCacheConfig === 'no-store') {\n                            throw Object.defineProperty(new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E521\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        break;\n                    }\n                case 'force-cache':\n                    {\n                        if (typeof currentFetchRevalidate === 'undefined' || currentFetchRevalidate === 0) {\n                            cacheReason = 'fetchCache = force-cache';\n                            finalRevalidate = INFINITE_CACHE;\n                        }\n                        break;\n                    }\n                case 'default-cache':\n                case 'default-no-store':\n                case 'auto':\n                case undefined:\n                    break;\n                default:\n                    pageFetchCacheMode;\n            }\n            if (typeof finalRevalidate === 'undefined') {\n                if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {\n                    finalRevalidate = INFINITE_CACHE;\n                    cacheReason = 'fetchCache = default-cache';\n                } else if (pageFetchCacheMode === 'default-no-store') {\n                    finalRevalidate = 0;\n                    cacheReason = 'fetchCache = default-no-store';\n                } else if (isUsingNoStore) {\n                    finalRevalidate = 0;\n                    cacheReason = 'noStore call';\n                } else if (autoNoCache) {\n                    finalRevalidate = 0;\n                    cacheReason = 'auto no cache';\n                } else {\n                    // TODO: should we consider this case an invariant?\n                    cacheReason = 'auto cache';\n                    finalRevalidate = revalidateStore ? revalidateStore.revalidate : INFINITE_CACHE;\n                }\n            } else if (!cacheReason) {\n                cacheReason = `revalidate: ${finalRevalidate}`;\n            }\n            if (// when force static is configured we don't bail from\n            // `revalidate: 0` values\n            !(workStore.forceStatic && finalRevalidate === 0) && // we don't consider autoNoCache to switch to dynamic for ISR\n            !autoNoCache && // If the revalidate value isn't currently set or the value is less\n            // than the current revalidate value, we should update the revalidate\n            // value.\n            revalidateStore && finalRevalidate < revalidateStore.revalidate) {\n                // If we were setting the revalidate value to 0, we should try to\n                // postpone instead first.\n                if (finalRevalidate === 0) {\n                    if (workUnitStore) {\n                        switch(workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                if (cacheSignal) {\n                                    cacheSignal.endRead();\n                                    cacheSignal = null;\n                                }\n                                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                            case 'request':\n                                if (process.env.NODE_ENV === 'development' && workUnitStore.stagedRendering) {\n                                    if (cacheSignal) {\n                                        cacheSignal.endRead();\n                                        cacheSignal = null;\n                                    }\n                                    await workUnitStore.stagedRendering.waitForStage(RenderStage.Dynamic);\n                                }\n                                break;\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                                break;\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    markCurrentScopeAsDynamic(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);\n                }\n                // We only want to set the revalidate store's revalidate time if it\n                // was explicitly set for the fetch call, i.e.\n                // originalFetchRevalidate.\n                if (revalidateStore && originalFetchRevalidate === finalRevalidate) {\n                    revalidateStore.revalidate = finalRevalidate;\n                }\n            }\n            const isCacheableRevalidate = typeof finalRevalidate === 'number' && finalRevalidate > 0;\n            let cacheKey;\n            const { incrementalCache } = workStore;\n            let isHmrRefresh = false;\n            let serverComponentsHmrCache;\n            if (workUnitStore) {\n                switch(workUnitStore.type){\n                    case 'request':\n                    case 'cache':\n                    case 'private-cache':\n                        isHmrRefresh = workUnitStore.isHmrRefresh ?? false;\n                        serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache;\n                        break;\n                    case 'prerender':\n                    case 'prerender-client':\n                    case 'prerender-runtime':\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'unstable-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            if (incrementalCache && (isCacheableRevalidate || serverComponentsHmrCache)) {\n                try {\n                    cacheKey = await incrementalCache.generateCacheKey(fetchUrl, isRequestInput ? input : init);\n                } catch (err) {\n                    console.error(`Failed to generate cache key for`, input);\n                }\n            }\n            const fetchIdx = workStore.nextFetchId ?? 1;\n            workStore.nextFetchId = fetchIdx + 1;\n            let handleUnlock = ()=>{};\n            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{\n                const requestInputFields = [\n                    'cache',\n                    'credentials',\n                    'headers',\n                    'integrity',\n                    'keepalive',\n                    'method',\n                    'mode',\n                    'redirect',\n                    'referrer',\n                    'referrerPolicy',\n                    'window',\n                    'duplex',\n                    // don't pass through signal when revalidating\n                    ...isStale ? [] : [\n                        'signal'\n                    ]\n                ];\n                if (isRequestInput) {\n                    const reqInput = input;\n                    const reqOptions = {\n                        body: reqInput._ogBody || reqInput.body\n                    };\n                    for (const field of requestInputFields){\n                        // @ts-expect-error custom fields\n                        reqOptions[field] = reqInput[field];\n                    }\n                    input = new Request(reqInput.url, reqOptions);\n                } else if (init) {\n                    const { _ogBody, body, signal, ...otherInput } = init;\n                    init = {\n                        ...otherInput,\n                        body: _ogBody || body,\n                        signal: isStale ? undefined : signal\n                    };\n                }\n                // add metadata to init without editing the original\n                const clonedInit = {\n                    ...init,\n                    next: {\n                        ...init == null ? void 0 : init.next,\n                        fetchType: 'origin',\n                        fetchIdx\n                    }\n                };\n                return originFetch(input, clonedInit).then(async (res)=>{\n                    if (!isStale && fetchStart) {\n                        trackFetchMetric(workStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason: cacheReasonOverride || cacheReason,\n                            cacheStatus: finalRevalidate === 0 || cacheReasonOverride ? 'skip' : 'miss',\n                            cacheWarning,\n                            status: res.status,\n                            method: clonedInit.method || 'GET'\n                        });\n                    }\n                    if (res.status === 200 && incrementalCache && cacheKey && (isCacheableRevalidate || serverComponentsHmrCache)) {\n                        const normalizedRevalidate = finalRevalidate >= INFINITE_CACHE ? CACHE_ONE_YEAR : finalRevalidate;\n                        const incrementalCacheConfig = isCacheableRevalidate ? {\n                            fetchCache: true,\n                            fetchUrl,\n                            fetchIdx,\n                            tags,\n                            isImplicitBuildTimeCache\n                        } : undefined;\n                        switch(workUnitStore == null ? void 0 : workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                return createCachedPrerenderResponse(res, cacheKey, incrementalCacheConfig, incrementalCache, normalizedRevalidate, handleUnlock);\n                            case 'request':\n                                if (process.env.NODE_ENV === 'development' && workUnitStore.stagedRendering && workUnitStore.cacheSignal) {\n                                    // We're filling caches for a staged render,\n                                    // so we need to wait for the response to finish instead of streaming.\n                                    return createCachedPrerenderResponse(res, cacheKey, incrementalCacheConfig, incrementalCache, normalizedRevalidate, handleUnlock);\n                                }\n                            // fallthrough\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                            case undefined:\n                                return createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheConfig, incrementalCache, serverComponentsHmrCache, normalizedRevalidate, input, handleUnlock);\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    // we had response that we determined shouldn't be cached so we return it\n                    // and don't cache it. This also needs to unlock the cache lock we acquired.\n                    await handleUnlock();\n                    return res;\n                }).catch((error)=>{\n                    handleUnlock();\n                    throw error;\n                });\n            };\n            let cacheReasonOverride;\n            let isForegroundRevalidate = false;\n            let isHmrRefreshCache = false;\n            if (cacheKey && incrementalCache) {\n                let cachedFetchData;\n                if (isHmrRefresh && serverComponentsHmrCache) {\n                    cachedFetchData = serverComponentsHmrCache.get(cacheKey);\n                    isHmrRefreshCache = true;\n                }\n                if (isCacheableRevalidate && !cachedFetchData) {\n                    handleUnlock = await incrementalCache.lock(cacheKey);\n                    const entry = workStore.isOnDemandRevalidate ? null : await incrementalCache.get(cacheKey, {\n                        kind: IncrementalCacheKind.FETCH,\n                        revalidate: finalRevalidate,\n                        fetchUrl,\n                        fetchIdx,\n                        tags,\n                        softTags: implicitTags == null ? void 0 : implicitTags.tags\n                    });\n                    if (hasNoExplicitCacheConfig && workUnitStore) {\n                        switch(workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                // We sometimes use the cache to dedupe fetches that do not\n                                // specify a cache configuration. In these cases we want to\n                                // make sure we still exclude them from prerenders if\n                                // cacheComponents is on so we introduce an artificial task boundary\n                                // here.\n                                await getTimeoutBoundary();\n                                break;\n                            case 'request':\n                                if (process.env.NODE_ENV === 'development' && workUnitStore.stagedRendering) {\n                                    await workUnitStore.stagedRendering.waitForStage(RenderStage.Dynamic);\n                                }\n                                break;\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                                break;\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    if (entry) {\n                        await handleUnlock();\n                    } else {\n                        // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n                        // TODO: it seems like we also hit this after revalidates in dev?\n                        cacheReasonOverride = 'cache-control: no-cache (hard refresh)';\n                    }\n                    if ((entry == null ? void 0 : entry.value) && entry.value.kind === CachedRouteKind.FETCH) {\n                        // when stale and is revalidating we wait for fresh data\n                        // so the revalidated entry has the updated data\n                        if (workStore.isStaticGeneration && entry.isStale) {\n                            isForegroundRevalidate = true;\n                        } else {\n                            if (entry.isStale) {\n                                workStore.pendingRevalidates ??= {};\n                                if (!workStore.pendingRevalidates[cacheKey]) {\n                                    const pendingRevalidate = doOriginalFetch(true).then(async (response)=>({\n                                            body: await response.arrayBuffer(),\n                                            headers: response.headers,\n                                            status: response.status,\n                                            statusText: response.statusText\n                                        })).finally(()=>{\n                                        workStore.pendingRevalidates ??= {};\n                                        delete workStore.pendingRevalidates[cacheKey || ''];\n                                    });\n                                    // Attach the empty catch here so we don't get a \"unhandled\n                                    // promise rejection\" warning.\n                                    pendingRevalidate.catch(console.error);\n                                    workStore.pendingRevalidates[cacheKey] = pendingRevalidate;\n                                }\n                            }\n                            cachedFetchData = entry.value.data;\n                        }\n                    }\n                }\n                if (cachedFetchData) {\n                    if (fetchStart) {\n                        trackFetchMetric(workStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason,\n                            cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',\n                            cacheWarning,\n                            status: cachedFetchData.status || 200,\n                            method: (init == null ? void 0 : init.method) || 'GET'\n                        });\n                    }\n                    const response = new Response(Buffer.from(cachedFetchData.body, 'base64'), {\n                        headers: cachedFetchData.headers,\n                        status: cachedFetchData.status\n                    });\n                    Object.defineProperty(response, 'url', {\n                        value: cachedFetchData.url\n                    });\n                    return response;\n                }\n            }\n            if ((workStore.isStaticGeneration || process.env.NODE_ENV === 'development' && process.env.__NEXT_CACHE_COMPONENTS && workUnitStore && // eslint-disable-next-line no-restricted-syntax\n            workUnitStore.type === 'request' && workUnitStore.stagedRendering) && init && typeof init === 'object') {\n                const { cache } = init;\n                // Delete `cache` property as Cloudflare Workers will throw an error\n                if (isEdgeRuntime) delete init.cache;\n                if (cache === 'no-store') {\n                    // If enabled, we should bail out of static generation.\n                    if (workUnitStore) {\n                        switch(workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                if (cacheSignal) {\n                                    cacheSignal.endRead();\n                                    cacheSignal = null;\n                                }\n                                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                            case 'request':\n                                if (process.env.NODE_ENV === 'development' && workUnitStore.stagedRendering) {\n                                    if (cacheSignal) {\n                                        cacheSignal.endRead();\n                                        cacheSignal = null;\n                                    }\n                                    await workUnitStore.stagedRendering.waitForStage(RenderStage.Dynamic);\n                                }\n                                break;\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                                break;\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    markCurrentScopeAsDynamic(workStore, workUnitStore, `no-store fetch ${input} ${workStore.route}`);\n                }\n                const hasNextConfig = 'next' in init;\n                const { next = {} } = init;\n                if (typeof next.revalidate === 'number' && revalidateStore && next.revalidate < revalidateStore.revalidate) {\n                    if (next.revalidate === 0) {\n                        // If enabled, we should bail out of static generation.\n                        if (workUnitStore) {\n                            switch(workUnitStore.type){\n                                case 'prerender':\n                                case 'prerender-client':\n                                case 'prerender-runtime':\n                                    return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                                case 'request':\n                                    if (process.env.NODE_ENV === 'development' && workUnitStore.stagedRendering) {\n                                        await workUnitStore.stagedRendering.waitForStage(RenderStage.Dynamic);\n                                    }\n                                    break;\n                                case 'cache':\n                                case 'private-cache':\n                                case 'unstable-cache':\n                                case 'prerender-legacy':\n                                case 'prerender-ppr':\n                                    break;\n                                default:\n                                    workUnitStore;\n                            }\n                        }\n                        markCurrentScopeAsDynamic(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);\n                    }\n                    if (!workStore.forceStatic || next.revalidate !== 0) {\n                        revalidateStore.revalidate = next.revalidate;\n                    }\n                }\n                if (hasNextConfig) delete init.next;\n            }\n            // if we are revalidating the whole page via time or on-demand and\n            // the fetch cache entry is stale we should still de-dupe the\n            // origin hit if it's a cache-able entry\n            if (cacheKey && isForegroundRevalidate) {\n                const pendingRevalidateKey = cacheKey;\n                workStore.pendingRevalidates ??= {};\n                let pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];\n                if (pendingRevalidate) {\n                    const revalidatedResult = await pendingRevalidate;\n                    return new Response(revalidatedResult.body, {\n                        headers: revalidatedResult.headers,\n                        status: revalidatedResult.status,\n                        statusText: revalidatedResult.statusText\n                    });\n                }\n                // We used to just resolve the Response and clone it however for\n                // static generation with cacheComponents we need the response to be able to\n                // be resolved in a microtask and cloning the response will never have\n                // a body that can resolve in a microtask in node (as observed through\n                // experimentation) So instead we await the body and then when it is\n                // available we construct manually cloned Response objects with the\n                // body as an ArrayBuffer. This will be resolvable in a microtask\n                // making it compatible with cacheComponents.\n                const pendingResponse = doOriginalFetch(true, cacheReasonOverride)// We're cloning the response using this utility because there\n                // exists a bug in the undici library around response cloning.\n                // See the following pull request for more details:\n                // https://github.com/vercel/next.js/pull/73274\n                .then(cloneResponse);\n                pendingRevalidate = pendingResponse.then(async (responses)=>{\n                    const response = responses[0];\n                    return {\n                        body: await response.arrayBuffer(),\n                        headers: response.headers,\n                        status: response.status,\n                        statusText: response.statusText\n                    };\n                }).finally(()=>{\n                    var _workStore_pendingRevalidates;\n                    // If the pending revalidate is not present in the store, then\n                    // we have nothing to delete.\n                    if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {\n                        return;\n                    }\n                    delete workStore.pendingRevalidates[pendingRevalidateKey];\n                });\n                // Attach the empty catch here so we don't get a \"unhandled promise\n                // rejection\" warning\n                pendingRevalidate.catch(()=>{});\n                workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;\n                return pendingResponse.then((responses)=>responses[1]);\n            } else {\n                return doOriginalFetch(false, cacheReasonOverride);\n            }\n        });\n        if (cacheSignal) {\n            try {\n                return await result;\n            } finally{\n                if (cacheSignal) {\n                    cacheSignal.endRead();\n                }\n            }\n        }\n        return result;\n    };\n    // Attach the necessary properties to the patched fetch function.\n    // We don't use this to determine if the fetch function has been patched,\n    // but for external consumers to determine if the fetch function has been\n    // patched.\n    patched.__nextPatched = true;\n    patched.__nextGetStaticStore = ()=>workAsyncStorage;\n    patched._nextOriginalFetch = originFetch;\n    globalThis[NEXT_PATCH_SYMBOL] = true;\n    // Assign the function name also as a name property, so that it's preserved\n    // even when mangling is enabled.\n    Object.defineProperty(patched, 'name', {\n        value: 'fetch',\n        writable: false\n    });\n    return patched;\n}\n// we patch fetch to collect cache information used for\n// determining if a page is static or not\nexport function patchFetch(options) {\n    // If we've already patched fetch, we should not patch it again.\n    if (isFetchPatched()) return;\n    // Grab the original fetch function. We'll attach this so we can use it in\n    // the patched fetch function.\n    const original = createDedupeFetch(globalThis.fetch);\n    // Set the global fetch to the patched fetch.\n    globalThis.fetch = createPatchedFetcher(original, options);\n}\nlet currentTimeoutBoundary = null;\nfunction getTimeoutBoundary() {\n    if (!currentTimeoutBoundary) {\n        currentTimeoutBoundary = new Promise((r)=>{\n            setTimeout(()=>{\n                currentTimeoutBoundary = null;\n                r();\n            }, 0);\n        });\n    }\n    return currentTimeoutBoundary;\n}\n\n//# sourceMappingURL=patch-fetch.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6943, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/esm/server/app-render/entry-base.js"],"sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createTemporaryReferenceSet, renderToReadableStream, decodeReply, decodeAction, decodeFormState } from 'react-server-dom-webpack/server';\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { prerender } from 'react-server-dom-webpack/static';\n// TODO: Just re-export `* as ReactServer`\nexport { captureOwnerStack, createElement, Fragment } from 'react';\nexport { default as LayoutRouter } from '../../client/components/layout-router';\nexport { default as RenderFromTemplateContext } from '../../client/components/render-from-template-context';\nexport { workAsyncStorage } from '../app-render/work-async-storage.external';\nexport { workUnitAsyncStorage } from './work-unit-async-storage.external';\nexport { actionAsyncStorage } from '../app-render/action-async-storage.external';\nexport { ClientPageRoot } from '../../client/components/client-page';\nexport { ClientSegmentRoot } from '../../client/components/client-segment';\nexport { createServerSearchParamsForServerPage, createPrerenderSearchParamsForClientPage } from '../request/search-params';\nexport { createServerParamsForServerSegment, createPrerenderParamsForClientSegment } from '../request/params';\nexport * as serverHooks from '../../client/components/hooks-server-context';\nexport { HTTPAccessFallbackBoundary } from '../../client/components/http-access-fallback/error-boundary';\nexport { createMetadataComponents } from '../../lib/metadata/metadata';\nexport { RootLayoutBoundary } from '../../lib/framework/boundary-components';\nexport { preloadStyle, preloadFont, preconnect } from './rsc/preloads';\nexport { Postpone } from './rsc/postpone';\nexport { taintObjectReference } from './rsc/taint';\nexport { collectSegmentData } from './collect-segment-data';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { patchFetch as _patchFetch } from '../lib/patch-fetch';\nlet SegmentViewNode = ()=>null;\nlet SegmentViewStateNode = ()=>null;\nif (process.env.NODE_ENV === 'development') {\n    const mod = require('../../next-devtools/userspace/app/segment-explorer-node');\n    SegmentViewNode = mod.SegmentViewNode;\n    SegmentViewStateNode = mod.SegmentViewStateNode;\n}\n// hot-reloader modules are not bundled so we need to inject `__next__clear_chunk_cache__`\n// into globalThis from this file which is bundled.\nif (process.env.TURBOPACK) {\n    globalThis.__next__clear_chunk_cache__ = __turbopack_clear_chunk_cache__;\n} else {\n    // Webpack does not have chunks on the server\n    globalThis.__next__clear_chunk_cache__ = null;\n}\n// patchFetch makes use of APIs such as `React.unstable_postpone` which are only available\n// in the experimental channel of React, so export it from here so that it comes from the bundled runtime\nexport function patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n// Development only\nexport { SegmentViewNode, SegmentViewStateNode };\n\n//# sourceMappingURL=entry-base.js.map"],"names":[],"mappings":"AAAA,6DAA6D;;;;;;;;;AAC7D;AACA,6DAA6D;AAC7D;AACA,0CAA0C;AAC1C;AACA;;;;;;;;;;;;;;;;AAIA;AACA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAI,kBAAkB,IAAI;AAC1B,IAAI,uBAAuB,IAAI;AAC/B,wCAA4C;IACxC,MAAM;;;;;IACN,kBAAkB,IAAI,eAAe;IACrC,uBAAuB,IAAI,oBAAoB;AACnD;AACA,0FAA0F;AAC1F,mDAAmD;AACnD,wCAA2B;IACvB,WAAW,2BAA2B;AAC1C;;AAMO,SAAS;IACZ,OAAO,IAAA,0MAAW,EAAC;QACf;QACA;IACJ;AACJ;;CAIA,sCAAsC","ignoreList":[0]}}]
}