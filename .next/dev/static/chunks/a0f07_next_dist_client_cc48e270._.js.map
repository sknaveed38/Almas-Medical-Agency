{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/asset-prefix.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getAssetPrefix\", {\n    enumerable: true,\n    get: function() {\n        return getAssetPrefix;\n    }\n});\nconst _invarianterror = require(\"../shared/lib/invariant-error\");\nfunction getAssetPrefix() {\n    const currentScript = document.currentScript;\n    if (!(currentScript instanceof HTMLScriptElement)) {\n        throw Object.defineProperty(new _invarianterror.InvariantError(`Expected document.currentScript to be a <script> element. Received ${currentScript} instead.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E783\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { pathname } = new URL(currentScript.src);\n    const nextIndex = pathname.indexOf('/_next/');\n    if (nextIndex === -1) {\n        throw Object.defineProperty(new _invarianterror.InvariantError(`Expected document.currentScript src to contain '/_next/'. Received ${currentScript.src} instead.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E784\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return pathname.slice(0, nextIndex);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=asset-prefix.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS;IACL,MAAM,gBAAgB,SAAS,aAAa;IAC5C,IAAI,CAAC,CAAC,yBAAyB,iBAAiB,GAAG;QAC/C,MAAM,OAAO,cAAc,CAAC,IAAI,gBAAgB,cAAc,CAAC,CAAC,mEAAmE,EAAE,cAAc,SAAS,CAAC,GAAG,qBAAqB;YACjL,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,IAAI,cAAc,GAAG;IAC9C,MAAM,YAAY,SAAS,OAAO,CAAC;IACnC,IAAI,cAAc,CAAC,GAAG;QAClB,MAAM,OAAO,cAAc,CAAC,IAAI,gBAAgB,cAAc,CAAC,CAAC,mEAAmE,EAAE,cAAc,GAAG,CAAC,SAAS,CAAC,GAAG,qBAAqB;YACrL,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,OAAO,SAAS,KAAK,CAAC,GAAG;AAC7B;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/set-attributes-from-props.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"setAttributesFromProps\", {\n    enumerable: true,\n    get: function() {\n        return setAttributesFromProps;\n    }\n});\nconst DOMAttributeNames = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv',\n    noModule: 'noModule'\n};\nconst ignoreProps = [\n    'onLoad',\n    'onReady',\n    'dangerouslySetInnerHTML',\n    'children',\n    'onError',\n    'strategy',\n    'stylesheets'\n];\nfunction isBooleanScriptAttribute(attr) {\n    return [\n        'async',\n        'defer',\n        'noModule'\n    ].includes(attr);\n}\nfunction setAttributesFromProps(el, props) {\n    for (const [p, value] of Object.entries(props)){\n        if (!props.hasOwnProperty(p)) continue;\n        if (ignoreProps.includes(p)) continue;\n        // we don't render undefined props to the DOM\n        if (value === undefined) {\n            continue;\n        }\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n            // Correctly assign boolean script attributes\n            // https://github.com/vercel/next.js/pull/20748\n            ;\n            el[attr] = !!value;\n        } else {\n            el.setAttribute(attr, String(value));\n        }\n        // Remove falsy non-zero boolean attributes so they are correctly interpreted\n        // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n        if (value === false || el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr) && (!value || value === 'false')) {\n            // Call setAttribute before, as we need to set and unset the attribute to override force async:\n            // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n            el.setAttribute(attr, '');\n            el.removeAttribute(attr);\n        }\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=set-attributes-from-props.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,0BAA0B;IACrD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,oBAAoB;IACtB,eAAe;IACf,WAAW;IACX,SAAS;IACT,WAAW;IACX,UAAU;AACd;AACA,MAAM,cAAc;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACD,SAAS,yBAAyB,IAAI;IAClC,OAAO;QACH;QACA;QACA;KACH,CAAC,QAAQ,CAAC;AACf;AACA,SAAS,uBAAuB,EAAE,EAAE,KAAK;IACrC,KAAK,MAAM,CAAC,GAAG,MAAM,IAAI,OAAO,OAAO,CAAC,OAAO;QAC3C,IAAI,CAAC,MAAM,cAAc,CAAC,IAAI;QAC9B,IAAI,YAAY,QAAQ,CAAC,IAAI;QAC7B,6CAA6C;QAC7C,IAAI,UAAU,WAAW;YACrB;QACJ;QACA,MAAM,OAAO,iBAAiB,CAAC,EAAE,IAAI,EAAE,WAAW;QAClD,IAAI,GAAG,OAAO,KAAK,YAAY,yBAAyB,OAAO;YAC3D,6CAA6C;YAC7C,+CAA+C;;YAE/C,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC;QACjB,OAAO;YACH,GAAG,YAAY,CAAC,MAAM,OAAO;QACjC;QACA,6EAA6E;QAC7E,2GAA2G;QAC3G,IAAI,UAAU,SAAS,GAAG,OAAO,KAAK,YAAY,yBAAyB,SAAS,CAAC,CAAC,SAAS,UAAU,OAAO,GAAG;YAC/G,+FAA+F;YAC/F,2EAA2E;YAC3E,GAAG,YAAY,CAAC,MAAM;YACtB,GAAG,eAAe,CAAC;QACvB;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-bootstrap.js"],"sourcesContent":["/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"appBootstrap\", {\n    enumerable: true,\n    get: function() {\n        return appBootstrap;\n    }\n});\nconst _assetprefix = require(\"./asset-prefix\");\nconst _setattributesfromprops = require(\"./set-attributes-from-props\");\nconst version = \"16.0.10\";\nwindow.next = {\n    version,\n    appDir: true\n};\nfunction loadScriptsInSequence(scripts, hydrate) {\n    if (!scripts || !scripts.length) {\n        return hydrate();\n    }\n    return scripts.reduce((promise, [src, props])=>{\n        return promise.then(()=>{\n            return new Promise((resolve, reject)=>{\n                const el = document.createElement('script');\n                if (props) {\n                    (0, _setattributesfromprops.setAttributesFromProps)(el, props);\n                }\n                if (src) {\n                    el.src = src;\n                    el.onload = ()=>resolve();\n                    el.onerror = reject;\n                } else if (props) {\n                    el.innerHTML = props.children;\n                    setTimeout(resolve);\n                }\n                document.head.appendChild(el);\n            });\n        });\n    }, Promise.resolve()).catch((err)=>{\n        console.error(err);\n    // Still try to hydrate even if there's an error.\n    }).then(()=>{\n        hydrate();\n    });\n}\nfunction appBootstrap(hydrate) {\n    const assetPrefix = (0, _assetprefix.getAssetPrefix)();\n    loadScriptsInSequence(self.__next_s, ()=>{\n        // If the static shell is being debugged, skip hydration if the\n        // `__nextppronly` query is present. This is only enabled when the\n        // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n        // set to `1`. Otherwise the following is optimized out.\n        if (process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1') {\n            const search = new URLSearchParams(window.location.search);\n            if (search.get('__nextppronly') === 'fallback' || search.get('__nextppronly') === '1') {\n                console.warn(`Skipping hydration due to __nextppronly=${search.get('__nextppronly')}`);\n                return;\n            }\n        }\n        hydrate(assetPrefix);\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-bootstrap.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC,GAqDW;AArDR;AACJ,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,gBAAgB;IAC3C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,UAAU;AAChB,OAAO,IAAI,GAAG;IACV;IACA,QAAQ;AACZ;AACA,SAAS,sBAAsB,OAAO,EAAE,OAAO;IAC3C,IAAI,CAAC,WAAW,CAAC,QAAQ,MAAM,EAAE;QAC7B,OAAO;IACX;IACA,OAAO,QAAQ,MAAM,CAAC,CAAC,SAAS,CAAC,KAAK,MAAM;QACxC,OAAO,QAAQ,IAAI,CAAC;YAChB,OAAO,IAAI,QAAQ,CAAC,SAAS;gBACzB,MAAM,KAAK,SAAS,aAAa,CAAC;gBAClC,IAAI,OAAO;oBACP,CAAC,GAAG,wBAAwB,sBAAsB,EAAE,IAAI;gBAC5D;gBACA,IAAI,KAAK;oBACL,GAAG,GAAG,GAAG;oBACT,GAAG,MAAM,GAAG,IAAI;oBAChB,GAAG,OAAO,GAAG;gBACjB,OAAO,IAAI,OAAO;oBACd,GAAG,SAAS,GAAG,MAAM,QAAQ;oBAC7B,WAAW;gBACf;gBACA,SAAS,IAAI,CAAC,WAAW,CAAC;YAC9B;QACJ;IACJ,GAAG,QAAQ,OAAO,IAAI,KAAK,CAAC,CAAC;QACzB,QAAQ,KAAK,CAAC;IAClB,iDAAiD;IACjD,GAAG,IAAI,CAAC;QACJ;IACJ;AACJ;AACA,SAAS,aAAa,OAAO;IACzB,MAAM,cAAc,CAAC,GAAG,aAAa,cAAc;IACnD,sBAAsB,KAAK,QAAQ,EAAE;QACjC,+DAA+D;QAC/D,kEAAkE;QAClE,uEAAuE;QACvE,wDAAwD;QACxD;;QAOA,QAAQ;IACZ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/react-client-callbacks/report-global-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"reportGlobalError\", {\n    enumerable: true,\n    get: function() {\n        return reportGlobalError;\n    }\n});\nconst reportGlobalError = typeof reportError === 'function' ? // emulating an uncaught JavaScript error.\nreportError : (error)=>{\n    // TODO: Dispatch error event\n    globalThis.console.error(error);\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=report-global-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,qBAAqB;IAChD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,oBAAoB,OAAO,gBAAgB,aACjD,cAAc,CAAC;IACX,6BAA6B;IAC7B,WAAW,OAAO,CAAC,KAAK,CAAC;AAC7B;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js"],"sourcesContent":["// This module can be shared between both pages router and app router\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    isRecoverableError: null,\n    onRecoverableError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isRecoverableError: function() {\n        return isRecoverableError;\n    },\n    onRecoverableError: function() {\n        return onRecoverableError;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(require(\"../../lib/is-error\"));\nconst _reportglobalerror = require(\"./report-global-error\");\nconst recoverableErrors = new WeakSet();\nfunction isRecoverableError(error) {\n    return recoverableErrors.has(error);\n}\nconst onRecoverableError = (error)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    let cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    if (process.env.NODE_ENV !== 'production') {\n        const { decorateDevError } = require('../../next-devtools/userspace/app/errors/stitched-error');\n        const causeError = decorateDevError(cause);\n        recoverableErrors.add(causeError);\n        cause = causeError;\n    }\n    (0, _reportglobalerror.reportGlobalError)(cause);\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=on-recoverable-error.js.map"],"names":[],"mappings":"AAAA,qEAAqE;AAoC7D;AAnCR;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,oBAAoB;AACxB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,oBAAoB;QAChB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,WAAW,WAAW,GAAG,yBAAyB,CAAC;AACzD,MAAM;AACN,MAAM,oBAAoB,IAAI;AAC9B,SAAS,mBAAmB,KAAK;IAC7B,OAAO,kBAAkB,GAAG,CAAC;AACjC;AACA,MAAM,qBAAqB,CAAC;IACxB,sDAAsD;IACtD,IAAI,QAAQ,CAAC,GAAG,SAAS,OAAO,EAAE,UAAU,WAAW,QAAQ,MAAM,KAAK,GAAG;IAC7E,6EAA6E;IAC7E,IAAI,CAAC,GAAG,cAAc,mBAAmB,EAAE,QAAQ;IACnD,wCAA2C;QACvC,MAAM,EAAE,gBAAgB,EAAE;QAC1B,MAAM,aAAa,iBAAiB;QACpC,kBAAkB,GAAG,CAAC;QACtB,QAAQ;IACZ;IACA,CAAC,GAAG,mBAAmB,iBAAiB,EAAE;AAC9C;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    HTTPAccessErrorStatus: null,\n    HTTP_ERROR_FALLBACK_ERROR_CODE: null,\n    getAccessFallbackErrorTypeByStatus: null,\n    getAccessFallbackHTTPStatus: null,\n    isHTTPAccessFallbackError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    HTTPAccessErrorStatus: function() {\n        return HTTPAccessErrorStatus;\n    },\n    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {\n        return HTTP_ERROR_FALLBACK_ERROR_CODE;\n    },\n    getAccessFallbackErrorTypeByStatus: function() {\n        return getAccessFallbackErrorTypeByStatus;\n    },\n    getAccessFallbackHTTPStatus: function() {\n        return getAccessFallbackHTTPStatus;\n    },\n    isHTTPAccessFallbackError: function() {\n        return isHTTPAccessFallbackError;\n    }\n});\nconst HTTPAccessErrorStatus = {\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    UNAUTHORIZED: 401\n};\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));\nconst HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';\nfunction isHTTPAccessFallbackError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const [prefix, httpStatus] = error.digest.split(';');\n    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));\n}\nfunction getAccessFallbackHTTPStatus(error) {\n    const httpStatus = error.digest.split(';')[1];\n    return Number(httpStatus);\n}\nfunction getAccessFallbackErrorTypeByStatus(status) {\n    switch(status){\n        case 401:\n            return 'unauthorized';\n        case 403:\n            return 'forbidden';\n        case 404:\n            return 'not-found';\n        default:\n            return;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=http-access-fallback.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,uBAAuB;IACvB,gCAAgC;IAChC,oCAAoC;IACpC,6BAA6B;IAC7B,2BAA2B;AAC/B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,uBAAuB;QACnB,OAAO;IACX;IACA,gCAAgC;QAC5B,OAAO;IACX;IACA,oCAAoC;QAChC,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,2BAA2B;QACvB,OAAO;IACX;AACJ;AACA,MAAM,wBAAwB;IAC1B,WAAW;IACX,WAAW;IACX,cAAc;AAClB;AACA,MAAM,gBAAgB,IAAI,IAAI,OAAO,MAAM,CAAC;AAC5C,MAAM,iCAAiC;AACvC,SAAS,0BAA0B,KAAK;IACpC,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,YAAY,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,UAAU;QACzG,OAAO;IACX;IACA,MAAM,CAAC,QAAQ,WAAW,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC;IAChD,OAAO,WAAW,kCAAkC,cAAc,GAAG,CAAC,OAAO;AACjF;AACA,SAAS,4BAA4B,KAAK;IACtC,MAAM,aAAa,MAAM,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAO,OAAO;AAClB;AACA,SAAS,mCAAmC,MAAM;IAC9C,OAAO;QACH,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI;IACR;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect-status-code.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"RedirectStatusCode\", {\n    enumerable: true,\n    get: function() {\n        return RedirectStatusCode;\n    }\n});\nvar RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {\n    RedirectStatusCode[RedirectStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\n    RedirectStatusCode[RedirectStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    RedirectStatusCode[RedirectStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    return RedirectStatusCode;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect-status-code.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,IAAI,qBAAqB,WAAW,GAAG,SAAS,kBAAkB;IAC9D,kBAAkB,CAAC,kBAAkB,CAAC,WAAW,GAAG,IAAI,GAAG;IAC3D,kBAAkB,CAAC,kBAAkB,CAAC,oBAAoB,GAAG,IAAI,GAAG;IACpE,kBAAkB,CAAC,kBAAkB,CAAC,oBAAoB,GAAG,IAAI,GAAG;IACpE,OAAO;AACX,EAAE,CAAC;AAEH,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    REDIRECT_ERROR_CODE: null,\n    RedirectType: null,\n    isRedirectError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    REDIRECT_ERROR_CODE: function() {\n        return REDIRECT_ERROR_CODE;\n    },\n    RedirectType: function() {\n        return RedirectType;\n    },\n    isRedirectError: function() {\n        return isRedirectError;\n    }\n});\nconst _redirectstatuscode = require(\"./redirect-status-code\");\nconst REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';\nvar RedirectType = /*#__PURE__*/ function(RedirectType) {\n    RedirectType[\"push\"] = \"push\";\n    RedirectType[\"replace\"] = \"replace\";\n    return RedirectType;\n}({});\nfunction isRedirectError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const digest = error.digest.split(';');\n    const [errorCode, type] = digest;\n    const destination = digest.slice(2, -2).join(';');\n    const status = digest.at(-2);\n    const statusCode = Number(status);\n    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,qBAAqB;IACrB,cAAc;IACd,iBAAiB;AACrB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,qBAAqB;QACjB,OAAO;IACX;IACA,cAAc;QACV,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,sBAAsB;AAC5B,IAAI,eAAe,WAAW,GAAG,SAAS,YAAY;IAClD,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,UAAU,GAAG;IAC1B,OAAO;AACX,EAAE,CAAC;AACH,SAAS,gBAAgB,KAAK;IAC1B,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,YAAY,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,UAAU;QACzG,OAAO;IACX;IACA,MAAM,SAAS,MAAM,MAAM,CAAC,KAAK,CAAC;IAClC,MAAM,CAAC,WAAW,KAAK,GAAG;IAC1B,MAAM,cAAc,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;IAC7C,MAAM,SAAS,OAAO,EAAE,CAAC,CAAC;IAC1B,MAAM,aAAa,OAAO;IAC1B,OAAO,cAAc,uBAAuB,CAAC,SAAS,aAAa,SAAS,MAAM,KAAK,OAAO,gBAAgB,YAAY,CAAC,MAAM,eAAe,cAAc,oBAAoB,kBAAkB;AACxM;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/is-next-router-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isNextRouterError\", {\n    enumerable: true,\n    get: function() {\n        return isNextRouterError;\n    }\n});\nconst _httpaccessfallback = require(\"./http-access-fallback/http-access-fallback\");\nconst _redirecterror = require(\"./redirect-error\");\nfunction isNextRouterError(error) {\n    return (0, _redirecterror.isRedirectError)(error) || (0, _httpaccessfallback.isHTTPAccessFallbackError)(error);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=is-next-router-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,qBAAqB;IAChD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,kBAAkB,KAAK;IAC5B,OAAO,CAAC,GAAG,eAAe,eAAe,EAAE,UAAU,CAAC,GAAG,oBAAoB,yBAAyB,EAAE;AAC5G;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/lib/console.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    formatConsoleArgs: null,\n    parseConsoleArgs: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatConsoleArgs: function() {\n        return formatConsoleArgs;\n    },\n    parseConsoleArgs: function() {\n        return parseConsoleArgs;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(require(\"../../lib/is-error\"));\nfunction formatObject(arg, depth) {\n    switch(typeof arg){\n        case 'object':\n            if (arg === null) {\n                return 'null';\n            } else if (Array.isArray(arg)) {\n                let result = '[';\n                if (depth < 1) {\n                    for(let i = 0; i < arg.length; i++){\n                        if (result !== '[') {\n                            result += ',';\n                        }\n                        if (Object.prototype.hasOwnProperty.call(arg, i)) {\n                            result += formatObject(arg[i], depth + 1);\n                        }\n                    }\n                } else {\n                    result += arg.length > 0 ? '...' : '';\n                }\n                result += ']';\n                return result;\n            } else if (arg instanceof Error) {\n                return arg + '';\n            } else {\n                const keys = Object.keys(arg);\n                let result = '{';\n                if (depth < 1) {\n                    for(let i = 0; i < keys.length; i++){\n                        const key = keys[i];\n                        const desc = Object.getOwnPropertyDescriptor(arg, 'key');\n                        if (desc && !desc.get && !desc.set) {\n                            const jsonKey = JSON.stringify(key);\n                            if (jsonKey !== '\"' + key + '\"') {\n                                result += jsonKey + ': ';\n                            } else {\n                                result += key + ': ';\n                            }\n                            result += formatObject(desc.value, depth + 1);\n                        }\n                    }\n                } else {\n                    result += keys.length > 0 ? '...' : '';\n                }\n                result += '}';\n                return result;\n            }\n        case 'string':\n            return JSON.stringify(arg);\n        case 'number':\n        case 'bigint':\n        case 'boolean':\n        case 'symbol':\n        case 'undefined':\n        case 'function':\n        default:\n            return String(arg);\n    }\n}\nfunction formatConsoleArgs(args) {\n    let message;\n    let idx;\n    if (typeof args[0] === 'string') {\n        message = args[0];\n        idx = 1;\n    } else {\n        message = '';\n        idx = 0;\n    }\n    let result = '';\n    let startQuote = false;\n    for(let i = 0; i < message.length; ++i){\n        const char = message[i];\n        if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n            result += char;\n            continue;\n        }\n        const code = message[++i];\n        switch(code){\n            case 'c':\n                {\n                    // TODO: We should colorize with HTML instead of turning into a string.\n                    // Ignore for now.\n                    result = startQuote ? `${result}]` : `[${result}`;\n                    startQuote = !startQuote;\n                    idx++;\n                    break;\n                }\n            case 'O':\n            case 'o':\n                {\n                    result += formatObject(args[idx++], 0);\n                    break;\n                }\n            case 'd':\n            case 'i':\n                {\n                    result += parseInt(args[idx++], 10);\n                    break;\n                }\n            case 'f':\n                {\n                    result += parseFloat(args[idx++]);\n                    break;\n                }\n            case 's':\n                {\n                    result += String(args[idx++]);\n                    break;\n                }\n            default:\n                result += '%' + code;\n        }\n    }\n    for(; idx < args.length; idx++){\n        result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0);\n    }\n    return result;\n}\nfunction parseConsoleArgs(args) {\n    // See\n    // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n    //\n    // Logs replayed from the server look like this:\n    // [\n    //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n    //   \"background: #e6e6e6; ...\",\n    //   \" Server \", // can also be e.g. \" Prerender \"\n    //   \"\",\n    //   Error,\n    //   \"The above error occurred in the <Page> component.\",\n    //   ...\n    // ]\n    if (args.length > 3 && typeof args[0] === 'string' && args[0].startsWith('%c%s%c') && typeof args[1] === 'string' && typeof args[2] === 'string' && typeof args[3] === 'string') {\n        const environmentName = args[2];\n        const maybeError = args[4];\n        return {\n            environmentName: environmentName.trim(),\n            error: (0, _iserror.default)(maybeError) ? maybeError : null\n        };\n    }\n    return {\n        environmentName: null,\n        error: null\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=console.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 628, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-globals.js"],"sourcesContent":["// imports polyfill from `@next/polyfill-module` after build.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nrequire(\"../build/polyfills/polyfill-module\");\n// Only setup devtools in development\nif (process.env.NODE_ENV !== 'production') {\n    require('../next-devtools/userspace/app/app-dev-overlay-setup');\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-globals.js.map"],"names":[],"mappings":"AAAA,6DAA6D;AAOzD;AANJ;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;;AAEA,qCAAqC;AACrC,wCAA2C;;AAE3C;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 650, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/navigation-untracked.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"useUntrackedPathname\", {\n    enumerable: true,\n    get: function() {\n        return useUntrackedPathname;\n    }\n});\nconst _react = require(\"react\");\nconst _hooksclientcontextsharedruntime = require(\"../../shared/lib/hooks-client-context.shared-runtime\");\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */ function hasFallbackRouteParams() {\n    if (typeof window === 'undefined') {\n        // AsyncLocalStorage should not be included in the client bundle.\n        const { workUnitAsyncStorage } = require('../../server/app-render/work-unit-async-storage.external');\n        const workUnitStore = workUnitAsyncStorage.getStore();\n        if (!workUnitStore) return false;\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n                const fallbackParams = workUnitStore.fallbackRouteParams;\n                return fallbackParams ? fallbackParams.size > 0 : false;\n            case 'prerender-legacy':\n            case 'request':\n            case 'prerender-runtime':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n        return false;\n    }\n    return false;\n}\nfunction useUntrackedPathname() {\n    // If there are any unknown route parameters we would typically throw\n    // an error, but this internal method allows us to return a null value instead\n    // for components that do not propagate the pathname to the static shell (like\n    // the error boundary).\n    if (hasFallbackRouteParams()) {\n        return null;\n    }\n    // This shouldn't cause any issues related to conditional rendering because\n    // the environment will be consistent for the render.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation-untracked.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,wBAAwB;IACnD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN;;;;;;CAMC,GAAG,SAAS;IACT,IAAI,OAAO,WAAW,aAAa;QAC/B,iEAAiE;QACjE,MAAM,EAAE,oBAAoB,EAAE;;;;;QAC9B,MAAM,gBAAgB,qBAAqB,QAAQ;QACnD,IAAI,CAAC,eAAe,OAAO;QAC3B,OAAO,cAAc,IAAI;YACrB,KAAK;YACL,KAAK;YACL,KAAK;gBACD,MAAM,iBAAiB,cAAc,mBAAmB;gBACxD,OAAO,iBAAiB,eAAe,IAAI,GAAG,IAAI;YACtD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACD;YACJ;gBACI;QACR;QACA,OAAO;IACX;IACA,OAAO;AACX;AACA,SAAS;IACL,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAI,0BAA0B;QAC1B,OAAO;IACX;IACA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,OAAO,CAAC,GAAG,OAAO,UAAU,EAAE,iCAAiC,eAAe;AAClF;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 721, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createHrefFromUrl\", {\n    enumerable: true,\n    get: function() {\n        return createHrefFromUrl;\n    }\n});\nfunction createHrefFromUrl(url, includeHash = true) {\n    return url.pathname + url.search + (includeHash ? url.hash : '');\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=create-href-from-url.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,qBAAqB;IAChD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,kBAAkB,GAAG,EAAE,cAAc,IAAI;IAC9C,OAAO,IAAI,QAAQ,GAAG,IAAI,MAAM,GAAG,CAAC,cAAc,IAAI,IAAI,GAAG,EAAE;AACnE;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/nav-failure-handler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    handleHardNavError: null,\n    useNavFailureHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleHardNavError: function() {\n        return handleHardNavError;\n    },\n    useNavFailureHandler: function() {\n        return useNavFailureHandler;\n    }\n});\nconst _react = require(\"react\");\nconst _createhreffromurl = require(\"./router-reducer/create-href-from-url\");\nfunction handleHardNavError(error) {\n    if (error && typeof window !== 'undefined' && window.next.__pendingUrl && (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== (0, _createhreffromurl.createHrefFromUrl)(window.next.__pendingUrl)) {\n        console.error(`Error occurred during navigation, falling back to hard navigation`, error);\n        window.location.href = window.next.__pendingUrl.toString();\n        return true;\n    }\n    return false;\n}\nfunction useNavFailureHandler() {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n        // this if is only for DCE of the feature flag not conditional\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            const uncaughtExceptionHandler = (evt)=>{\n                const error = 'reason' in evt ? evt.reason : evt.error;\n                // if we have an unhandled exception/rejection during\n                // a navigation we fall back to a hard navigation to\n                // attempt recovering to a good state\n                handleHardNavError(error);\n            };\n            window.addEventListener('unhandledrejection', uncaughtExceptionHandler);\n            window.addEventListener('error', uncaughtExceptionHandler);\n            return ()=>{\n                window.removeEventListener('error', uncaughtExceptionHandler);\n                window.removeEventListener('unhandledrejection', uncaughtExceptionHandler);\n            };\n        }, []);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=nav-failure-handler.js.map"],"names":[],"mappings":"AAiCQ;AAjCR;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,sBAAsB;AAC1B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,mBAAmB,KAAK;IAC7B,IAAI,SAAS,OAAO,WAAW,eAAe,OAAO,IAAI,CAAC,YAAY,IAAI,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,IAAI,IAAI,OAAO,QAAQ,CAAC,IAAI,OAAO,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,OAAO,IAAI,CAAC,YAAY,GAAG;QACxN,QAAQ,KAAK,CAAC,CAAC,iEAAiE,CAAC,EAAE;QACnF,OAAO,QAAQ,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,YAAY,CAAC,QAAQ;QACxD,OAAO;IACX;IACA,OAAO;AACX;AACA,SAAS;IACL;;AAmBJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/handle-isr-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"HandleISRError\", {\n    enumerable: true,\n    get: function() {\n        return HandleISRError;\n    }\n});\nconst workAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/work-async-storage.external').workAsyncStorage : undefined;\nfunction HandleISRError({ error }) {\n    if (workAsyncStorage) {\n        const store = workAsyncStorage.getStore();\n        if (store?.isStaticGeneration) {\n            if (error) {\n                console.error(error);\n            }\n            throw error;\n        }\n    }\n    return null;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=handle-isr-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,mBAAmB,OAAO,WAAW,cAAc;;;;KAA+D,gBAAgB,GAAG;AAC3I,SAAS,eAAe,EAAE,KAAK,EAAE;IAC7B,IAAI,kBAAkB;QAClB,MAAM,QAAQ,iBAAiB,QAAQ;QACvC,IAAI,OAAO,oBAAoB;YAC3B,IAAI,OAAO;gBACP,QAAQ,KAAK,CAAC;YAClB;YACA,MAAM;QACV;IACJ;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 829, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/error-boundary.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ErrorBoundary: null,\n    ErrorBoundaryHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ErrorBoundary: function() {\n        return ErrorBoundary;\n    },\n    ErrorBoundaryHandler: function() {\n        return ErrorBoundaryHandler;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_default._(require(\"react\"));\nconst _navigationuntracked = require(\"./navigation-untracked\");\nconst _isnextroutererror = require(\"./is-next-router-error\");\nconst _navfailurehandler = require(\"./nav-failure-handler\");\nconst _handleisrerror = require(\"./handle-isr-error\");\nconst _isbot = require(\"../../shared/lib/router/utils/is-bot\");\nconst isBotUserAgent = typeof window !== 'undefined' && (0, _isbot.isBot)(window.navigator.userAgent);\nclass ErrorBoundaryHandler extends _react.default.Component {\n    constructor(props){\n        super(props), this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null,\n            previousPathname: this.props.pathname\n        };\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _isnextroutererror.isNextRouterError)(error)) {\n            // Re-throw if an expected internal Next.js router error occurs\n            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n            throw error;\n        }\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        const { error } = state;\n        // if we encounter an error while\n        // a navigation is pending we shouldn't render\n        // the error boundary and instead should fallback\n        // to a hard navigation to attempt recovering\n        if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n            if (error && (0, _navfailurehandler.handleHardNavError)(error)) {\n                // clear error so we don't render anything\n                return {\n                    error: null,\n                    previousPathname: props.pathname\n                };\n            }\n        }\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.error) {\n            return {\n                error: null,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            error: state.error,\n            previousPathname: props.pathname\n        };\n    }\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n    render() {\n        //When it's bot request, segment level error boundary will keep rendering the children,\n        // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n        if (this.state.error && !isBotUserAgent) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {\n                        error: this.state.error\n                    }),\n                    this.props.errorStyles,\n                    this.props.errorScripts,\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(this.props.errorComponent, {\n                        error: this.state.error,\n                        reset: this.reset\n                    })\n                ]\n            });\n        }\n        return this.props.children;\n    }\n}\nfunction ErrorBoundary({ errorComponent, errorStyles, errorScripts, children }) {\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these errors can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    if (errorComponent) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryHandler, {\n            pathname: pathname,\n            errorComponent: errorComponent,\n            errorStyles: errorStyles,\n            errorScripts: errorScripts,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=error-boundary.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 960, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/builtin/global-error.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\n\"default\", {\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n});\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _handleisrerror = require(\"../handle-isr-error\");\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: 'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        height: '100vh',\n        textAlign: 'center',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center'\n    },\n    text: {\n        fontSize: '14px',\n        fontWeight: 400,\n        lineHeight: '28px',\n        margin: '0 8px'\n    }\n};\nfunction DefaultGlobalError({ error }) {\n    const digest = error?.digest;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"html\", {\n        id: \"__next_error__\",\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"head\", {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"body\", {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {\n                        error: error\n                    }),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n                        style: styles.error,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"h2\", {\n                                    style: styles.text,\n                                    children: [\n                                        \"Application error: a \",\n                                        digest ? 'server' : 'client',\n                                        \"-side exception has occurred while loading \",\n                                        window.location.hostname,\n                                        \" (see the\",\n                                        ' ',\n                                        digest ? 'server logs' : 'browser console',\n                                        \" for more information).\"\n                                    ]\n                                }),\n                                digest ? /*#__PURE__*/ (0, _jsxruntime.jsx)(\"p\", {\n                                    style: styles.text,\n                                    children: `Digest: ${digest}`\n                                }) : null\n                            ]\n                        })\n                    })\n                ]\n            })\n        ]\n    });\n}\nconst _default = DefaultGlobalError;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=global-error.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SACtB,2CAA2C;AAC3C,WAAW;IACP,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,SAAS;IACX,OAAO;QACH,0FAA0F;QAC1F,YAAY;QACZ,QAAQ;QACR,WAAW;QACX,SAAS;QACT,eAAe;QACf,YAAY;QACZ,gBAAgB;IACpB;IACA,MAAM;QACF,UAAU;QACV,YAAY;QACZ,YAAY;QACZ,QAAQ;IACZ;AACJ;AACA,SAAS,mBAAmB,EAAE,KAAK,EAAE;IACjC,MAAM,SAAS,OAAO;IACtB,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,IAAI,EAAE,QAAQ;QAC/C,IAAI;QACJ,UAAU;YACN,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,QAAQ,CAAC;YAC5C,WAAW,GAAG,CAAC,GAAG,YAAY,IAAI,EAAE,QAAQ;gBACxC,UAAU;oBACN,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,gBAAgB,cAAc,EAAE;wBAC/D,OAAO;oBACX;oBACA,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,OAAO;wBACtC,OAAO,OAAO,KAAK;wBACnB,UAAU,WAAW,GAAG,CAAC,GAAG,YAAY,IAAI,EAAE,OAAO;4BACjD,UAAU;gCACN,WAAW,GAAG,CAAC,GAAG,YAAY,IAAI,EAAE,MAAM;oCACtC,OAAO,OAAO,IAAI;oCAClB,UAAU;wCACN;wCACA,SAAS,WAAW;wCACpB;wCACA,OAAO,QAAQ,CAAC,QAAQ;wCACxB;wCACA;wCACA,SAAS,gBAAgB;wCACzB;qCACH;gCACL;gCACA,SAAS,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,KAAK;oCAC7C,OAAO,OAAO,IAAI;oCAClB,UAAU,CAAC,QAAQ,EAAE,QAAQ;gCACjC,KAAK;6BACR;wBACL;oBACJ;iBACH;YACL;SACH;IACL;AACJ;AACA,MAAM,WAAW;AAEjB,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 1042, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/dev/runtime-error-handler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"RuntimeErrorHandler\", {\n    enumerable: true,\n    get: function() {\n        return RuntimeErrorHandler;\n    }\n});\nconst RuntimeErrorHandler = {\n    hadRuntimeError: false\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=runtime-error-handler.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,uBAAuB;IAClD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,sBAAsB;IACxB,iBAAiB;AACrB;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 1065, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/not-found.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"notFound\", {\n    enumerable: true,\n    get: function() {\n        return notFound;\n    }\n});\nconst _httpaccessfallback = require(\"./http-access-fallback/http-access-fallback\");\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};404`;\nfunction notFound() {\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=not-found.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,YAAY;IACvC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN;;;;;;;;;;;;;CAaC,GAAG,MAAM,SAAS,GAAG,oBAAoB,8BAA8B,CAAC,IAAI,CAAC;AAC9E,SAAS;IACL,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,SAAS,qBAAqB;QACxE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,MAAM,GAAG;IACf,MAAM;AACV;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 1109, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js"],"sourcesContent":["// This file is only used in app router due to the specific error state handling.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    onCaughtError: null,\n    onUncaughtError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _isnextroutererror = require(\"../components/is-next-router-error\");\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _reportglobalerror = require(\"./report-global-error\");\nconst _errorboundary = require(\"../components/error-boundary\");\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(require(\"../components/builtin/global-error\"));\nconst devToolErrorMod = process.env.NODE_ENV !== 'production' ? require('../../next-devtools/userspace/app/errors') : {\n    decorateDevError: (error)=>error,\n    handleClientError: ()=>{},\n    originConsoleError: console.error.bind(console)\n};\nfunction onCaughtError(thrownValue, errorInfo) {\n    const errorBoundaryComponent = errorInfo.errorBoundary?.constructor;\n    let isImplicitErrorBoundary;\n    if (process.env.NODE_ENV !== 'production') {\n        const { AppDevOverlayErrorBoundary } = require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary');\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _globalerror.default;\n    // Skip the segment explorer triggered error\n    if (process.env.NODE_ENV !== 'production') {\n        const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = require('../../next-devtools/userspace/app/segment-explorer-node');\n        if (thrownValue instanceof Error && thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {\n            return;\n        }\n    }\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(thrownValue);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (process.env.NODE_ENV !== 'production') {\n        const errorBoundaryName = // read react component displayName\n        errorBoundaryComponent?.displayName || errorBoundaryComponent?.name || 'Unknown';\n        const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1];\n        // Match chrome or safari stack trace\n        const matches = // regex to match the function name in the stack trace\n        // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`;\n        const componentErrorMessage = componentThatErroredName ? `The above error occurred in the <${componentThatErroredName}> component.` : `The above error occurred in one of your components.`;\n        const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`;\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // Log and report the error with location but without modifying the error stack\n        devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation);\n        devToolErrorMod.handleClientError(error);\n    } else {\n        devToolErrorMod.originConsoleError(thrownValue);\n    }\n}\nfunction onUncaughtError(thrownValue) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (process.env.NODE_ENV !== 'production') {\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(error);\n    } else {\n        (0, _reportglobalerror.reportGlobalError)(thrownValue);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=error-boundary-callbacks.js.map"],"names":[],"mappings":"AAAA,iFAAiF;AA6BzD;AA5BxB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,iBAAiB;AACrB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,eAAe,WAAW,GAAG,yBAAyB,CAAC;AAC7D,MAAM,kBAAkB,2LAA8F;AAKtH,SAAS,cAAc,WAAW,EAAE,SAAS;IACzC,MAAM,yBAAyB,UAAU,aAAa,EAAE;IACxD,IAAI;IACJ,wCAA2C;QACvC,MAAM,EAAE,0BAA0B,EAAE;QACpC,0BAA0B,2BAA2B;IACzD;IACA,0BAA0B,2BAA2B,2BAA2B,eAAe,oBAAoB,IAAI,UAAU,aAAa,CAAC,KAAK,CAAC,cAAc,KAAK,aAAa,OAAO;IAC5L,4CAA4C;IAC5C,wCAA2C;QACvC,MAAM,EAAE,wCAAwC,EAAE;QAClD,IAAI,uBAAuB,SAAS,YAAY,OAAO,KAAK,0CAA0C;YAClG;QACJ;IACJ;IACA,IAAI,yBAAyB;QACzB,6EAA6E;QAC7E,uDAAuD;QACvD,6DAA6D;QAC7D,OAAO,gBAAgB;IAC3B;IACA,6EAA6E;IAC7E,IAAI,CAAC,GAAG,cAAc,mBAAmB,EAAE,gBAAgB,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,cAAc;IACnH,wCAA2C;QACvC,MAAM,oBACN,wBAAwB,eAAe,wBAAwB,QAAQ;QACvE,MAAM,4BAA4B,WAAW,gBAAgB,MAAM,KAAK,CAAC,EAAE;QAC3E,qCAAqC;QACrC,MAAM,UACN,qGAAqG;QACrG,gGAAgG;QAChG,2BAA2B,MAAM,4BAA4B,EAAE;QAC/D,MAAM,2BAA2B,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,EAAE,IAAI;QAC7D,iIAAiI;QACjI,MAAM,uBAAuB,CAAC,uBAAuB,EAAE,kBAAkB,iBAAiB,CAAC;QAC3F,MAAM,wBAAwB,uCAA2B,CAAC,iCAAiC,EAAE,yBAAyB,YAAY,CAAC,GAAG;QACtI,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,EAAE,sBAAsB;QACxE,MAAM,QAAQ,gBAAgB,gBAAgB,CAAC;QAC/C,+EAA+E;QAC/E,gBAAgB,kBAAkB,CAAC,YAAY,aAAa;QAC5D,gBAAgB,iBAAiB,CAAC;IACtC;;AAGJ;AACA,SAAS,gBAAgB,WAAW;IAChC,6EAA6E;IAC7E,IAAI,CAAC,GAAG,cAAc,mBAAmB,EAAE,gBAAgB,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,cAAc;IACnH,wCAA2C;QACvC,MAAM,QAAQ,gBAAgB,gBAAgB,CAAC;QAC/C,oFAAoF;QACpF,CAAC,GAAG,mBAAmB,iBAAiB,EAAE;IAC9C;;AAGJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 1203, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HMR_REFRESH: null,\n    ACTION_NAVIGATE: null,\n    ACTION_REFRESH: null,\n    ACTION_RESTORE: null,\n    ACTION_SERVER_ACTION: null,\n    ACTION_SERVER_PATCH: null,\n    PrefetchKind: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n    return PrefetchKind;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=router-reducer-types.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,iBAAiB;IACjB,gBAAgB;IAChB,gBAAgB;IAChB,sBAAsB;IACtB,qBAAqB;IACrB,cAAc;AAClB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;IACA,cAAc;QACV,OAAO;IACX;AACJ;AACA,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB,MAAM,iBAAiB;AACvB,MAAM,sBAAsB;AAC5B,MAAM,qBAAqB;AAC3B,MAAM,uBAAuB;AAC7B,IAAI,eAAe,WAAW,GAAG,SAAS,YAAY;IAClD,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,OAAO,GAAG;IACvB,YAAY,CAAC,YAAY,GAAG;IAC5B,OAAO;AACX,EAAE,CAAC;AAEH,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 1267, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/use-action-queue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    dispatchAppRouterAction: null,\n    useActionQueue: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dispatchAppRouterAction: function() {\n        return dispatchAppRouterAction;\n    },\n    useActionQueue: function() {\n        return useActionQueue;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _isthenable = require(\"../../shared/lib/is-thenable\");\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch = null;\nfunction dispatchAppRouterAction(action) {\n    if (dispatch === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    dispatch(action);\n}\nconst __DEV__ = process.env.NODE_ENV !== 'production';\nconst promisesWithDebugInfo = __DEV__ ? new WeakMap() : null;\nfunction useActionQueue(actionQueue) {\n    const [state, setState] = _react.default.useState(actionQueue.state);\n    // Because of a known issue that requires to decode Flight streams inside the\n    // render phase, we have to be a bit clever and assign the dispatch method to\n    // a module-level variable upon initialization. The useState hook in this\n    // module only exists to synchronize state that lives outside of React.\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\n    // this is conceptually how we're modeling the app router state, despite the\n    // weird implementation details.\n    if (process.env.NODE_ENV !== 'production') {\n        const { useAppDevRenderingIndicator } = require('../../next-devtools/userspace/use-app-dev-rendering-indicator');\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const appDevRenderingIndicator = useAppDevRenderingIndicator();\n        dispatch = (action)=>{\n            appDevRenderingIndicator(()=>{\n                actionQueue.dispatch(action, setState);\n            });\n        };\n    } else {\n        dispatch = (action)=>actionQueue.dispatch(action, setState);\n    }\n    // When navigating to a non-prefetched route, then App Router state will be\n    // blocked until the server responds. We need to transfer the `_debugInfo`\n    // from the underlying Flight response onto the top-level promise that is\n    // passed to React (via `use`) so that the latency is accurately represented\n    // in the React DevTools.\n    const stateWithDebugInfo = (0, _react.useMemo)(()=>{\n        if (!__DEV__) {\n            return state;\n        }\n        if ((0, _isthenable.isThenable)(state)) {\n            // useMemo can't be used to cache a Promise since the memoized value is thrown\n            // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n            let promiseWithDebugInfo = promisesWithDebugInfo.get(state);\n            if (promiseWithDebugInfo === undefined) {\n                const debugInfo = [];\n                promiseWithDebugInfo = Promise.resolve(state).then((asyncState)=>{\n                    if (asyncState.debugInfo !== null) {\n                        debugInfo.push(...asyncState.debugInfo);\n                    }\n                    return asyncState;\n                });\n                promiseWithDebugInfo._debugInfo = debugInfo;\n                promisesWithDebugInfo.set(state, promiseWithDebugInfo);\n            }\n            return promiseWithDebugInfo;\n        }\n        return state;\n    }, [\n        state\n    ]);\n    return (0, _isthenable.isThenable)(stateWithDebugInfo) ? (0, _react.use)(stateWithDebugInfo) : stateWithDebugInfo;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=use-action-queue.js.map"],"names":[],"mappings":"AAuCgB;AAvChB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,yBAAyB;IACzB,gBAAgB;AACpB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,yBAAyB;QACrB,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,SAAS,WAAW,GAAG,0BAA0B,CAAC;AACxD,MAAM;AACN,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAI,WAAW;AACf,SAAS,wBAAwB,MAAM;IACnC,IAAI,aAAa,MAAM;QACnB,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,4EAA4E,qBAAqB;YACnI,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,SAAS;AACb;AACA,MAAM,UAAU,oDAAyB;AACzC,MAAM,wBAAwB,uCAAU,IAAI,YAAY;AACxD,SAAS,eAAe,WAAW;IAC/B,MAAM,CAAC,OAAO,SAAS,GAAG,OAAO,OAAO,CAAC,QAAQ,CAAC,YAAY,KAAK;IACnE,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,wCAA2C;QACvC,MAAM,EAAE,2BAA2B,EAAE;QACrC,sDAAsD;QACtD,MAAM,2BAA2B;QACjC,WAAW,CAAC;YACR,yBAAyB;gBACrB,YAAY,QAAQ,CAAC,QAAQ;YACjC;QACJ;IACJ;;IAGA,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,4EAA4E;IAC5E,yBAAyB;IACzB,MAAM,qBAAqB,CAAC,GAAG,OAAO,OAAO,EAAE;QAC3C;;QAGA,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,QAAQ;YACpC,8EAA8E;YAC9E,kFAAkF;YAClF,IAAI,uBAAuB,sBAAsB,GAAG,CAAC;YACrD,IAAI,yBAAyB,WAAW;gBACpC,MAAM,YAAY,EAAE;gBACpB,uBAAuB,QAAQ,OAAO,CAAC,OAAO,IAAI,CAAC,CAAC;oBAChD,IAAI,WAAW,SAAS,KAAK,MAAM;wBAC/B,UAAU,IAAI,IAAI,WAAW,SAAS;oBAC1C;oBACA,OAAO;gBACX;gBACA,qBAAqB,UAAU,GAAG;gBAClC,sBAAsB,GAAG,CAAC,OAAO;YACrC;YACA,OAAO;QACX;QACA,OAAO;IACX,GAAG;QACC;KACH;IACD,OAAO,CAAC,GAAG,YAAY,UAAU,EAAE,sBAAsB,CAAC,GAAG,OAAO,GAAG,EAAE,sBAAsB;AACnG;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 1371, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-call-server.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"callServer\", {\n    enumerable: true,\n    get: function() {\n        return callServer;\n    }\n});\nconst _react = require(\"react\");\nconst _routerreducertypes = require(\"./components/router-reducer/router-reducer-types\");\nconst _useactionqueue = require(\"./components/use-action-queue\");\nasync function callServer(actionId, actionArgs) {\n    return new Promise((resolve, reject)=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_SERVER_ACTION,\n                actionId,\n                actionArgs,\n                resolve,\n                reject\n            });\n        });\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-call-server.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,eAAe,WAAW,QAAQ,EAAE,UAAU;IAC1C,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB,CAAC,GAAG,OAAO,eAAe,EAAE;YACxB,CAAC,GAAG,gBAAgB,uBAAuB,EAAE;gBACzC,MAAM,oBAAoB,oBAAoB;gBAC9C;gBACA;gBACA;gBACA;YACJ;QACJ;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 1407, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-find-source-map-url.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"findSourceMapURL\", {\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n});\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nconst pathname = `${basePath}/__nextjs_source-map`;\nconst findSourceMapURL = process.env.NODE_ENV === 'development' ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return `${filename}.map`;\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : undefined;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-find-source-map-url.js.map"],"names":[],"mappings":"AAUiB;AAVjB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,oBAAoB;IAC/C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,WAAW,wCAAsC;AACvD,MAAM,WAAW,GAAG,SAAS,oBAAoB,CAAC;AAClD,MAAM,mBAAmB,uCAAyC,SAAS,iBAAiB,QAAQ;IAChG,IAAI,aAAa,IAAI;QACjB,OAAO;IACX;IACA,IAAI,SAAS,UAAU,CAAC,SAAS,QAAQ,CAAC,MAAM,KAAK,SAAS,QAAQ,CAAC,kBAAkB;QACrF,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAO,GAAG,SAAS,IAAI,CAAC;IAC5B;IACA,MAAM,MAAM,IAAI,IAAI,UAAU,SAAS,QAAQ,CAAC,MAAM;IACtD,IAAI,YAAY,CAAC,GAAG,CAAC,YAAY;IACjC,OAAO,IAAI,IAAI;AACnB,IAAI;AAEJ,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 1449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/match-segments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"matchSegment\", {\n    enumerable: true,\n    get: function() {\n        return matchSegment;\n    }\n});\nconst matchSegment = (existingSegment, segment)=>{\n    // segment is either Array or string\n    if (typeof existingSegment === 'string') {\n        if (typeof segment === 'string') {\n            // Common case: segment is just a string\n            return existingSegment === segment;\n        }\n        return false;\n    }\n    if (typeof segment === 'string') {\n        return false;\n    }\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=match-segments.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,gBAAgB;IAC3C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,eAAe,CAAC,iBAAiB;IACnC,oCAAoC;IACpC,IAAI,OAAO,oBAAoB,UAAU;QACrC,IAAI,OAAO,YAAY,UAAU;YAC7B,wCAAwC;YACxC,OAAO,oBAAoB;QAC/B;QACA,OAAO;IACX;IACA,IAAI,OAAO,YAAY,UAAU;QAC7B,OAAO;IACX;IACA,OAAO,eAAe,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE,IAAI,eAAe,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE;AACjF;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 1483, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    computeChangedPath: null,\n    extractPathFromFlightRouterState: null,\n    getSelectedParams: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    computeChangedPath: function() {\n        return computeChangedPath;\n    },\n    extractPathFromFlightRouterState: function() {\n        return extractPathFromFlightRouterState;\n    },\n    getSelectedParams: function() {\n        return getSelectedParams;\n    }\n});\nconst _interceptionroutes = require(\"../../../shared/lib/router/utils/interception-routes\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _matchsegments = require(\"../match-segments\");\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === '/' ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === 'string') {\n        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n        if (segment === 'children') return '';\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === '' || (0, _segment.isGroupSegment)(segment)) {\n            return acc;\n        }\n        return `${acc}/${segment}`;\n    }, '') || '/';\n}\nfunction extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return '';\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    const parallelRoutes = flightRouterState[1] ?? {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === 'children') continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return '';\n    }\n    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return extractPathFromFlightRouterState(treeB) ?? '';\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return `${segmentToPathname(segmentB)}/${changedPath}`;\n            }\n        }\n    }\n    return null;\n}\nfunction computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === '/') {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split('/'));\n}\nfunction getSelectedParams(currentTree, params = {}) {\n    const parallelRoutes = currentTree[1];\n    for (const parallelRoute of Object.values(parallelRoutes)){\n        const segment = parallelRoute[0];\n        const isDynamicParameter = Array.isArray(segment);\n        const segmentValue = isDynamicParameter ? segment[1] : segment;\n        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;\n        // Ensure catchAll and optional catchall are turned into an array\n        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');\n        if (isCatchAll) {\n            params[segment[0]] = segment[1].split('/');\n        } else if (isDynamicParameter) {\n            params[segment[0]] = segment[1];\n        }\n        params = getSelectedParams(parallelRoute, params);\n    }\n    return params;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=compute-changed-path.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/handle-mutable.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"handleMutable\", {\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n});\nconst _computechangedpath = require(\"./compute-changed-path\");\nfunction isNotUndefined(value) {\n    return typeof value !== 'undefined';\n}\nfunction handleMutable(state, mutable) {\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = mutable.shouldScroll ?? true;\n    let previousNextUrl = state.previousNextUrl;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            previousNextUrl = nextUrl;\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    return {\n        // Set href.\n        canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n        renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable?.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: mutable.onlyHashChange || false,\n            hashFragment: shouldScroll ? // #top is handled in layout-router.\n            mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl,\n        previousNextUrl: previousNextUrl,\n        debugInfo: mutable.collectedDebugInfo ?? null\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=handle-mutable.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,iBAAiB;IAC5C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,eAAe,KAAK;IACzB,OAAO,OAAO,UAAU;AAC5B;AACA,SAAS,cAAc,KAAK,EAAE,OAAO;IACjC,0DAA0D;IAC1D,MAAM,eAAe,QAAQ,YAAY,IAAI;IAC7C,IAAI,kBAAkB,MAAM,eAAe;IAC3C,IAAI,UAAU,MAAM,OAAO;IAC3B,IAAI,eAAe,QAAQ,WAAW,GAAG;QACrC,sEAAsE;QACtE,MAAM,cAAc,CAAC,GAAG,oBAAoB,kBAAkB,EAAE,MAAM,IAAI,EAAE,QAAQ,WAAW;QAC/F,IAAI,aAAa;YACb,qDAAqD;YACrD,kBAAkB;YAClB,UAAU;QACd,OAAO,IAAI,CAAC,SAAS;YACjB,6HAA6H;YAC7H,UAAU,MAAM,YAAY;QAChC;IACJ,0EAA0E;IAC1E;IACA,OAAO;QACH,YAAY;QACZ,cAAc,QAAQ,YAAY,IAAI,MAAM,YAAY;QACxD,gBAAgB,QAAQ,cAAc,IAAI,MAAM,cAAc;QAC9D,SAAS;YACL,aAAa,eAAe,QAAQ,WAAW,IAAI,QAAQ,WAAW,GAAG,MAAM,OAAO,CAAC,WAAW;YAClG,eAAe,eAAe,QAAQ,aAAa,IAAI,QAAQ,aAAa,GAAG,MAAM,OAAO,CAAC,aAAa;YAC1G,4BAA4B,eAAe,QAAQ,0BAA0B,IAAI,QAAQ,0BAA0B,GAAG,MAAM,OAAO,CAAC,0BAA0B;QAClK;QACA,kEAAkE;QAClE,mBAAmB;YACf,OAAO,eAAe,eAAe,SAAS,sBAAsB,OAAO,MAAM,iBAAiB,CAAC,KAAK,GAAG;YAC3G,gBAAgB,QAAQ,cAAc,IAAI;YAC1C,cAAc,eACd,QAAQ,YAAY,IAAI,QAAQ,YAAY,KAAK,KAAK,mBAAmB,QAAQ,YAAY,CAAC,KAAK,CAAC,MAAM,MAAM,iBAAiB,CAAC,YAAY,GAAG;YACjJ,cAAc,eAAe,SAAS,sBAAsB,MAAM,iBAAiB,CAAC,YAAY,GAAG,EAAE;QACzG;QACA,eAAe;QACf,OAAO,QAAQ,KAAK,GAAG,QAAQ,KAAK,GAAG,MAAM,KAAK;QAClD,8BAA8B;QAC9B,MAAM,eAAe,QAAQ,WAAW,IAAI,QAAQ,WAAW,GAAG,MAAM,IAAI;QAC5E;QACA,iBAAiB;QACjB,WAAW,QAAQ,kBAAkB,IAAI;IAC7C;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 1680, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/app-router-headers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HEADER: null,\n    FLIGHT_HEADERS: null,\n    NEXT_ACTION_NOT_FOUND_HEADER: null,\n    NEXT_DID_POSTPONE_HEADER: null,\n    NEXT_HMR_REFRESH_HASH_COOKIE: null,\n    NEXT_HMR_REFRESH_HEADER: null,\n    NEXT_HTML_REQUEST_ID_HEADER: null,\n    NEXT_IS_PRERENDER_HEADER: null,\n    NEXT_REQUEST_ID_HEADER: null,\n    NEXT_REWRITTEN_PATH_HEADER: null,\n    NEXT_REWRITTEN_QUERY_HEADER: null,\n    NEXT_ROUTER_PREFETCH_HEADER: null,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: null,\n    NEXT_ROUTER_STALE_TIME_HEADER: null,\n    NEXT_ROUTER_STATE_TREE_HEADER: null,\n    NEXT_RSC_UNION_QUERY: null,\n    NEXT_URL: null,\n    RSC_CONTENT_TYPE_HEADER: null,\n    RSC_HEADER: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HEADER: function() {\n        return ACTION_HEADER;\n    },\n    FLIGHT_HEADERS: function() {\n        return FLIGHT_HEADERS;\n    },\n    NEXT_ACTION_NOT_FOUND_HEADER: function() {\n        return NEXT_ACTION_NOT_FOUND_HEADER;\n    },\n    NEXT_DID_POSTPONE_HEADER: function() {\n        return NEXT_DID_POSTPONE_HEADER;\n    },\n    NEXT_HMR_REFRESH_HASH_COOKIE: function() {\n        return NEXT_HMR_REFRESH_HASH_COOKIE;\n    },\n    NEXT_HMR_REFRESH_HEADER: function() {\n        return NEXT_HMR_REFRESH_HEADER;\n    },\n    NEXT_HTML_REQUEST_ID_HEADER: function() {\n        return NEXT_HTML_REQUEST_ID_HEADER;\n    },\n    NEXT_IS_PRERENDER_HEADER: function() {\n        return NEXT_IS_PRERENDER_HEADER;\n    },\n    NEXT_REQUEST_ID_HEADER: function() {\n        return NEXT_REQUEST_ID_HEADER;\n    },\n    NEXT_REWRITTEN_PATH_HEADER: function() {\n        return NEXT_REWRITTEN_PATH_HEADER;\n    },\n    NEXT_REWRITTEN_QUERY_HEADER: function() {\n        return NEXT_REWRITTEN_QUERY_HEADER;\n    },\n    NEXT_ROUTER_PREFETCH_HEADER: function() {\n        return NEXT_ROUTER_PREFETCH_HEADER;\n    },\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {\n        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;\n    },\n    NEXT_ROUTER_STALE_TIME_HEADER: function() {\n        return NEXT_ROUTER_STALE_TIME_HEADER;\n    },\n    NEXT_ROUTER_STATE_TREE_HEADER: function() {\n        return NEXT_ROUTER_STATE_TREE_HEADER;\n    },\n    NEXT_RSC_UNION_QUERY: function() {\n        return NEXT_RSC_UNION_QUERY;\n    },\n    NEXT_URL: function() {\n        return NEXT_URL;\n    },\n    RSC_CONTENT_TYPE_HEADER: function() {\n        return RSC_CONTENT_TYPE_HEADER;\n    },\n    RSC_HEADER: function() {\n        return RSC_HEADER;\n    }\n});\nconst RSC_HEADER = 'rsc';\nconst ACTION_HEADER = 'next-action';\nconst NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\nconst NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\nconst NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\nconst NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\nconst NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\nconst NEXT_URL = 'next-url';\nconst RSC_CONTENT_TYPE_HEADER = 'text/x-component';\nconst FLIGHT_HEADERS = [\n    RSC_HEADER,\n    NEXT_ROUTER_STATE_TREE_HEADER,\n    NEXT_ROUTER_PREFETCH_HEADER,\n    NEXT_HMR_REFRESH_HEADER,\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n];\nconst NEXT_RSC_UNION_QUERY = '_rsc';\nconst NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\nconst NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\nconst NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\nconst NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\nconst NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\nconst NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\nconst NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id';\nconst NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id';\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-router-headers.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,gBAAgB;IAChB,8BAA8B;IAC9B,0BAA0B;IAC1B,8BAA8B;IAC9B,yBAAyB;IACzB,6BAA6B;IAC7B,0BAA0B;IAC1B,wBAAwB;IACxB,4BAA4B;IAC5B,6BAA6B;IAC7B,6BAA6B;IAC7B,qCAAqC;IACrC,+BAA+B;IAC/B,+BAA+B;IAC/B,sBAAsB;IACtB,UAAU;IACV,yBAAyB;IACzB,YAAY;AAChB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,gBAAgB;QACZ,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,0BAA0B;QACtB,OAAO;IACX;IACA,8BAA8B;QAC1B,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,0BAA0B;QACtB,OAAO;IACX;IACA,wBAAwB;QACpB,OAAO;IACX;IACA,4BAA4B;QACxB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,6BAA6B;QACzB,OAAO;IACX;IACA,qCAAqC;QACjC,OAAO;IACX;IACA,+BAA+B;QAC3B,OAAO;IACX;IACA,+BAA+B;QAC3B,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;IACA,UAAU;QACN,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;IACA,YAAY;QACR,OAAO;IACX;AACJ;AACA,MAAM,aAAa;AACnB,MAAM,gBAAgB;AACtB,MAAM,gCAAgC;AACtC,MAAM,8BAA8B;AACpC,MAAM,sCAAsC;AAC5C,MAAM,0BAA0B;AAChC,MAAM,+BAA+B;AACrC,MAAM,WAAW;AACjB,MAAM,0BAA0B;AAChC,MAAM,iBAAiB;IACnB;IACA;IACA;IACA;IACA;CACH;AACD,MAAM,uBAAuB;AAC7B,MAAM,gCAAgC;AACtC,MAAM,2BAA2B;AACjC,MAAM,6BAA6B;AACnC,MAAM,8BAA8B;AACpC,MAAM,2BAA2B;AACjC,MAAM,+BAA+B;AACrC,MAAM,yBAAyB;AAC/B,MAAM,8BAA8B;AAEpC,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 1805, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/route-params.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    doesStaticSegmentAppearInURL: null,\n    getCacheKeyForDynamicParam: null,\n    getParamValueFromCacheKey: null,\n    getRenderedPathname: null,\n    getRenderedSearch: null,\n    parseDynamicParamFromURLPart: null,\n    urlSearchParamsToParsedUrlQuery: null,\n    urlToUrlWithoutFlightMarker: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlSearchParamsToParsedUrlQuery: function() {\n        return urlSearchParamsToParsedUrlQuery;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = require(\"../shared/lib/segment\");\nconst _segmentvalueencoding = require(\"../shared/lib/segment-cache/segment-value-encoding\");\nconst _approuterheaders = require(\"./components/app-router-headers\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (process.env.NODE_ENV === 'production') {\n        if (process.env.__NEXT_CONFIG_OUTPUT === 'export' && urlWithoutFlightParameters.pathname.endsWith('.txt')) {\n            const { pathname } = urlWithoutFlightParameters;\n            const length = pathname.endsWith('/index.txt') ? 10 : 4;\n            // Slice off `/index.txt` or `.txt` from the end of the pathname\n            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);\n        }\n    }\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nfunction urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=route-params.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/flight-data-helpers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createInitialRSCPayloadFromFallbackPrerender: null,\n    getFlightDataPartsFromPath: null,\n    getNextFlightSegmentPath: null,\n    normalizeFlightData: null,\n    prepareFlightRouterStateForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createInitialRSCPayloadFromFallbackPrerender: function() {\n        return createInitialRSCPayloadFromFallbackPrerender;\n    },\n    getFlightDataPartsFromPath: function() {\n        return getFlightDataPartsFromPath;\n    },\n    getNextFlightSegmentPath: function() {\n        return getNextFlightSegmentPath;\n    },\n    normalizeFlightData: function() {\n        return normalizeFlightData;\n    },\n    prepareFlightRouterStateForRequest: function() {\n        return prepareFlightRouterStateForRequest;\n    }\n});\nconst _segment = require(\"../shared/lib/segment\");\nconst _routeparams = require(\"./route-params\");\nconst _createhreffromurl = require(\"./components/router-reducer/create-href-from-url\");\nfunction getFlightDataPartsFromPath(flightDataPath) {\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n    const flightDataPathLength = 4;\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\n    return {\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\n        pathToSegment: segmentPath.slice(0, -1),\n        segmentPath,\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n        // in which case we default to ''.\n        segment: segmentPath[segmentPath.length - 1] ?? '',\n        tree,\n        seedData,\n        head,\n        isHeadPartial,\n        isRootRender: flightDataPath.length === flightDataPathLength\n    };\n}\nfunction createInitialRSCPayloadFromFallbackPrerender(response, fallbackInitialRSCPayload) {\n    // This is a static fallback page. In order to hydrate the page, we need to\n    // parse the client params from the URL, but to account for the possibility\n    // that the page was rewritten, we need to check the response headers\n    // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n    // we can't access the headers of the initial document response, the client\n    // performs a fetch request to the current location. Since it's possible that\n    // the fetch request will be dynamically rewritten to a different path than\n    // the initial document, this fetch request delivers _all_ the hydration data\n    // for the page; it was not inlined into the document, like it normally\n    // would be.\n    //\n    // TODO: Consider treating the case where fetch is rewritten to a different\n    // path from the document as a special deopt case. We should optimistically\n    // assume this won't happen, inline the data into the document, and perform\n    // a minimal request (like a HEAD or range request) to verify that the\n    // response matches. Tricky to get right because we need to account for\n    // all the different deployment environments we support, like output:\n    // \"export\" mode, where we currently don't assume that custom response\n    // headers are present.\n    // Patch the Flight data sent by the server with the correct params parsed\n    // from the URL + response object.\n    const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(new URL(location.href));\n    const originalFlightDataPath = fallbackInitialRSCPayload.f[0];\n    const originalFlightRouterState = originalFlightDataPath[0];\n    return {\n        b: fallbackInitialRSCPayload.b,\n        c: canonicalUrl.split('/'),\n        q: renderedSearch,\n        i: fallbackInitialRSCPayload.i,\n        f: [\n            [\n                fillInFallbackFlightRouterState(originalFlightRouterState, renderedPathname, renderedSearch),\n                originalFlightDataPath[1],\n                originalFlightDataPath[2],\n                originalFlightDataPath[2]\n            ]\n        ],\n        m: fallbackInitialRSCPayload.m,\n        G: fallbackInitialRSCPayload.G,\n        S: fallbackInitialRSCPayload.S\n    };\n}\nfunction fillInFallbackFlightRouterState(flightRouterState, renderedPathname, renderedSearch) {\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    return fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, index);\n}\nfunction fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, pathnamePartsIndex) {\n    const originalSegment = flightRouterState[0];\n    let newSegment;\n    let doesAppearInURL;\n    if (typeof originalSegment === 'string') {\n        newSegment = originalSegment;\n        doesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(originalSegment);\n    } else {\n        const paramName = originalSegment[0];\n        const paramType = originalSegment[2];\n        const paramValue = (0, _routeparams.parseDynamicParamFromURLPart)(paramType, pathnameParts, pathnamePartsIndex);\n        const cacheKey = (0, _routeparams.getCacheKeyForDynamicParam)(paramValue, renderedSearch);\n        newSegment = [\n            paramName,\n            cacheKey,\n            paramType\n        ];\n        doesAppearInURL = true;\n    }\n    // Only increment the index if the segment appears in the URL. If it's a\n    // \"virtual\" segment, like a route group, it remains the same.\n    const childPathnamePartsIndex = doesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n    const children = flightRouterState[1];\n    const newChildren = {};\n    for(let key in children){\n        const childFlightRouterState = children[key];\n        newChildren[key] = fillInFallbackFlightRouterStateImpl(childFlightRouterState, renderedSearch, pathnameParts, childPathnamePartsIndex);\n    }\n    const newState = [\n        newSegment,\n        newChildren,\n        null,\n        flightRouterState[3],\n        flightRouterState[4]\n    ];\n    return newState;\n}\nfunction getNextFlightSegmentPath(flightSegmentPath) {\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n    // to get the next segment path.\n    return flightSegmentPath.slice(2);\n}\nfunction normalizeFlightData(flightData) {\n    // FlightData can be a string when the server didn't respond with a proper flight response,\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n    if (typeof flightData === 'string') {\n        return flightData;\n    }\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\n}\nfunction prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\n    // HMR requests need the complete, unmodified state for proper functionality\n    if (isHmrRefresh) {\n        return encodeURIComponent(JSON.stringify(flightRouterState));\n    }\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\n}\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\n    // __PAGE__ segments are always fetched from the server, so there's\n    // no need to send them up\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\n    // Recursively process parallel routes\n    const cleanedParallelRoutes = {};\n    for (const [key, childState] of Object.entries(parallelRoutes)){\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\n    }\n    const result = [\n        cleanedSegment,\n        cleanedParallelRoutes,\n        null,\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\n    ];\n    // Append optional fields if present\n    if (isRootLayout !== undefined) {\n        result[4] = isRootLayout;\n    }\n    if (hasLoadingBoundary !== undefined) {\n        result[5] = hasLoadingBoundary;\n    }\n    return result;\n}\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */ function stripSearchParamsFromPageSegment(segment) {\n    if (typeof segment === 'string' && segment.startsWith(_segment.PAGE_SEGMENT_KEY + '?')) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */ function shouldPreserveRefreshMarker(refreshMarker) {\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=flight-data-helpers.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2254, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-build-id.js"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getAppBuildId: null,\n    setAppBuildId: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getAppBuildId: function() {\n        return getAppBuildId;\n    },\n    setAppBuildId: function() {\n        return setAppBuildId;\n    }\n});\nlet globalBuildId = '';\nfunction setAppBuildId(buildId) {\n    globalBuildId = buildId;\n}\nfunction getAppBuildId() {\n    return globalBuildId;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-build-id.js.map"],"names":[],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AACtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;AAE7E,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,eAAe;AACnB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,eAAe;QACX,OAAO;IACX;AACJ;AACA,IAAI,gBAAgB;AACpB,SAAS,cAAc,OAAO;IAC1B,gBAAgB;AACpB;AACA,SAAS;IACL,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 2305, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    setCacheBustingSearchParam: null,\n    setCacheBustingSearchParamWithHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    setCacheBustingSearchParam: function() {\n        return setCacheBustingSearchParam;\n    },\n    setCacheBustingSearchParamWithHash: function() {\n        return setCacheBustingSearchParamWithHash;\n    }\n});\nconst _cachebustingsearchparam = require(\"../../../shared/lib/router/utils/cache-busting-search-param\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);\n    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);\n};\nconst setCacheBustingSearchParamWithHash = (url, hash)=>{\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    // Always remove any existing cache busting param and add a fresh one to ensure\n    // we have the correct value based on current request headers\n    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=`));\n    if (hash.length > 0) {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=${hash}`);\n    } else {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}`);\n    }\n    url.search = pairs.length ? `?${pairs.join('&')}` : '';\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=set-cache-busting-search-param.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,4BAA4B;IAC5B,oCAAoC;AACxC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,4BAA4B;QACxB,OAAO;IACX;IACA,oCAAoC;QAChC,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,6BAA6B,CAAC,KAAK;IACrC,MAAM,iBAAiB,CAAC,GAAG,yBAAyB,8BAA8B,EAAE,OAAO,CAAC,kBAAkB,2BAA2B,CAAC,EAAE,OAAO,CAAC,kBAAkB,mCAAmC,CAAC,EAAE,OAAO,CAAC,kBAAkB,6BAA6B,CAAC,EAAE,OAAO,CAAC,kBAAkB,QAAQ,CAAC;IACzS,mCAAmC,KAAK;AAC5C;AACA,MAAM,qCAAqC,CAAC,KAAK;IAC7C;;;;;;;;;;GAUD,GAAG,MAAM,iBAAiB,IAAI,MAAM;IACnC,MAAM,WAAW,eAAe,UAAU,CAAC,OAAO,eAAe,KAAK,CAAC,KAAK;IAC5E,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAM,QAAQ,SAAS,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,OAAO,QAAQ,CAAC,KAAK,UAAU,CAAC,GAAG,kBAAkB,oBAAoB,CAAC,CAAC,CAAC;IACtH,IAAI,KAAK,MAAM,GAAG,GAAG;QACjB,MAAM,IAAI,CAAC,GAAG,kBAAkB,oBAAoB,CAAC,CAAC,EAAE,MAAM;IAClE,OAAO;QACH,MAAM,IAAI,CAAC,GAAG,kBAAkB,oBAAoB,EAAE;IAC1D;IACA,IAAI,MAAM,GAAG,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC,MAAM,GAAG;AACxD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0DAA0D","ignoreList":[0]}},
    {"offset": {"line": 2366, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createFetch: null,\n    createFromNextReadableStream: null,\n    fetchServerResponse: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = require(\"react-server-dom-webpack/client\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst _appcallserver = require(\"../../app-call-server\");\nconst _appfindsourcemapurl = require(\"../../app-find-source-map-url\");\nconst _routerreducertypes = require(\"./router-reducer-types\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nconst _appbuildid = require(\"../../app-build-id\");\nconst _setcachebustingsearchparam = require(\"./set-cache-busting-search-param\");\nconst _routeparams = require(\"../../route-params\");\nconst createFromReadableStream = _client.createFromReadableStream;\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL) {\n    createDebugChannel = require('../../dev/debug-channel').createDebugChannel;\n}\nfunction doMpaNavigation(url) {\n    return (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString();\n}\nlet isPageUnloading = false;\nif (typeof window !== 'undefined') {\n    // Track when the page is unloading, e.g. due to reloading the page or\n    // performing hard navigations. This allows us to suppress error logging when\n    // the browser cancels in-flight requests during page unload.\n    window.addEventListener('pagehide', ()=>{\n        isPageUnloading = true;\n    });\n    // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n    // execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        isPageUnloading = false;\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    // In static export mode, we need to modify the URL to request the .txt file,\n    // but we should preserve the original URL for the canonical URL and error handling.\n    const originalUrl = url;\n    try {\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                // In \"output: export\" mode, we can't rely on headers to distinguish\n                // between HTML and RSC requests. Instead, we append an extra prefix\n                // to the request.\n                url = new URL(url);\n                if (url.pathname.endsWith('/')) {\n                    url.pathname += 'index.txt';\n                } else {\n                    url.pathname += '.txt';\n                }\n            }\n        }\n        // Typically, during a navigation, we decode the response using Flight's\n        // `createFromFetch` API, which accepts a `fetch` promise.\n        // TODO: Remove this check once the old PPR flag is removed\n        const isLegacyPPR = process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS;\n        const shouldImmediatelyDecode = !isLegacyPPR;\n        const res = await createFetch(url, headers, fetchPriority, shouldImmediatelyDecode);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!res.headers.get('vary')?.includes(_approuterheaders.NEXT_URL);\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                if (!isFlightResponse) {\n                    isFlightResponse = contentType.startsWith('text/plain');\n                }\n            }\n        }\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        // TODO: This needs to happen in the Flight Client.\n        // Or Webpack needs to include the runtime update in the Flight response as\n        // a blocking script.\n        if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n            await require('../../dev/hot-reloader/app/hot-reloader-app').waitForWebpackRuntimeHotUpdate();\n        }\n        let flightResponsePromise = res.flightResponse;\n        if (flightResponsePromise === null) {\n            // Typically, `createFetch` would have already started decoding the\n            // Flight response. If it hasn't, though, we need to decode it now.\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n            // without Cache Components). Remove this branch once legacy PPR\n            // is deleted.\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\n        }\n        const flightResponse = await flightResponsePromise;\n        if ((0, _appbuildid.getAppBuildId)() !== flightResponse.b) {\n            return doMpaNavigation(res.url);\n        }\n        const normalizedFlightData = (0, _flightdatahelpers.normalizeFlightData)(flightResponse.f);\n        if (typeof normalizedFlightData === 'string') {\n            return doMpaNavigation(normalizedFlightData);\n        }\n        return {\n            flightData: normalizedFlightData,\n            canonicalUrl: canonicalUrl,\n            renderedSearch: (0, _routeparams.getRenderedSearch)(res),\n            couldBeIntercepted: interception,\n            prerendered: flightResponse.S,\n            postponed,\n            staleTime,\n            debugInfo: flightResponsePromise._debugInfo ?? null\n        };\n    } catch (err) {\n        if (!isPageUnloading) {\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return originalUrl.toString();\n    }\n}\nasync function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n        headers['Next-Test-Fetch-Priority'] = fetchPriority;\n    }\n    if (process.env.NEXT_DEPLOYMENT_ID) {\n        headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\n    // Immediately pass the fetch promise to the Flight client so that the debug\n    // info includes the latency from the client to the server. The internal timer\n    // in React starts as soon as `createFromFetch` is called.\n    //\n    // The only case where we don't do this is during a prefetch, because we have\n    // to do some extra processing of the response stream (see\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n    // prefetch response never blocks a navigation; if it hasn't already been\n    // written into the cache by the time the navigation happens, the router will\n    // go straight to a dynamic request.\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n    let browserResponse = await fetchPromise;\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid  when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n        // This is to prevent a redirect loop. Same limit used by Chrome.\n        const MAX_REDIRECTS = 20;\n        for(let n = 0; n < MAX_REDIRECTS; n++){\n            if (!browserResponse.redirected) {\n                break;\n            }\n            const responseUrl = new URL(browserResponse.url, fetchUrl);\n            if (responseUrl.origin !== fetchUrl.origin) {\n                break;\n            }\n            if (responseUrl.searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY) === fetchUrl.searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY)) {\n                break;\n            }\n            // The RSC request was redirected. Assume the response is invalid.\n            //\n            // Append the cache busting search param to the redirected URL and\n            // fetch again.\n            // TODO: We should abort the previous request.\n            fetchUrl = new URL(responseUrl);\n            (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n            fetchPromise = fetch(fetchUrl, fetchOptions);\n            flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n            browserResponse = await fetchPromise;\n            // We just performed a manual redirect, so this is now true.\n            redirected = true;\n        }\n    }\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status,\n        // This is the exact promise returned by `createFromFetch`. It contains\n        // debug information that we need to transfer to any derived promises that\n        // are later rendered by React.\n        flightResponse: flightResponsePromise\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream, requestHeaders) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\n    return createFromFetch(promiseForResponse, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=fetch-server-response.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2676, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createRouterCacheKey\", {\n    enumerable: true,\n    get: function() {\n        return createRouterCacheKey;\n    }\n});\nconst _segment = require(\"../../../shared/lib/segment\");\nfunction createRouterCacheKey(segment, withoutSearchParameters = false) {\n    // if the segment is an array, it means it's a dynamic segment\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n    if (Array.isArray(segment)) {\n        return `${segment[0]}|${segment[1]}|${segment[2]}`;\n    }\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\n    // When `withoutSearchParameters` is true, we only want to return the page segment\n    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=create-router-cache-key.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,wBAAwB;IACnD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,qBAAqB,OAAO,EAAE,0BAA0B,KAAK;IAClE,8DAA8D;IAC9D,uGAAuG;IACvG,IAAI,MAAM,OAAO,CAAC,UAAU;QACxB,OAAO,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE;IACtD;IACA,kEAAkE;IAClE,kFAAkF;IAClF,IAAI,2BAA2B,QAAQ,UAAU,CAAC,SAAS,gBAAgB,GAAG;QAC1E,OAAO,SAAS,gBAAgB;IACpC;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 2710, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isNavigatingToNewRootLayout\", {\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n});\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=is-navigating-to-new-root-layout.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,+BAA+B;IAC1D,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,4BAA4B,WAAW,EAAE,QAAQ;IACtD,mBAAmB;IACnB,MAAM,qBAAqB,WAAW,CAAC,EAAE;IACzC,MAAM,kBAAkB,QAAQ,CAAC,EAAE;IACnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAI,MAAM,OAAO,CAAC,uBAAuB,MAAM,OAAO,CAAC,kBAAkB;QACrE,sHAAsH;QACtH,uGAAuG;QACvG,IAAI,kBAAkB,CAAC,EAAE,KAAK,eAAe,CAAC,EAAE,IAAI,kBAAkB,CAAC,EAAE,KAAK,eAAe,CAAC,EAAE,EAAE;YAC9F,OAAO;QACX;IACJ,OAAO,IAAI,uBAAuB,iBAAiB;QAC/C,OAAO;IACX;IACA,iCAAiC;IACjC,IAAI,WAAW,CAAC,EAAE,EAAE;QAChB,4EAA4E;QAC5E,OAAO,CAAC,QAAQ,CAAC,EAAE;IACvB;IACA,oEAAoE;IACpE,IAAI,QAAQ,CAAC,EAAE,EAAE;QACb,OAAO;IACX;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAM,mBAAmB,OAAO,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAM,gBAAgB,OAAO,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAAC,oBAAoB,CAAC,eAAe,OAAO;IAChD,OAAO,4BAA4B,kBAAkB;AACzD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4DAA4D","ignoreList":[0]}},
    {"offset": {"line": 2763, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    abortTask: null,\n    listenForDynamicRequest: null,\n    startPPRNavigation: null,\n    updateCacheNodeOnPopstateRestoration: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _matchsegments = require(\"../match-segments\");\nconst _createhreffromurl = require(\"./create-href-from-url\");\nconst _createroutercachekey = require(\"./create-router-cache-key\");\nconst _isnavigatingtonewrootlayout = require(\"./is-navigating-to-new-root-layout\");\nconst _navigatereducer = require(\"./reducers/navigate-reducer\");\nconst MPA_NAVIGATION_TASK = {\n    route: null,\n    node: null,\n    dynamicRequestTree: null,\n    children: null\n};\nfunction startPPRNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {\n    const segmentPath = [];\n    return updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);\n}\nfunction updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    if (!didFindRootLayout) {\n        // We're currently traversing the part of the tree that was also part of\n        // the previous route. If we discover a root layout, then we don't need to\n        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n        const isRootLayout = newRouterState[4] === true;\n        if (isRootLayout) {\n            // Found a matching root layout.\n            didFindRootLayout = true;\n        }\n    }\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server  for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let needsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n    // end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            newSegmentChild\n        ]);\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment  a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation  but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else if (isSamePageNavigation && // Check if this is a page segment.\n        // TODO: We're not consistent about how we do this check. Some places\n        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n        // check if there any any children, which is why I'm doing it here. We\n        // should probably encode an empty children set as `null` though. Either\n        // way, we should update all the checks to be consistent.\n        Object.keys(newRouterStateChild[1]).length === 0) {\n            // We special case navigations to the exact same URL as the current\n            // location. It's a common UI pattern for apps to refresh when you click a\n            // link to the current page. So when this happens, we refresh the dynamic\n            // data in the page segments.\n            //\n            // Note that this does not apply if the any part of the hash or search\n            // query has changed. This might feel a bit weird but it makes more sense\n            // when you consider that the way to trigger this behavior is to click\n            // the same link multiple times.\n            //\n            // TODO: We should probably refresh the *entire* route when this case\n            // occurs, not just the page segments. Essentially treating it the same as\n            // a refresh() triggered by an action, which is the more explicit way of\n            // modeling the UI pattern described above.\n            //\n            // Also note that this only refreshes the dynamic data, not static/\n            // cached data. If the page segment is fully static and prefetched, the\n            // request is skipped. (This is also how refresh() works.)\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees. Recursively update\n                // the children.\n                taskChild = updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);\n            } else {\n                // There's no existing Cache Node for this segment. Switch to the\n                // \"create\" path.\n                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        }\n        if (taskChild !== null) {\n            // Recursively propagate up the child tasks.\n            if (taskChild.route === null) {\n                // One of the child tasks discovered a change to the root layout.\n                // Immediately unwind from this recursive traversal.\n                return MPA_NAVIGATION_TASK;\n            }\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            const taskChildRoute = taskChild.route;\n            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n            }\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        navigatedAt\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    if (!didFindRootLayout) {\n        // The route tree changed before we reached a layout. (The highest-level\n        // layout in a route tree is referred to as the \"root\" layout.) This could\n        // mean that we're navigating between two different root layouts. When this\n        // happens, we perform a full-page (MPA-style) navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just because\n        // we're re-rendering a segment outside of the root layout does not mean we\n        // should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments are\n        // considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is unchanged.\n        // In the common case, this branch is skipped completely.\n        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {\n            // The root layout changed. Perform a full-page navigation.\n            return MPA_NAVIGATION_TASK;\n        }\n    }\n    return createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n}\nfunction createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Same traversal as updateCacheNodeNavigation, but we switch to this path\n    // once we reach the part of the tree that was not in the previous route. We\n    // don't need to diff against the old tree, we just need to create a new one.\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const routerStateChildren = routerState[1];\n    const isLeafSegment = Object.keys(routerStateChildren).length === 0;\n    // Even we're rendering inside the \"new\" part of the target tree, we may have\n    // a locally cached segment that we can reuse. This may come from either 1)\n    // the CacheNode tree, which lives in React state and is populated by previous\n    // navigations; or 2) the prefetch cache, which is a separate cache that is\n    // populated by prefetches.\n    let rsc;\n    let loading;\n    let head;\n    let cacheNodeNavigatedAt;\n    if (existingCacheNode !== undefined && // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + _navigatereducer.DYNAMIC_STALETIME_MS > navigatedAt) {\n        // We have an existing CacheNode for this segment, and it's not stale. We\n        // should reuse it rather than request a new one.\n        rsc = existingCacheNode.rsc;\n        loading = existingCacheNode.loading;\n        head = existingCacheNode.head;\n        // Don't update the navigatedAt timestamp, since we're reusing stale data.\n        cacheNodeNavigatedAt = existingCacheNode.navigatedAt;\n    } else if (prefetchData !== null) {\n        // There's no existing CacheNode for this segment, but we do have prefetch\n        // data. If the prefetch data is fully static (i.e. does not contain any\n        // dynamic holes), we don't need to request it from the server.\n        rsc = prefetchData[0];\n        loading = prefetchData[2];\n        head = isLeafSegment ? possiblyPartialPrefetchHead : null;\n        // Even though we're accessing the data from the prefetch cache, this is\n        // conceptually a new segment, not a reused one. So we should update the\n        // navigatedAt timestamp.\n        cacheNodeNavigatedAt = navigatedAt;\n        const isPrefetchRscPartial = prefetchData[3];\n        if (// Check if the segment data is partial\n        isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)\n        isPrefetchHeadPartial && isLeafSegment) {\n            // We only have partial data from this segment. Like missing segments, we\n            // must request the full data from the server.\n            return spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n        } else {\n        // The prefetch data is fully static, so we can omit it from the\n        // navigation request.\n        }\n    } else {\n        // There's no prefetch for this segment. Everything from this point will be\n        // requested from the server, even if there are static children below it.\n        // Create a terminal task node that will later be fulfilled by\n        // server response.\n        return spawnPendingTask(navigatedAt, routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    // We already have a full segment we can render, so we don't need to request a\n    // new one from the server. Keep traversing down the tree until we reach\n    // something that requires a dynamic request.\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const taskChildren = new Map();\n    const existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null;\n    const cacheNodeChildren = new Map(existingCacheNodeChildren);\n    let dynamicRequestTreeChildren = {};\n    let needsDynamicRequest = false;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    } else {\n        for(let parallelRouteKey in routerStateChildren){\n            const routerStateChild = routerStateChildren[parallelRouteKey];\n            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n            const existingSegmentMapChild = existingCacheNodeChildren !== null ? existingCacheNodeChildren.get(parallelRouteKey) : undefined;\n            const segmentChild = routerStateChild[0];\n            const segmentPathChild = segmentPath.concat([\n                parallelRouteKey,\n                segmentChild\n            ]);\n            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n            const existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;\n            const taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n            taskChildren.set(parallelRouteKey, taskChild);\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;\n            }\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map();\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    return {\n        // Since we're inside a new route tree, unlike the\n        // `updateCacheNodeOnNavigation` path, the router state on the children\n        // tasks is always the same as the router state we pass in. So we don't need\n        // to clone/modify it.\n        route: routerState,\n        node: {\n            lazyData: null,\n            // Since this segment is already full, we don't need to use the\n            // `prefetchRsc` field.\n            rsc,\n            prefetchRsc: null,\n            head,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: cacheNodeChildren,\n            navigatedAt: cacheNodeNavigatedAt\n        },\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Create a task that will later be fulfilled by data from the server.\n    // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n    // this to the server so it knows where to start rendering.\n    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);\n    dynamicRequestTree[3] = 'refetch';\n    const newTask = {\n        route: routerState,\n        // Corresponds to the part of the route that will be rendered on the server.\n        node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),\n        // Because this is non-null, and it gets propagated up through the parent\n        // tasks, the root task will know that it needs to perform a server request.\n        dynamicRequestTree,\n        children: null\n    };\n    return newTask;\n}\nfunction reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterState) {\n    // This is a \"default\" segment. These are never sent by the server during a\n    // soft navigation; instead, the client reuses whatever segment was already\n    // active in that slot on the previous route. This means if we later need to\n    // refresh the segment, it will have to be refetched from the previous route's\n    // URL. We store it in the Flight Router State.\n    //\n    // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n    // get rid of that eventually by making sure we only add URLs to page segments\n    // that are reused. Then the presence of the URL alone is enough.\n    let reusedRouterState;\n    const oldRefreshMarker = oldRouterState[3];\n    if (oldRefreshMarker === 'refresh') {\n        // This segment was already reused from an even older route. Keep its\n        // existing URL and refresh marker.\n        reusedRouterState = oldRouterState;\n    } else {\n        // This segment was not previously reused, and it's not on the new route.\n        // So it must have been delivered in the old route.\n        reusedRouterState = patchRouterStateWithNewChildren(oldRouterState, oldRouterState[1]);\n        reusedRouterState[2] = (0, _createhreffromurl.createHrefFromUrl)(oldUrl);\n        reusedRouterState[3] = 'refresh';\n    }\n    return {\n        route: reusedRouterState,\n        node: null,\n        dynamicRequestTree: null,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((result)=>{\n        if (typeof result === 'string') {\n            // Happens when navigating to page in `pages` from `app`. We shouldn't\n            // get here because should have already handled this during\n            // the prefetch.\n            return;\n        }\n        const { flightData, debugInfo } = result;\n        for (const normalizedFlightData of flightData){\n            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;\n            if (!dynamicData) {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead, debugInfo);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null, debugInfo);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error, null);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead, debugInfo) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead, debugInfo);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead, debugInfo) {\n    if (task.dynamicRequestTree === null) {\n        // Everything in this subtree is already complete. Bail out.\n        return;\n    }\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead, debugInfo);\n            // Set this to null to indicate that this task is now complete.\n            task.dynamicRequestTree = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[1];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead, debugInfo);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            segmentChild\n        ]);\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    }\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : [\n            null,\n            null\n        ],\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        // TODO: Technically, a loading boundary could contain dynamic data. We must\n        // have separate `loading` and `prefetchLoading` fields to handle this, like\n        // we do for the segment data and head.\n        loading: prefetchData !== null ? prefetchData[2] ?? null : // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n        createDeferredRsc(),\n        navigatedAt\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead, debugInfo) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety  it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[1];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead, debugInfo);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[0];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData, debugInfo);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n    // Fulfill it using the dynamic response so that we can display the loading boundary.\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        const dynamicLoading = dynamicData[2];\n        loading.resolve(dynamicLoading, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead, debugInfo);\n    }\n}\nfunction abortTask(task, error, debugInfo) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error, debugInfo);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error, debugInfo);\n        }\n    }\n    // Set this to null to indicate that this task is now complete.\n    task.dynamicRequestTree = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error, debugInfo) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null, debugInfo);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error, debugInfo);\n        }\n    }\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        loading.resolve(null, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null, debugInfo);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [\n            null,\n            null\n        ],\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: oldCacheNode.loading,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        navigatedAt: oldCacheNode.navigatedAt\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && typeof value === 'object' && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    // Create an unresolved promise that represents data derived from a Flight\n    // response. The promise will be resolved later as soon as we start receiving\n    // data from the server, i.e. as soon as the Flight client decodes and returns\n    // the top-level response object.\n    // The `_debugInfo` field contains profiling information. Promises that are\n    // created by Flight already have this info added by React; for any derived\n    // promise created by the router, we need to transfer the Flight debug info\n    // onto the derived promise.\n    //\n    // The debug info represents the latency between the start of the navigation\n    // and the start of rendering. (It does not represent the time it takes for\n    // whole stream to finish.)\n    const debugInfo = [];\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    pendingRsc._debugInfo = debugInfo;\n    return pendingRsc;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=ppr-navigations.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3638, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/types.js"],"sourcesContent":["/**\n * Shared types and constants for the Segment Cache.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    FetchStrategy: null,\n    NavigationResultTag: null,\n    PrefetchPriority: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    FetchStrategy: function() {\n        return FetchStrategy;\n    },\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    }\n});\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\nvar FetchStrategy = /*#__PURE__*/ function(FetchStrategy) {\n    // Deliberately ordered so we can easily compare two segments\n    // and determine if one segment is \"more specific\" than another\n    // (i.e. if it's likely that it contains more data)\n    FetchStrategy[FetchStrategy[\"LoadingBoundary\"] = 0] = \"LoadingBoundary\";\n    FetchStrategy[FetchStrategy[\"PPR\"] = 1] = \"PPR\";\n    FetchStrategy[FetchStrategy[\"PPRRuntime\"] = 2] = \"PPRRuntime\";\n    FetchStrategy[FetchStrategy[\"Full\"] = 3] = \"Full\";\n    return FetchStrategy;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=types.js.map"],"names":[],"mappings":"AAAA;;CAEC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,eAAe;IACf,qBAAqB;IACrB,kBAAkB;AACtB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,eAAe;QACX,OAAO;IACX;IACA,qBAAqB;QACjB,OAAO;IACX;IACA,kBAAkB;QACd,OAAO;IACX;AACJ;AACA,IAAI,sBAAsB,WAAW,GAAG,SAAS,mBAAmB;IAChE,mBAAmB,CAAC,mBAAmB,CAAC,MAAM,GAAG,EAAE,GAAG;IACtD,mBAAmB,CAAC,mBAAmB,CAAC,UAAU,GAAG,EAAE,GAAG;IAC1D,mBAAmB,CAAC,mBAAmB,CAAC,OAAO,GAAG,EAAE,GAAG;IACvD,mBAAmB,CAAC,mBAAmB,CAAC,QAAQ,GAAG,EAAE,GAAG;IACxD,OAAO;AACX,EAAE,CAAC;AACH,IAAI,mBAAmB,WAAW,GAAG,SAAS,gBAAgB;IAC1D;;;;;GAKD,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,SAAS,GAAG,EAAE,GAAG;IACrD;;GAED,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,UAAU,GAAG,EAAE,GAAG;IACtD;;;GAGD,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,aAAa,GAAG,EAAE,GAAG;IACzD,OAAO;AACX,EAAE,CAAC;AACH,IAAI,gBAAgB,WAAW,GAAG,SAAS,aAAa;IACpD,6DAA6D;IAC7D,+DAA+D;IAC/D,mDAAmD;IACnD,aAAa,CAAC,aAAa,CAAC,kBAAkB,GAAG,EAAE,GAAG;IACtD,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,EAAE,GAAG;IAC1C,aAAa,CAAC,aAAa,CAAC,aAAa,GAAG,EAAE,GAAG;IACjD,aAAa,CAAC,aAAa,CAAC,OAAO,GAAG,EAAE,GAAG;IAC3C,OAAO;AACX,EAAE,CAAC;AAEH,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 3709, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/lru.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    deleteFromLru: null,\n    lruPut: null,\n    updateLruSize: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    deleteFromLru: function() {\n        return deleteFromLru;\n    },\n    lruPut: function() {\n        return lruPut;\n    },\n    updateLruSize: function() {\n        return updateLruSize;\n    }\n});\nconst _cachemap = require(\"./cache-map\");\nlet head = null;\nlet didScheduleCleanup = false;\nlet lruSize = 0;\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n;\nfunction lruPut(node) {\n    if (head === node) {\n        // Already at the head\n        return;\n    }\n    const prev = node.prev;\n    const next = node.next;\n    if (next === null || prev === null) {\n        // This is an insertion\n        lruSize += node.size;\n        // Whenever we add an entry, we need to check if we've exceeded the\n        // max size. We don't evict entries immediately; they're evicted later in\n        // an asynchronous task.\n        ensureCleanupIsScheduled();\n    } else {\n        // This is a move. Remove from its current position.\n        prev.next = next;\n        next.prev = prev;\n    }\n    // Move to the front of the list\n    if (head === null) {\n        // This is the first entry\n        node.prev = node;\n        node.next = node;\n    } else {\n        // Add to the front of the list\n        const tail = head.prev;\n        node.prev = tail;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            tail.next = node;\n        }\n        node.next = head;\n        head.prev = node;\n    }\n    head = node;\n}\nfunction updateLruSize(node, newNodeSize) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size;\n    node.size = newNodeSize;\n    if (node.next === null) {\n        // This entry is not currently being tracked by the LRU.\n        return;\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize;\n    ensureCleanupIsScheduled();\n}\nfunction deleteFromLru(deleted) {\n    const next = deleted.next;\n    const prev = deleted.prev;\n    if (next !== null && prev !== null) {\n        lruSize -= deleted.size;\n        deleted.next = null;\n        deleted.prev = null;\n        // Remove from the list\n        if (head === deleted) {\n            // Update the head\n            if (next === head) {\n                // This was the last entry\n                head = null;\n            } else {\n                head = next;\n            }\n        } else {\n            prev.next = next;\n            next.prev = prev;\n        }\n    } else {\n    // Already deleted\n    }\n}\nfunction ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n        return;\n    }\n    didScheduleCleanup = true;\n    requestCleanupCallback(cleanup);\n}\nfunction cleanup() {\n    didScheduleCleanup = false;\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteFromLru` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9;\n    while(lruSize > ninetyPercentMax && head !== null){\n        const tail = head.prev;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            // Delete the entry from the map. In turn, this will remove it from\n            // the LRU.\n            (0, _cachemap.deleteFromCacheMap)(tail.value);\n        }\n    }\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=lru.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3852, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/cache-map.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    Fallback: null,\n    createCacheMap: null,\n    deleteFromCacheMap: null,\n    getFromCacheMap: null,\n    isValueExpired: null,\n    setInCacheMap: null,\n    setSizeInCacheMap: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Fallback: function() {\n        return Fallback;\n    },\n    createCacheMap: function() {\n        return createCacheMap;\n    },\n    deleteFromCacheMap: function() {\n        return deleteFromCacheMap;\n    },\n    getFromCacheMap: function() {\n        return getFromCacheMap;\n    },\n    isValueExpired: function() {\n        return isValueExpired;\n    },\n    setInCacheMap: function() {\n        return setInCacheMap;\n    },\n    setSizeInCacheMap: function() {\n        return setSizeInCacheMap;\n    }\n});\nconst _lru = require(\"./lru\");\nconst Fallback = {};\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {};\nfunction createCacheMap() {\n    const cacheMap = {\n        parent: null,\n        key: null,\n        value: null,\n        map: null,\n        // LRU-related fields\n        prev: null,\n        next: null,\n        size: 0\n    };\n    return cacheMap;\n}\nfunction getOrInitialize(cacheMap, keys, isRevalidation) {\n    // Go through each level of keys until we find the entry that matches, or\n    // create a new entry if one doesn't exist.\n    //\n    // This function will only return entries that match the keypath _exactly_.\n    // Unlike getWithFallback, it will not access fallback entries unless it's\n    // explicitly part of the keypath.\n    let entry = cacheMap;\n    let remainingKeys = keys;\n    let key = null;\n    while(true){\n        const previousKey = key;\n        if (remainingKeys !== null) {\n            key = remainingKeys.value;\n            remainingKeys = remainingKeys.parent;\n        } else if (isRevalidation && previousKey !== Revalidation) {\n            // During a revalidation, we append an internal \"Revalidation\" key to\n            // the end of the keypath. The \"normal\" entry is its parent.\n            // However, if the parent entry is currently empty, we don't need to store\n            // this as a revalidation entry. Just insert the revalidation into the\n            // normal slot.\n            if (entry.value === null) {\n                return entry;\n            }\n            // Otheriwse, create a child entry.\n            key = Revalidation;\n        } else {\n            break;\n        }\n        let map = entry.map;\n        if (map !== null) {\n            const existingEntry = map.get(key);\n            if (existingEntry !== undefined) {\n                // Found a match. Keep going.\n                entry = existingEntry;\n                continue;\n            }\n        } else {\n            map = new Map();\n            entry.map = map;\n        }\n        // No entry exists yet at this level. Create a new one.\n        const newEntry = {\n            parent: entry,\n            key,\n            value: null,\n            map: null,\n            // LRU-related fields\n            prev: null,\n            next: null,\n            size: 0\n        };\n        map.set(key, newEntry);\n        entry = newEntry;\n    }\n    return entry;\n}\nfunction getFromCacheMap(now, currentCacheVersion, rootEntry, keys, isRevalidation) {\n    const entry = getEntryWithFallbackImpl(now, currentCacheVersion, rootEntry, keys, isRevalidation, 0);\n    if (entry === null || entry.value === null) {\n        return null;\n    }\n    // This is an LRU access. Move the entry to the front of the list.\n    (0, _lru.lruPut)(entry);\n    return entry.value;\n}\nfunction isValueExpired(now, currentCacheVersion, value) {\n    return value.staleAt <= now || value.version < currentCacheVersion;\n}\nfunction lazilyEvictIfNeeded(now, currentCacheVersion, entry) {\n    // We have a matching entry, but before we can return it, we need to check if\n    // it's still fresh. Otherwise it should be treated the same as a cache miss.\n    if (entry.value === null) {\n        // This entry has no value, so there's nothing to evict.\n        return entry;\n    }\n    const value = entry.value;\n    if (isValueExpired(now, currentCacheVersion, value)) {\n        // The value expired. Lazily evict it from the cache, and return null. This\n        // is conceptually the same as a cache miss.\n        deleteMapEntry(entry);\n        return null;\n    }\n    // The matched entry has not expired. Return it.\n    return entry;\n}\nfunction getEntryWithFallbackImpl(now, currentCacheVersion, entry, keys, isRevalidation, previousKey) {\n    // This is similar to getExactEntry, but if an exact match is not found for\n    // a key, it will return the fallback entry instead. This is recursive at\n    // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n    // valid match for [a, b, c, d].\n    //\n    // It will return the most specific match available.\n    let key;\n    let remainingKeys;\n    if (keys !== null) {\n        key = keys.value;\n        remainingKeys = keys.parent;\n    } else if (isRevalidation && previousKey !== Revalidation) {\n        // During a revalidation, we append an internal \"Revalidation\" key to\n        // the end of the keypath.\n        key = Revalidation;\n        remainingKeys = null;\n    } else {\n        // There are no more keys. This is the terminal entry.\n        // TODO: When performing a lookup during a navigation, as opposed to a\n        // prefetch, we may want to skip entries that are Pending if there's also\n        // a Fulfilled fallback entry. Tricky to say, though, since if it's\n        // already pending, it's likely to stream in soon. Maybe we could do this\n        // just on slow connections and offline mode.\n        return lazilyEvictIfNeeded(now, currentCacheVersion, entry);\n    }\n    const map = entry.map;\n    if (map !== null) {\n        const existingEntry = map.get(key);\n        if (existingEntry !== undefined) {\n            // Found an exact match for this key. Keep searching.\n            const result = getEntryWithFallbackImpl(now, currentCacheVersion, existingEntry, remainingKeys, isRevalidation, key);\n            if (result !== null) {\n                return result;\n            }\n        }\n        // No match found for this key. Check if there's a fallback.\n        const fallbackEntry = map.get(Fallback);\n        if (fallbackEntry !== undefined) {\n            // Found a fallback for this key. Keep searching.\n            return getEntryWithFallbackImpl(now, currentCacheVersion, fallbackEntry, remainingKeys, isRevalidation, key);\n        }\n    }\n    return null;\n}\nfunction setInCacheMap(cacheMap, keys, value, isRevalidation) {\n    // Add a value to the map at the given keypath. If the value is already\n    // part of the map, it's removed from its previous keypath. (NOTE: This is\n    // unlike a regular JS map, but the behavior is intentional.)\n    const entry = getOrInitialize(cacheMap, keys, isRevalidation);\n    setMapEntryValue(entry, value);\n    // This is an LRU access. Move the entry to the front of the list.\n    (0, _lru.lruPut)(entry);\n    (0, _lru.updateLruSize)(entry, value.size);\n}\nfunction setMapEntryValue(entry, value) {\n    if (entry.value !== null) {\n        // There's already a value at the given keypath. Disconnect the old value\n        // from the map. We're not calling `deleteMapEntry` here because the\n        // entry itself is still in the map. We just want to overwrite its value.\n        dropRef(entry.value);\n        // Fill the entry with the updated value.\n        const emptyEntry = entry;\n        emptyEntry.value = null;\n        fillEmptyReference(emptyEntry, value);\n    } else {\n        fillEmptyReference(entry, value);\n    }\n}\nfunction fillEmptyReference(entry, value) {\n    // This value may already be in the map at a different keypath.\n    // Grab a reference before we overwrite it.\n    const oldEntry = value.ref;\n    const fullEntry = entry;\n    fullEntry.value = value;\n    value.ref = fullEntry;\n    (0, _lru.updateLruSize)(fullEntry, value.size);\n    if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n        // This value is already in the map at a different keypath in the map.\n        // Values only exist at a single keypath at a time. Remove it from the\n        // previous keypath.\n        //\n        // Note that only the internal map entry is garbage collected; we don't\n        // call `dropRef` here because it's still in the map, just\n        // at a new keypath (the one we just set, above).\n        deleteMapEntry(oldEntry);\n    }\n}\nfunction deleteFromCacheMap(value) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    dropRef(value);\n    deleteMapEntry(entry);\n}\nfunction dropRef(value) {\n    // Drop the value from the map by setting its `ref` backpointer to\n    // null. This is a separate operation from `deleteMapEntry` because when\n    // re-keying a value we need to be able to delete the old, internal map\n    // entry without garbage collecting the value itself.\n    value.ref = null;\n}\nfunction deleteMapEntry(entry) {\n    // Delete the entry from the cache.\n    const emptyEntry = entry;\n    emptyEntry.value = null;\n    (0, _lru.deleteFromLru)(entry);\n    // Check if we can garbage collect the entry.\n    const map = emptyEntry.map;\n    if (map === null) {\n        // Since this entry has no value, and also no child entries, we can\n        // garbage collect it. Remove it from its parent, and keep garbage\n        // collecting the parents until we reach a non-empty entry.\n        let parent = emptyEntry.parent;\n        let key = emptyEntry.key;\n        while(parent !== null){\n            const parentMap = parent.map;\n            if (parentMap !== null) {\n                parentMap.delete(key);\n                if (parentMap.size === 0) {\n                    // We just removed the last entry in the parent map.\n                    parent.map = null;\n                    if (parent.value === null) {\n                        // The parent node has no child entries, nor does it have a value\n                        // on itself. It can be garbage collected. Keep going.\n                        key = parent.key;\n                        parent = parent.parent;\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n    } else {\n        // Check if there's a revalidating entry. If so, promote it to a\n        // \"normal\" entry, since the normal one was just deleted.\n        const revalidatingEntry = map.get(Revalidation);\n        if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n            setMapEntryValue(emptyEntry, revalidatingEntry.value);\n        }\n    }\n}\nfunction setSizeInCacheMap(value, size) {\n    const entry = value.ref;\n    if (entry === null) {\n        // This value is not a member of any map.\n        return;\n    }\n    // Except during initialization (when the size is set to 0), this is the only\n    // place the `size` field should be updated, to ensure it's in sync with the\n    // the LRU.\n    value.size = size;\n    (0, _lru.updateLruSize)(entry, size);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=cache-map.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4164, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/vary-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    appendLayoutVaryPath: null,\n    clonePageVaryPathWithNewSearchParams: null,\n    finalizeLayoutVaryPath: null,\n    finalizeMetadataVaryPath: null,\n    finalizePageVaryPath: null,\n    getFulfilledRouteVaryPath: null,\n    getRouteVaryPath: null,\n    getSegmentVaryPathForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    appendLayoutVaryPath: function() {\n        return appendLayoutVaryPath;\n    },\n    clonePageVaryPathWithNewSearchParams: function() {\n        return clonePageVaryPathWithNewSearchParams;\n    },\n    finalizeLayoutVaryPath: function() {\n        return finalizeLayoutVaryPath;\n    },\n    finalizeMetadataVaryPath: function() {\n        return finalizeMetadataVaryPath;\n    },\n    finalizePageVaryPath: function() {\n        return finalizePageVaryPath;\n    },\n    getFulfilledRouteVaryPath: function() {\n        return getFulfilledRouteVaryPath;\n    },\n    getRouteVaryPath: function() {\n        return getRouteVaryPath;\n    },\n    getSegmentVaryPathForRequest: function() {\n        return getSegmentVaryPathForRequest;\n    }\n});\nconst _types = require(\"./types\");\nconst _cachemap = require(\"./cache-map\");\nconst _segmentvalueencoding = require(\"../../../shared/lib/segment-cache/segment-value-encoding\");\nfunction getRouteVaryPath(pathname, search, nextUrl) {\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: nextUrl,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nfunction getFulfilledRouteVaryPath(pathname, search, nextUrl, couldBeIntercepted) {\n    // This is called when a route's data is fulfilled. The cache entry will be\n    // re-keyed based on which inputs the response varies by.\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: couldBeIntercepted ? nextUrl : _cachemap.Fallback,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nfunction appendLayoutVaryPath(parentPath, cacheKey) {\n    const varyPathPart = {\n        value: cacheKey,\n        parent: parentPath\n    };\n    return varyPathPart;\n}\nfunction finalizeLayoutVaryPath(requestKey, varyPath) {\n    const layoutVaryPath = {\n        value: requestKey,\n        parent: varyPath\n    };\n    return layoutVaryPath;\n}\nfunction finalizePageVaryPath(requestKey, renderedSearch, varyPath) {\n    // Unlike layouts, a page segment's vary path also includes the search string.\n    // requestKey -> searchParams -> pathParams\n    const pageVaryPath = {\n        value: requestKey,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nfunction finalizeMetadataVaryPath(pageRequestKey, renderedSearch, varyPath) {\n    // The metadata \"segment\" is not a real segment because it doesn't exist in\n    // the normal structure of the route tree, but in terms of caching, it\n    // behaves like a page segment because it varies by all the same params as\n    // a page.\n    //\n    // To keep the protocol for querying the server simple, the request key for\n    // the metadata does not include any path information. It's unnecessary from\n    // the server's perspective, because unlike page segments, there's only one\n    // metadata response per URL, i.e. there's no need to distinguish multiple\n    // parallel pages.\n    //\n    // However, this means the metadata request key is insufficient for\n    // caching the the metadata in the client cache, because on the client we\n    // use the request key to distinguish the metadata entry from all other\n    // page's metadata entries.\n    //\n    // So instead we create a simulated request key based on the page segment.\n    // Conceptually this is equivalent to the request key the server would have\n    // assigned the metadata segment if it treated it as part of the actual\n    // route structure.\n    // If there are multiple parallel pages, we use whichever is the first one.\n    // This is fine because the only difference between request keys for\n    // different parallel pages are things like route groups and parallel\n    // route slots. As long as it's always the same one, it doesn't matter.\n    const pageVaryPath = {\n        // Append the actual metadata request key to the page request key. Note\n        // that we're not using a separate vary path part; it's unnecessary because\n        // these are not conceptually separate inputs.\n        value: pageRequestKey + _segmentvalueencoding.HEAD_REQUEST_KEY,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nfunction getSegmentVaryPathForRequest(fetchStrategy, tree) {\n    // This is used for storing pending requests in the cache. We want to choose\n    // the most generic vary path based on the strategy used to fetch it, i.e.\n    // static/PPR versus runtime prefetching, so that it can be reused as much\n    // as possible.\n    //\n    // We may be able to re-key the response to something even more generic once\n    // we receive it  for example, if the server tells us that the response\n    // doesn't vary on a particular param  but even before we send the request,\n    // we know some params are reusable based on the fetch strategy alone. For\n    // example, a static prefetch will never vary on search params.\n    //\n    // The original vary path with all the params filled in is stored on the\n    // route tree object. We will clone this one to create a new vary path\n    // where certain params are replaced with Fallback.\n    //\n    // This result of this function is not stored anywhere. It's only used to\n    // access the cache a single time.\n    //\n    // TODO: Rather than create a new list object just to access the cache, the\n    // plan is to add the concept of a \"vary mask\". This will represent all the\n    // params that can be treated as Fallback. (Or perhaps the inverse.)\n    const originalVaryPath = tree.varyPath;\n    // Only page segments (and the special \"metadata\" segment, which is treated\n    // like a page segment for the purposes of caching) may contain search\n    // params. There's no reason to include them in the vary path otherwise.\n    if (tree.isPage) {\n        // Only a runtime prefetch will include search params in the vary path.\n        // Static prefetches never include search params, so they can be reused\n        // across all possible search param values.\n        const doesVaryOnSearchParams = fetchStrategy === _types.FetchStrategy.Full || fetchStrategy === _types.FetchStrategy.PPRRuntime;\n        if (!doesVaryOnSearchParams) {\n            // The response from the the server will not vary on search params. Clone\n            // the end of the original vary path to replace the search params\n            // with Fallback.\n            //\n            // requestKey -> searchParams -> pathParams\n            //               ^ This part gets replaced with Fallback\n            const searchParamsVaryPath = originalVaryPath.parent;\n            const pathParamsVaryPath = searchParamsVaryPath.parent;\n            const patchedVaryPath = {\n                value: originalVaryPath.value,\n                parent: {\n                    value: _cachemap.Fallback,\n                    parent: pathParamsVaryPath\n                }\n            };\n            return patchedVaryPath;\n        }\n    }\n    // The request does vary on search params. We don't need to modify anything.\n    return originalVaryPath;\n}\nfunction clonePageVaryPathWithNewSearchParams(originalVaryPath, newSearch) {\n    // requestKey -> searchParams -> pathParams\n    //               ^ This part gets replaced with newSearch\n    const searchParamsVaryPath = originalVaryPath.parent;\n    const clonedVaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n            value: newSearch,\n            parent: searchParamsVaryPath.parent\n        }\n    };\n    return clonedVaryPath;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=vary-path.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4382, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/cache-key.js"],"sourcesContent":["// TypeScript trick to simulate opaque types, like in Flow.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createCacheKey\", {\n    enumerable: true,\n    get: function() {\n        return createCacheKey;\n    }\n});\nfunction createCacheKey(originalHref, nextUrl) {\n    const originalUrl = new URL(originalHref);\n    const cacheKey = {\n        pathname: originalUrl.pathname,\n        search: originalUrl.search,\n        nextUrl: nextUrl\n    };\n    return cacheKey;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=cache-key.js.map"],"names":[],"mappings":"AAAA,2DAA2D;AAE3D,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,eAAe,YAAY,EAAE,OAAO;IACzC,MAAM,cAAc,IAAI,IAAI;IAC5B,MAAM,WAAW;QACb,UAAU,YAAY,QAAQ;QAC9B,QAAQ,YAAY,MAAM;QAC1B,SAAS;IACb;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 4412, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/scheduler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    cancelPrefetchTask: null,\n    isPrefetchTaskDirty: null,\n    pingPrefetchTask: null,\n    reschedulePrefetchTask: null,\n    schedulePrefetchTask: null,\n    startRevalidationCooldown: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    isPrefetchTaskDirty: function() {\n        return isPrefetchTaskDirty;\n    },\n    pingPrefetchTask: function() {\n        return pingPrefetchTask;\n    },\n    reschedulePrefetchTask: function() {\n        return reschedulePrefetchTask;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    },\n    startRevalidationCooldown: function() {\n        return startRevalidationCooldown;\n    }\n});\nconst _approutertypes = require(\"../../../shared/lib/app-router-types\");\nconst _matchsegments = require(\"../match-segments\");\nconst _cache = require(\"./cache\");\nconst _varypath = require(\"./vary-path\");\nconst _cachekey = require(\"./cache-key\");\nconst _types = require(\"./types\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn)=>Promise.resolve().then(fn).catch((error)=>setTimeout(()=>{\n            throw error;\n        }));\nconst taskHeap = [];\nlet inProgressRequests = 0;\nlet sortIdCounter = 0;\nlet didScheduleMicrotask = false;\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink = null;\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300;\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle = null;\nfunction startRevalidationCooldown() {\n    // Clear any existing timeout in case multiple revalidations happen\n    // in quick succession.\n    if (revalidationCooldownTimeoutHandle !== null) {\n        clearTimeout(revalidationCooldownTimeoutHandle);\n    }\n    // Schedule the cooldown to expire after the delay.\n    revalidationCooldownTimeoutHandle = setTimeout(()=>{\n        revalidationCooldownTimeoutHandle = null;\n        // Retry the prefetch queue now that the cooldown has expired.\n        ensureWorkIsScheduled();\n    }, REVALIDATION_COOLDOWN_MS);\n}\nfunction schedulePrefetchTask(key, treeAtTimeOfPrefetch, fetchStrategy, priority, onInvalidate) {\n    // Spawn a new prefetch task\n    const task = {\n        key,\n        treeAtTimeOfPrefetch,\n        cacheVersion: (0, _cache.getCurrentCacheVersion)(),\n        priority,\n        phase: 1,\n        hasBackgroundWork: false,\n        spawnedRuntimePrefetches: null,\n        fetchStrategy,\n        sortId: sortIdCounter++,\n        isCanceled: false,\n        onInvalidate,\n        _heapIndex: -1\n    };\n    trackMostRecentlyHoveredLink(task);\n    heapPush(taskHeap, task);\n    // Schedule an async task to process the queue.\n    //\n    // The main reason we process the queue in an async task is for batching.\n    // It's common for a single JS task/event to trigger multiple prefetches.\n    // By deferring to a microtask, we only process the queue once per JS task.\n    // If they have different priorities, it also ensures they are processed in\n    // the optimal order.\n    ensureWorkIsScheduled();\n    return task;\n}\nfunction cancelPrefetchTask(task) {\n    // Remove the prefetch task from the queue. If the task already completed,\n    // then this is a no-op.\n    //\n    // We must also explicitly mark the task as canceled so that a blocked task\n    // does not get added back to the queue when it's pinged by the network.\n    task.isCanceled = true;\n    heapDelete(taskHeap, task);\n}\nfunction reschedulePrefetchTask(task, treeAtTimeOfPrefetch, fetchStrategy, priority) {\n    // Bump the prefetch task to the top of the queue, as if it were a fresh\n    // task. This is essentially the same as canceling the task and scheduling\n    // a new one, except it reuses the original object.\n    //\n    // The primary use case is to increase the priority of a Link-initated\n    // prefetch on hover.\n    // Un-cancel the task, in case it was previously canceled.\n    task.isCanceled = false;\n    task.phase = 1;\n    // Assign a new sort ID to move it ahead of all other tasks at the same\n    // priority level. (Higher sort IDs are processed first.)\n    task.sortId = sortIdCounter++;\n    task.priority = // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? _types.PrefetchPriority.Intent : priority;\n    task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch;\n    task.fetchStrategy = fetchStrategy;\n    trackMostRecentlyHoveredLink(task);\n    if (task._heapIndex !== -1) {\n        // The task is already in the queue.\n        heapResift(taskHeap, task);\n    } else {\n        heapPush(taskHeap, task);\n    }\n    ensureWorkIsScheduled();\n}\nfunction isPrefetchTaskDirty(task, nextUrl, tree) {\n    // This is used to quickly bail out of a prefetch task if the result is\n    // guaranteed to not have changed since the task was initiated. This is\n    // strictly an optimization  theoretically, if it always returned true, no\n    // behavior should change because a full prefetch task will effectively\n    // perform the same checks.\n    const currentCacheVersion = (0, _cache.getCurrentCacheVersion)();\n    return task.cacheVersion !== currentCacheVersion || task.treeAtTimeOfPrefetch !== tree || task.key.nextUrl !== nextUrl;\n}\nfunction trackMostRecentlyHoveredLink(task) {\n    // Track the mostly recently hovered link, i.e. the most recently scheduled\n    // task at Intent priority. There must only be one such task at a time.\n    if (task.priority === _types.PrefetchPriority.Intent && task !== mostRecentlyHoveredLink) {\n        if (mostRecentlyHoveredLink !== null) {\n            // Bump the previously hovered link's priority down to Default.\n            if (mostRecentlyHoveredLink.priority !== _types.PrefetchPriority.Background) {\n                mostRecentlyHoveredLink.priority = _types.PrefetchPriority.Default;\n                heapResift(taskHeap, mostRecentlyHoveredLink);\n            }\n        }\n        mostRecentlyHoveredLink = task;\n    }\n}\nfunction ensureWorkIsScheduled() {\n    if (didScheduleMicrotask) {\n        // Already scheduled a task to process the queue\n        return;\n    }\n    didScheduleMicrotask = true;\n    scheduleMicrotask(processQueueInMicrotask);\n}\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */ function hasNetworkBandwidth(task) {\n    // Check if we're within the revalidation cooldown window\n    if (revalidationCooldownTimeoutHandle !== null) {\n        // We're within the cooldown window. Return false to prevent prefetching.\n        // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n        // to retry the queue.\n        return false;\n    }\n    // TODO: Also check if there's an in-progress navigation. We should never\n    // add prefetch requests to the network queue if an actual navigation is\n    // taking place, to ensure there's sufficient bandwidth for render-blocking\n    // data and resources.\n    // TODO: Consider reserving some amount of bandwidth for static prefetches.\n    if (task.priority === _types.PrefetchPriority.Intent) {\n        // The most recently hovered link is allowed to exceed the default limit.\n        //\n        // The goal is to always have enough bandwidth to start a new prefetch\n        // request when hovering over a link.\n        //\n        // However, because we don't abort in-progress requests, it's still possible\n        // we'll run out of bandwidth. When links are hovered in quick succession,\n        // there could be multiple hover requests running simultaneously.\n        return inProgressRequests < 12;\n    }\n    // The default limit is lower than the limit for a hovered link.\n    return inProgressRequests < 4;\n}\nfunction spawnPrefetchSubtask(prefetchSubtask) {\n    // When the scheduler spawns an async task, we don't await its result.\n    // Instead, the async task writes its result directly into the cache, then\n    // pings the scheduler to continue.\n    //\n    // We process server responses streamingly, so the prefetch subtask will\n    // likely resolve before we're finished receiving all the data. The subtask\n    // result includes a promise that resolves once the network connection is\n    // closed. The scheduler uses this to control network bandwidth by tracking\n    // and limiting the number of concurrent requests.\n    inProgressRequests++;\n    return prefetchSubtask.then((result)=>{\n        if (result === null) {\n            // The prefetch task errored before it could start processing the\n            // network stream. Assume the connection is closed.\n            onPrefetchConnectionClosed();\n            return null;\n        }\n        // Wait for the connection to close before freeing up more bandwidth.\n        result.closed.then(onPrefetchConnectionClosed);\n        return result.value;\n    });\n}\nfunction onPrefetchConnectionClosed() {\n    inProgressRequests--;\n    // Notify the scheduler that we have more bandwidth, and can continue\n    // processing tasks.\n    ensureWorkIsScheduled();\n}\nfunction pingPrefetchTask(task) {\n    // \"Ping\" a prefetch that's already in progress to notify it of new data.\n    if (// Check if prefetch was canceled.\n    task.isCanceled || // Check if prefetch is already queued.\n    task._heapIndex !== -1) {\n        return;\n    }\n    // Add the task back to the queue.\n    heapPush(taskHeap, task);\n    ensureWorkIsScheduled();\n}\nfunction processQueueInMicrotask() {\n    didScheduleMicrotask = false;\n    // We aim to minimize how often we read the current time. Since nearly all\n    // functions in the prefetch scheduler are synchronous, we can read the time\n    // once and pass it as an argument wherever it's needed.\n    const now = Date.now();\n    // Process the task queue until we run out of network bandwidth.\n    let task = heapPeek(taskHeap);\n    while(task !== null && hasNetworkBandwidth(task)){\n        task.cacheVersion = (0, _cache.getCurrentCacheVersion)();\n        const exitStatus = pingRoute(now, task);\n        // These fields are only valid for a single attempt. Reset them after each\n        // iteration of the task queue.\n        const hasBackgroundWork = task.hasBackgroundWork;\n        task.hasBackgroundWork = false;\n        task.spawnedRuntimePrefetches = null;\n        switch(exitStatus){\n            case 0:\n                // The task yielded because there are too many requests in progress.\n                // Stop processing tasks until we have more bandwidth.\n                return;\n            case 1:\n                // The task is blocked. It needs more data before it can proceed.\n                // Keep the task out of the queue until the server responds.\n                heapPop(taskHeap);\n                // Continue to the next task\n                task = heapPeek(taskHeap);\n                continue;\n            case 2:\n                if (task.phase === 1) {\n                    // Finished prefetching the route tree. Proceed to prefetching\n                    // the segments.\n                    task.phase = 0;\n                    heapResift(taskHeap, task);\n                } else if (hasBackgroundWork) {\n                    // The task spawned additional background work. Reschedule the task\n                    // at background priority.\n                    task.priority = _types.PrefetchPriority.Background;\n                    heapResift(taskHeap, task);\n                } else {\n                    // The prefetch is complete. Continue to the next task.\n                    heapPop(taskHeap);\n                }\n                task = heapPeek(taskHeap);\n                continue;\n            default:\n                exitStatus;\n        }\n    }\n}\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */ function background(task) {\n    if (task.priority === _types.PrefetchPriority.Background) {\n        return true;\n    }\n    task.hasBackgroundWork = true;\n    return false;\n}\nfunction pingRoute(now, task) {\n    const key = task.key;\n    const route = (0, _cache.readOrCreateRouteCacheEntry)(now, task, key);\n    const exitStatus = pingRootRouteTree(now, task, route);\n    if (exitStatus !== 0 && key.search !== '') {\n        // If the URL has a non-empty search string, also prefetch the pathname\n        // without the search string. We use the searchless route tree as a base for\n        // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n        //\n        // Note that we don't need to prefetch any of the segment data. Just the\n        // route tree.\n        //\n        // TODO: This is a temporary solution; the plan is to replace this by adding\n        // a wildcard lookup method to the TupleMap implementation. This is\n        // non-trivial to implement because it needs to account for things like\n        // fallback route entries, hence this temporary workaround.\n        const url = new URL(key.pathname, location.origin);\n        const keyWithoutSearch = (0, _cachekey.createCacheKey)(url.href, key.nextUrl);\n        const routeWithoutSearch = (0, _cache.readOrCreateRouteCacheEntry)(now, task, keyWithoutSearch);\n        switch(routeWithoutSearch.status){\n            case _cache.EntryStatus.Empty:\n                {\n                    if (background(task)) {\n                        routeWithoutSearch.status = _cache.EntryStatus.Pending;\n                        spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(routeWithoutSearch, task, keyWithoutSearch));\n                    }\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                {\n                    break;\n                }\n            default:\n                routeWithoutSearch;\n        }\n    }\n    return exitStatus;\n}\nfunction pingRootRouteTree(now, task, route) {\n    switch(route.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // Route is not yet cached, and there's no request already in progress.\n                // Spawn a task to request the route, load it into the cache, and ping\n                // the task to continue.\n                // TODO: There are multiple strategies in the <Link> API for prefetching\n                // a route. Currently we've only implemented the main one: per-segment,\n                // static-data only.\n                //\n                // There's also `<Link prefetch={true}>`\n                // which prefetch both static *and* dynamic data.\n                // Similarly, we need to fallback to the old, per-page\n                // behavior if PPR is disabled for a route (via the incremental opt-in).\n                //\n                // Those cases will be handled here.\n                spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(route, task, task.key));\n                // If the request takes longer than a minute, a subsequent request should\n                // retry instead of waiting for this one. When the response is received,\n                // this value will be replaced by a new value based on the stale time sent\n                // from the server.\n                // TODO: We should probably also manually abort the fetch task, to reclaim\n                // server bandwidth.\n                route.staleAt = now + 60 * 1000;\n                // Upgrade to Pending so we know there's already a request in progress\n                route.status = _cache.EntryStatus.Pending;\n            // Intentional fallthrough to the Pending branch\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                // Still pending. We can't start prefetching the segments until the route\n                // tree has loaded. Add the task to the set of blocked tasks so that it\n                // is notified when the route tree is ready.\n                const blockedTasks = route.blockedTasks;\n                if (blockedTasks === null) {\n                    route.blockedTasks = new Set([\n                        task\n                    ]);\n                } else {\n                    blockedTasks.add(task);\n                }\n                return 1;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // Route tree failed to load. Treat as a 404.\n                return 2;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                if (task.phase !== 0) {\n                    // Do not prefetch segment data until we've entered the segment phase.\n                    return 2;\n                }\n                // Recursively fill in the segment tree.\n                if (!hasNetworkBandwidth(task)) {\n                    // Stop prefetching segments until there's more bandwidth.\n                    return 0;\n                }\n                const tree = route.tree;\n                // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n                // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n                // We don't need to do this for runtime prefetches, because those are only available in\n                // `cacheComponents`, where every route is PPR.\n                const fetchStrategy = task.fetchStrategy === _types.FetchStrategy.PPR ? route.isPPREnabled ? _types.FetchStrategy.PPR : _types.FetchStrategy.LoadingBoundary : task.fetchStrategy;\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                        {\n                            // For Cache Components pages, each segment may be prefetched\n                            // statically or using a runtime request, based on various\n                            // configurations and heuristics. We'll do this in two passes: first\n                            // traverse the tree and perform all the static prefetches.\n                            //\n                            // Then, if there are any segments that need a runtime request,\n                            // do another pass to perform a runtime prefetch.\n                            pingStaticHead(now, task, route);\n                            const exitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, task.treeAtTimeOfPrefetch, tree);\n                            if (exitStatus === 0) {\n                                // Child yielded without finishing.\n                                return 0;\n                            }\n                            const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches;\n                            if (spawnedRuntimePrefetches !== null) {\n                                // During the first pass, we discovered segments that require a\n                                // runtime prefetch. Do a second pass to construct a request tree.\n                                const spawnedEntries = new Map();\n                                pingRuntimeHead(now, task, route, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n                                const requestTree = pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries);\n                                let needsDynamicRequest = spawnedEntries.size > 0;\n                                if (needsDynamicRequest) {\n                                    // Perform a dynamic prefetch request and populate the cache with\n                                    // the result.\n                                    spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, _types.FetchStrategy.PPRRuntime, requestTree, spawnedEntries));\n                                }\n                            }\n                            return 2;\n                        }\n                    case _types.FetchStrategy.Full:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // Prefetch multiple segments using a single dynamic request.\n                            // TODO: We can consolidate this branch with previous one by modeling\n                            // it as if the first segment in the new tree has runtime prefetching\n                            // enabled. Will do this as a follow-up refactor. Might want to remove\n                            // the special metatdata case below first. In the meantime, it's not\n                            // really that much duplication, just would be nice to remove one of\n                            // these codepaths.\n                            const spawnedEntries = new Map();\n                            pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy);\n                            const dynamicRequestTree = diffRouteTreeAgainstCurrent(now, task, route, task.treeAtTimeOfPrefetch, tree, spawnedEntries, fetchStrategy);\n                            let needsDynamicRequest = spawnedEntries.size > 0;\n                            if (needsDynamicRequest) {\n                                spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries));\n                            }\n                            return 2;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n                break;\n            }\n        default:\n            {\n                route;\n            }\n    }\n    return 2;\n}\nfunction pingStaticHead(now, task, route) {\n    // The Head data for a page (metadata, viewport) is not really a route\n    // segment, in the sense that it doesn't appear in the route tree. But we\n    // store it in the cache as if it were, using a special key.\n    pingStaticSegmentData(now, task, route, (0, _cache.readOrCreateSegmentCacheEntry)(now, _types.FetchStrategy.PPR, route, route.metadata), task.key, route.metadata);\n}\nfunction pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy) {\n    pingRouteTreeAndIncludeDynamicData(now, task, route, route.metadata, false, spawnedEntries, // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === _types.FetchStrategy.LoadingBoundary ? _types.FetchStrategy.Full : fetchStrategy);\n}\n// TODO: Rename dynamic -> runtime throughout this module\nfunction pingSharedPartOfCacheComponentsTree(now, task, route, oldTree, newTree) {\n    // When Cache Components is enabled (or PPR, or a fully static route when PPR\n    // is disabled; those cases are treated equivalently to Cache Components), we\n    // start by prefetching each segment individually. Once we reach the \"new\"\n    // part of the tree  the part that doesn't exist on the current page  we\n    // may choose to switch to a runtime prefetch instead, based on the\n    // information sent by the server in the route tree.\n    //\n    // The traversal starts in the \"shared\" part of the tree. Once we reach the\n    // \"new\" part of the tree, we switch to a different traversal,\n    // pingNewPartOfCacheComponentsTree.\n    // Prefetch this segment's static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, newTree);\n    pingStaticSegmentData(now, task, route, segment, task.key, newTree);\n    // Recursively ping the children.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            if (!hasNetworkBandwidth(task)) {\n                // Stop prefetching segments until there's more bandwidth.\n                return 0;\n            }\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            let childExitStatus;\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // We're still in the \"shared\" part of the tree.\n                childExitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, oldTreeChild, newTreeChild);\n            } else {\n                // We've entered the \"new\" part of the tree. Switch\n                // traversal functions.\n                childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, newTreeChild);\n            }\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    return 2;\n}\nfunction pingNewPartOfCacheComponentsTree(now, task, route, tree) {\n    // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n    // exist on the current page. (In other words, we're deeper than the\n    // shared layouts.) Segments in here default to being prefetched statically.\n    // However, if the server instructs us to, we may switch to a runtime\n    // prefetch instead. Traverse the tree and check at each segment.\n    if (tree.hasRuntimePrefetch) {\n        // This route has a runtime prefetch response. Since we're below the shared\n        // layout, everything from this point should be prefetched using a single,\n        // combined runtime request, rather than using per-segment static requests.\n        // This is true even if some of the child segments are known to be fully\n        // static  once we've decided to perform a runtime prefetch, we might as\n        // well respond with the static segments in the same roundtrip. (That's how\n        // regular navigations work, too.) We'll still skip over segments that are\n        // already cached, though.\n        //\n        // It's the server's responsibility to set a reasonable value of\n        // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n        // server may send a value of `false` even if the user opts in, if it\n        // determines during build that the route is always fully static. There are\n        // more optimizations we can do once we implement fallback param\n        // tracking, too.\n        //\n        // Use the task object to collect the segments that need a runtime prefetch.\n        // This will signal to the outer task queue that a second traversal is\n        // required to construct a request tree.\n        if (task.spawnedRuntimePrefetches === null) {\n            task.spawnedRuntimePrefetches = new Set([\n                tree.requestKey\n            ]);\n        } else {\n            task.spawnedRuntimePrefetches.add(tree.requestKey);\n        }\n        // Then exit the traversal without prefetching anything further.\n        return 2;\n    }\n    // This segment should not be runtime prefetched. Prefetch its static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    pingStaticSegmentData(now, task, route, segment, task.key, tree);\n    if (tree.slots !== null) {\n        if (!hasNetworkBandwidth(task)) {\n            // Stop prefetching segments until there's more bandwidth.\n            return 0;\n        }\n        // Recursively ping the children.\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            const childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, childTree);\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    // This segment and all its children have finished prefetching.\n    return 2;\n}\nfunction diffRouteTreeAgainstCurrent(now, task, route, oldTree, newTree, spawnedEntries, fetchStrategy) {\n    // This is a single recursive traversal that does multiple things:\n    // - Finds the parts of the target route (newTree) that are not part of\n    //   of the current page (oldTree) by diffing them, using the same algorithm\n    //   as a real navigation.\n    // - Constructs a request tree (FlightRouterState) that describes which\n    //   segments need to be prefetched and which ones are already cached.\n    // - Creates a set of pending cache entries for the segments that need to\n    //   be prefetched, so that a subsequent prefetch task does not request the\n    //   same segments again.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    let requestTreeChildren = {};\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // This segment is already part of the current route. Keep traversing.\n                const requestTreeChild = diffRouteTreeAgainstCurrent(now, task, route, oldTreeChild, newTreeChild, spawnedEntries, fetchStrategy);\n                requestTreeChildren[parallelRouteKey] = requestTreeChild;\n            } else {\n                // This segment is not part of the current route. We're entering a\n                // part of the tree that we need to prefetch (unless everything is\n                // already cached).\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // When PPR is disabled, we can't prefetch per segment. We must\n                            // fallback to the old prefetch behavior and send a dynamic request.\n                            // Only routes that include a loading boundary can be prefetched in\n                            // this way.\n                            //\n                            // This is simlar to a \"full\" prefetch, but we're much more\n                            // conservative about which segments to include in the request.\n                            //\n                            // The server will only render up to the first loading boundary\n                            // inside new part of the tree. If there's no loading boundary\n                            // anywhere in the tree, the server will never return any data, so\n                            // we can skip the request.\n                            const subtreeHasLoadingBoundary = newTreeChild.hasLoadingBoundary !== _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary;\n                            const requestTreeChild = subtreeHasLoadingBoundary ? pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, newTreeChild, null, spawnedEntries) : (0, _cache.convertRouteTreeToFlightRouterState)(newTreeChild);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.PPRRuntime:\n                        {\n                            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n                            // not just the static PPR shell.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.Full:\n                        {\n                            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n                            // static and dynamic. We issue roughly the same request that we\n                            // would during a real navigation. The goal is that once the\n                            // navigation occurs, the router should not have to fetch any\n                            // additional data.\n                            //\n                            // Although the response will include dynamic data, opting into a\n                            // Full prefetch  via <Link prefetch={true}>  implicitly\n                            // instructs the cache to treat the response as \"static\", or non-\n                            // dynamic, since the whole point is to cache it for\n                            // future navigations.\n                            //\n                            // Construct a tree (currently a FlightRouterState) that represents\n                            // which segments need to be prefetched and which ones are already\n                            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n                            // send the request tree to the server and use the response to\n                            // populate the segment cache.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n            }\n        }\n    }\n    const requestTree = [\n        newTree.segment,\n        requestTreeChildren,\n        null,\n        null,\n        newTree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, tree, refetchMarkerContext, spawnedEntries) {\n    // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n    // server is only going to return a minimal loading state  it will stop\n    // rendering at the first loading boundary. Whereas a Full prefetch is\n    // intentionally aggressive and tries to pretfetch all the data that will be\n    // needed for a navigation, a LoadingBoundary prefetch is much more\n    // conservative. For example, it will omit from the request tree any segment\n    // that is already cached, regardles of whether it's partial or full. By\n    // contrast, a Full prefetch will refetch partial segments.\n    // \"inside-shared-layout\" tells the server where to start looking for a\n    // loading boundary.\n    let refetchMarker = refetchMarkerContext === null ? 'inside-shared-layout' : null;\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Add a refetch marker so the server knows\n                // to start rendering here.\n                // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n                // FlightRouterState from the request tree. I think this would probably\n                // already work even without any updates to the server. For consistency,\n                // though, I'll send the full tree and we'll look into this later as part\n                // of a larger redesign of the request protocol.\n                // Add the pending cache entry to the result map.\n                spawnedEntries.set(tree.requestKey, (0, _cache.upgradeToPendingSegment)(segment, // Set the fetch strategy to LoadingBoundary to indicate that the server\n                // might not include it in the pending response. If another route is able\n                // to issue a per-segment request, we'll do that in the background.\n                _types.FetchStrategy.LoadingBoundary));\n                if (refetchMarkerContext !== 'refetch') {\n                    refetchMarker = refetchMarkerContext = 'refetch';\n                } else {\n                // There's already a parent with a refetch marker, so we don't need\n                // to add another one.\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                const segmentHasLoadingBoundary = tree.hasLoadingBoundary === _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary;\n                if (segmentHasLoadingBoundary) {\n                    // This segment has a loading boundary, which means the server won't\n                    // render its children. So there's nothing left to prefetch along this\n                    // path. We can bail out.\n                    return (0, _cache.convertRouteTreeToFlightRouterState)(tree);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, childTree, refetchMarkerContext, spawnedEntries);\n        }\n    }\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRouteTreeAndIncludeDynamicData(now, task, route, tree, isInsideRefetchingParent, spawnedEntries, fetchStrategy) {\n    // The tree we're constructing is the same shape as the tree we're navigating\n    // to. But even though this is a \"new\" tree, some of the individual segments\n    // may be cached as a result of other route prefetches.\n    //\n    // So we need to find the first uncached segment along each path add an\n    // explicit \"refetch\" marker so the server knows where to start rendering.\n    // Once the server starts rendering along a path, it keeps rendering the\n    // entire subtree.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy, route, tree);\n    let spawnedSegment = null;\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Include it in the request.\n                spawnedSegment = (0, _cache.upgradeToPendingSegment)(segment, fetchStrategy);\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                if (segment.isPartial && (0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n                    // This means we're in one of these cases:\n                    //   - we have a static prefetch, and we're doing a runtime prefetch\n                    //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n                    // In either case, we need to include it in the request to get a more specific (or full) version.\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n        case _cache.EntryStatus.Rejected:\n            {\n                // There's either another prefetch currently in progress, or the previous\n                // attempt failed. If the new strategy can provide more content, fetch it again.\n                if ((0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRouteTreeAndIncludeDynamicData(now, task, route, childTree, isInsideRefetchingParent || spawnedSegment !== null, spawnedEntries, fetchStrategy);\n        }\n    }\n    if (spawnedSegment !== null) {\n        // Add the pending entry to the result map.\n        spawnedEntries.set(tree.requestKey, spawnedSegment);\n    }\n    // Don't bother to add a refetch marker if one is already present in a parent.\n    const refetchMarker = !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null;\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries) {\n    // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n    // a segment is part of the runtime prefetch, the tree is constructed by\n    // diffing against what's already in the prefetch cache. Otherwise, we send\n    // a regular FlightRouterState with no special markers.\n    //\n    // See pingRouteTreeAndIncludeDynamicData for details.\n    if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n        // This segment needs a runtime prefetch.\n        return pingRouteTreeAndIncludeDynamicData(now, task, route, tree, false, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n    }\n    let requestTreeChildren = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(now, task, route, childTree, spawnedRuntimePrefetches, spawnedEntries);\n        }\n    }\n    // This segment is not part of the runtime prefetch. Clone the base tree.\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        null\n    ];\n    return requestTree;\n}\nfunction pingStaticSegmentData(now, task, route, segment, routeKey, tree) {\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            // Upgrade to Pending so we know there's already a request in progress\n            spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(segment, _types.FetchStrategy.PPR), routeKey, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            {\n                // There's already a request in progress. Depending on what kind of\n                // request it is, we may want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a pending request, but because it's using the old\n                        // prefetching strategy, we can't be sure if it will be fulfilled by\n                        // the response  it might be inside the loading boundary. Perform\n                        // a revalidation, but because it's speculative, wait to do it at\n                        // background priority.\n                        if (background(task)) {\n                            // TODO: Instead of speculatively revalidating, consider including\n                            // `hasLoading` in the route tree prefetch response.\n                            pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        }\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // The existing entry in the cache was rejected. Depending on how it\n                // was originally fetched, we may or may not want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a rejected entry, but it was fetched using the loading\n                        // boundary strategy. So the reason it wasn't returned by the server\n                        // might just be because it was inside a loading boundary. Or because\n                        // there was a dynamic rewrite. Revalidate it using the per-\n                        // segment strategy.\n                        //\n                        // Because a rejected segment will definitely prevent the segment (and\n                        // all of its children) from rendering, we perform this revalidation\n                        // immediately instead of deferring it to a background task.\n                        pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            break;\n        default:\n            segment;\n    }\n// Segments do not have dependent tasks, so once the prefetch is initiated,\n// there's nothing else for us to do (except write the server data into the\n// entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\nfunction pingPPRSegmentRevalidation(now, route, routeKey, tree) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, _types.FetchStrategy.PPR, route, tree);\n    switch(revalidatingSegment.status){\n        case _cache.EntryStatus.Empty:\n            // Spawn a prefetch request and upsert the segment into the cache\n            // upon completion.\n            upsertSegmentOnCompletion(spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(revalidatingSegment, _types.FetchStrategy.PPR), routeKey, tree)), (0, _varypath.getSegmentVaryPathForRequest)(_types.FetchStrategy.PPR, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            break;\n        case _cache.EntryStatus.Fulfilled:\n        case _cache.EntryStatus.Rejected:\n            break;\n        default:\n            revalidatingSegment;\n    }\n}\nfunction pingFullSegmentRevalidation(now, route, tree, fetchStrategy) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, fetchStrategy, route, tree);\n    if (revalidatingSegment.status === _cache.EntryStatus.Empty) {\n        // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n        // segments that we need. So we don't initiate a request here directly. By\n        // returning a pending entry from this function, it signals to the caller\n        // that this segment should be included in the request that's sent to\n        // the server.\n        const pendingSegment = (0, _cache.upgradeToPendingSegment)(revalidatingSegment, fetchStrategy);\n        upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n        return pendingSegment;\n    } else {\n        // There's already a revalidation in progress.\n        const nonEmptyRevalidatingSegment = revalidatingSegment;\n        if ((0, _cache.canNewFetchStrategyProvideMoreContent)(nonEmptyRevalidatingSegment.fetchStrategy, fetchStrategy)) {\n            // The existing revalidation was fetched using a less specific strategy.\n            // Reset it and start a new revalidation.\n            const emptySegment = (0, _cache.overwriteRevalidatingSegmentCacheEntry)(fetchStrategy, route, tree);\n            const pendingSegment = (0, _cache.upgradeToPendingSegment)(emptySegment, fetchStrategy);\n            upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n            return pendingSegment;\n        }\n        switch(nonEmptyRevalidatingSegment.status){\n            case _cache.EntryStatus.Pending:\n                // There's already an in-progress prefetch that includes this segment.\n                return null;\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                // A previous revalidation attempt finished, but we chose not to replace\n                // the existing entry in the cache. Don't try again until or unless the\n                // revalidation entry expires.\n                return null;\n            default:\n                nonEmptyRevalidatingSegment;\n                return null;\n        }\n    }\n}\nconst noop = ()=>{};\nfunction upsertSegmentOnCompletion(promise, varyPath) {\n    // Wait for a segment to finish loading, then upsert it into the cache\n    promise.then((fulfilled)=>{\n        if (fulfilled !== null) {\n            // Received new data. Attempt to replace the existing entry in the cache.\n            (0, _cache.upsertSegmentEntry)(Date.now(), varyPath, fulfilled);\n        }\n    }, noop);\n}\nfunction doesCurrentSegmentMatchCachedSegment(route, currentSegment, cachedSegment) {\n    if (cachedSegment === _segment.PAGE_SEGMENT_KEY) {\n        // In the FlightRouterState stored by the router, the page segment has the\n        // rendered search params appended to the name of the segment. In the\n        // prefetch cache, however, this is stored separately. So, when comparing\n        // the router's current FlightRouterState to the cached FlightRouterState,\n        // we need to make sure we compare both parts of the segment.\n        // TODO: This is not modeled clearly. We use the same type,\n        // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n        // _and_ the server response format, when conceptually those are three\n        // different things and treated in different ways. We should encode more of\n        // this information into the type design so mistakes are less likely.\n        return currentSegment === (0, _segment.addSearchParamsIfPageSegment)(_segment.PAGE_SEGMENT_KEY, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    }\n    // Non-page segments are compared using the same function as the server\n    return (0, _matchsegments.matchSegment)(cachedSegment, currentSegment);\n}\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\nfunction compareQueuePriority(a, b) {\n    // Since the queue is a MinHeap, this should return a positive number if b is\n    // higher priority than a, and a negative number if a is higher priority\n    // than b.\n    // `priority` is an integer, where higher numbers are higher priority.\n    const priorityDiff = b.priority - a.priority;\n    if (priorityDiff !== 0) {\n        return priorityDiff;\n    }\n    // If the priority is the same, check which phase the prefetch is in  is it\n    // prefetching the route tree, or the segments? Route trees are prioritized.\n    const phaseDiff = b.phase - a.phase;\n    if (phaseDiff !== 0) {\n        return phaseDiff;\n    }\n    // Finally, check the insertion order. `sortId` is an incrementing counter\n    // assigned to prefetches. We want to process the newest prefetches first.\n    return b.sortId - a.sortId;\n}\nfunction heapPush(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    node._heapIndex = index;\n    heapSiftUp(heap, node, index);\n}\nfunction heapPeek(heap) {\n    return heap.length === 0 ? null : heap[0];\n}\nfunction heapPop(heap) {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    first._heapIndex = -1;\n    const last = heap.pop();\n    if (last !== first) {\n        heap[0] = last;\n        last._heapIndex = 0;\n        heapSiftDown(heap, last, 0);\n    }\n    return first;\n}\nfunction heapDelete(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        node._heapIndex = -1;\n        if (heap.length !== 0) {\n            const last = heap.pop();\n            if (last !== node) {\n                heap[index] = last;\n                last._heapIndex = index;\n                heapSiftDown(heap, last, index);\n            }\n        }\n    }\n}\nfunction heapResift(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        if (index === 0) {\n            heapSiftDown(heap, node, 0);\n        } else {\n            const parentIndex = index - 1 >>> 1;\n            const parent = heap[parentIndex];\n            if (compareQueuePriority(parent, node) > 0) {\n                // The parent is larger. Sift up.\n                heapSiftUp(heap, node, index);\n            } else {\n                // The parent is smaller (or equal). Sift down.\n                heapSiftDown(heap, node, index);\n            }\n        }\n    }\n}\nfunction heapSiftUp(heap, node, i) {\n    let index = i;\n    while(index > 0){\n        const parentIndex = index - 1 >>> 1;\n        const parent = heap[parentIndex];\n        if (compareQueuePriority(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            node._heapIndex = parentIndex;\n            heap[index] = parent;\n            parent._heapIndex = index;\n            index = parentIndex;\n        } else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction heapSiftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while(index < halfLength){\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compareQueuePriority(left, node) < 0) {\n            if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n                heap[index] = right;\n                right._heapIndex = index;\n                heap[rightIndex] = node;\n                node._heapIndex = rightIndex;\n                index = rightIndex;\n            } else {\n                heap[index] = left;\n                left._heapIndex = index;\n                heap[leftIndex] = node;\n                node._heapIndex = leftIndex;\n                index = leftIndex;\n            }\n        } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n            heap[index] = right;\n            right._heapIndex = index;\n            heap[rightIndex] = node;\n            node._heapIndex = rightIndex;\n            index = rightIndex;\n        } else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=scheduler.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5559, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/normalize-trailing-slash.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"normalizePathTrailingSlash\", {\n    enumerable: true,\n    get: function() {\n        return normalizePathTrailingSlash;\n    }\n});\nconst _removetrailingslash = require(\"../shared/lib/router/utils/remove-trailing-slash\");\nconst _parsepath = require(\"../shared/lib/router/utils/parse-path\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    if (process.env.__NEXT_TRAILING_SLASH) {\n        if (/\\.[^/]+\\/?$/.test(pathname)) {\n            return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n        } else if (pathname.endsWith('/')) {\n            return `${pathname}${query}${hash}`;\n        } else {\n            return `${pathname}/${query}${hash}`;\n        }\n    }\n    return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=normalize-trailing-slash.js.map"],"names":[],"mappings":"AAaiC;AAbjC;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,8BAA8B;IACzD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,6BAA6B,CAAC;IAChC,IAAI,CAAC,KAAK,UAAU,CAAC,kDAAkD;QACnE,OAAO;IACX;IACA,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,GAAG,WAAW,SAAS,EAAE;IAC5D;;IASA,OAAO,GAAG,CAAC,GAAG,qBAAqB,mBAAmB,EAAE,YAAY,QAAQ,MAAM;AACtF;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 5592, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/add-base-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"addBasePath\", {\n    enumerable: true,\n    get: function() {\n        return addBasePath;\n    }\n});\nconst _addpathprefix = require(\"../shared/lib/router/utils/add-path-prefix\");\nconst _normalizetrailingslash = require(\"./normalize-trailing-slash\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction addBasePath(path, required) {\n    return (0, _normalizetrailingslash.normalizePathTrailingSlash)(process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required ? path : (0, _addpathprefix.addPathPrefix)(path, basePath));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=add-base-path.js.map"],"names":[],"mappings":"AAYiB;AAZjB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,eAAe;IAC1C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,WAAW,wCAAsC;AACvD,SAAS,YAAY,IAAI,EAAE,QAAQ;IAC/B,OAAO,CAAC,GAAG,wBAAwB,0BAA0B,EAAE,sCAA0D,0BAAO,CAAC,GAAG,eAAe,aAAa,EAAE,MAAM;AAC5K;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 5620, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/app-router-utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createPrefetchURL: null,\n    isExternalURL: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    isExternalURL: function() {\n        return isExternalURL;\n    }\n});\nconst _isbot = require(\"../../shared/lib/router/utils/is-bot\");\nconst _addbasepath = require(\"../add-base-path\");\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(`Cannot prefetch '${href}' because it cannot be converted to a URL.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (process.env.NODE_ENV === 'development') {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-router-utils.js.map"],"names":[],"mappings":"AA6CQ;AA7CR;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,mBAAmB;IACnB,eAAe;AACnB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,mBAAmB;QACf,OAAO;IACX;IACA,eAAe;QACX,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,cAAc,GAAG;IACtB,OAAO,IAAI,MAAM,KAAK,OAAO,QAAQ,CAAC,MAAM;AAChD;AACA,SAAS,kBAAkB,IAAI;IAC3B,kDAAkD;IAClD,IAAI,CAAC,GAAG,OAAO,KAAK,EAAE,OAAO,SAAS,CAAC,SAAS,GAAG;QAC/C,OAAO;IACX;IACA,IAAI;IACJ,IAAI;QACA,MAAM,IAAI,IAAI,CAAC,GAAG,aAAa,WAAW,EAAE,OAAO,OAAO,QAAQ,CAAC,IAAI;IAC3E,EAAE,OAAO,GAAG;QACR,2EAA2E;QAC3E,kDAAkD;QAClD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK,0CAA0C,CAAC,GAAG,qBAAqB;YAC9H,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,uEAAuE;IACvE,wCAA4C;QACxC,OAAO;IACX;;;AAMJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 5683, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/links.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    IDLE_LINK_STATUS: null,\n    PENDING_LINK_STATUS: null,\n    mountFormInstance: null,\n    mountLinkInstance: null,\n    onLinkVisibilityChanged: null,\n    onNavigationIntent: null,\n    pingVisibleLinks: null,\n    setLinkForCurrentNavigation: null,\n    unmountLinkForCurrentNavigation: null,\n    unmountPrefetchableInstance: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    IDLE_LINK_STATUS: function() {\n        return IDLE_LINK_STATUS;\n    },\n    PENDING_LINK_STATUS: function() {\n        return PENDING_LINK_STATUS;\n    },\n    mountFormInstance: function() {\n        return mountFormInstance;\n    },\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    setLinkForCurrentNavigation: function() {\n        return setLinkForCurrentNavigation;\n    },\n    unmountLinkForCurrentNavigation: function() {\n        return unmountLinkForCurrentNavigation;\n    },\n    unmountPrefetchableInstance: function() {\n        return unmountPrefetchableInstance;\n    }\n});\nconst _types = require(\"./segment-cache/types\");\nconst _cachekey = require(\"./segment-cache/cache-key\");\nconst _scheduler = require(\"./segment-cache/scheduler\");\nconst _react = require(\"react\");\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\nconst PENDING_LINK_STATUS = {\n    pending: true\n};\nconst IDLE_LINK_STATUS = {\n    pending: false\n};\nfunction setLinkForCurrentNavigation(link) {\n    (0, _react.startTransition)(()=>{\n        linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link?.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\nfunction unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    if (typeof window !== 'undefined') {\n        const { createPrefetchURL } = require('./app-router-utils');\n        try {\n            return createPrefetchURL(href);\n        } catch  {\n            // createPrefetchURL sometimes throws an error if an invalid URL is\n            // provided, though I'm not sure if it's actually necessary.\n            // TODO: Consider removing the throw from the inner function, or change it\n            // to reportError. Or maybe the error isn't even necessary for automatic\n            // prefetches, just navigations.\n            const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n            reportErrorFn(`Cannot prefetch '${href}' because it cannot be converted to a URL.`);\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nfunction mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nfunction mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nfunction unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _scheduler.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (process.env.NODE_ENV !== 'production') {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        prefetchableAndVisible.add(instance);\n    } else {\n        prefetchableAndVisible.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Default);\n}\nfunction onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (process.env.__NEXT_DYNAMIC_ON_HOVER && unstable_upgradeToDynamicPrefetch) {\n            // Switch to a full prefetch\n            instance.fetchStrategy = _types.FetchStrategy.Full;\n        }\n        rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    // Ensures that app-router-instance is not compiled in the server bundle\n    if (typeof window !== 'undefined') {\n        const existingPrefetchTask = instance.prefetchTask;\n        if (!instance.isVisible) {\n            // Cancel any in-progress prefetch task. (If it already finished then this\n            // is a no-op.)\n            if (existingPrefetchTask !== null) {\n                (0, _scheduler.cancelPrefetchTask)(existingPrefetchTask);\n            }\n            // We don't need to reset the prefetchTask to null upon cancellation; an\n            // old task object can be rescheduled with reschedulePrefetchTask. This is a\n            // micro-optimization but also makes the code simpler (don't need to\n            // worry about whether an old task object is stale).\n            return;\n        }\n        const { getCurrentAppRouterState } = require('./app-router-instance');\n        const appRouterState = getCurrentAppRouterState();\n        if (appRouterState !== null) {\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            if (existingPrefetchTask === null) {\n                // Initiate a prefetch task.\n                const nextUrl = appRouterState.nextUrl;\n                const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n                instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n            } else {\n                // We already have an old task object that we can reschedule. This is\n                // effectively the same as canceling the old task and creating a new one.\n                (0, _scheduler.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n            }\n        }\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !(0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _scheduler.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _types.PrefetchPriority.Default, null);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=links.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5969, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/cache.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    EntryStatus: null,\n    canNewFetchStrategyProvideMoreContent: null,\n    convertRouteTreeToFlightRouterState: null,\n    createDetachedSegmentCacheEntry: null,\n    fetchRouteOnCacheMiss: null,\n    fetchSegmentOnCacheMiss: null,\n    fetchSegmentPrefetchesUsingDynamicRequest: null,\n    getCurrentCacheVersion: null,\n    getStaleTimeMs: null,\n    overwriteRevalidatingSegmentCacheEntry: null,\n    pingInvalidationListeners: null,\n    readOrCreateRevalidatingSegmentEntry: null,\n    readOrCreateRouteCacheEntry: null,\n    readOrCreateSegmentCacheEntry: null,\n    readRouteCacheEntry: null,\n    readSegmentCacheEntry: null,\n    requestOptimisticRouteCacheEntry: null,\n    revalidateEntireCache: null,\n    upgradeToPendingSegment: null,\n    upsertSegmentEntry: null,\n    waitForSegmentCacheEntry: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    EntryStatus: function() {\n        return EntryStatus;\n    },\n    canNewFetchStrategyProvideMoreContent: function() {\n        return canNewFetchStrategyProvideMoreContent;\n    },\n    convertRouteTreeToFlightRouterState: function() {\n        return convertRouteTreeToFlightRouterState;\n    },\n    createDetachedSegmentCacheEntry: function() {\n        return createDetachedSegmentCacheEntry;\n    },\n    fetchRouteOnCacheMiss: function() {\n        return fetchRouteOnCacheMiss;\n    },\n    fetchSegmentOnCacheMiss: function() {\n        return fetchSegmentOnCacheMiss;\n    },\n    fetchSegmentPrefetchesUsingDynamicRequest: function() {\n        return fetchSegmentPrefetchesUsingDynamicRequest;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    getStaleTimeMs: function() {\n        return getStaleTimeMs;\n    },\n    overwriteRevalidatingSegmentCacheEntry: function() {\n        return overwriteRevalidatingSegmentCacheEntry;\n    },\n    pingInvalidationListeners: function() {\n        return pingInvalidationListeners;\n    },\n    readOrCreateRevalidatingSegmentEntry: function() {\n        return readOrCreateRevalidatingSegmentEntry;\n    },\n    readOrCreateRouteCacheEntry: function() {\n        return readOrCreateRouteCacheEntry;\n    },\n    readOrCreateSegmentCacheEntry: function() {\n        return readOrCreateSegmentCacheEntry;\n    },\n    readRouteCacheEntry: function() {\n        return readRouteCacheEntry;\n    },\n    readSegmentCacheEntry: function() {\n        return readSegmentCacheEntry;\n    },\n    requestOptimisticRouteCacheEntry: function() {\n        return requestOptimisticRouteCacheEntry;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    upgradeToPendingSegment: function() {\n        return upgradeToPendingSegment;\n    },\n    upsertSegmentEntry: function() {\n        return upsertSegmentEntry;\n    },\n    waitForSegmentCacheEntry: function() {\n        return waitForSegmentCacheEntry;\n    }\n});\nconst _approutertypes = require(\"../../../shared/lib/app-router-types\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst _fetchserverresponse = require(\"../router-reducer/fetch-server-response\");\nconst _scheduler = require(\"./scheduler\");\nconst _varypath = require(\"./vary-path\");\nconst _appbuildid = require(\"../../app-build-id\");\nconst _createhreffromurl = require(\"../router-reducer/create-href-from-url\");\nconst _cachekey = require(\"./cache-key\");\nconst _routeparams = require(\"../../route-params\");\nconst _cachemap = require(\"./cache-map\");\nconst _segmentvalueencoding = require(\"../../../shared/lib/segment-cache/segment-value-encoding\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nconst _navigatereducer = require(\"../router-reducer/reducers/navigate-reducer\");\nconst _links = require(\"../links\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _outputexportprefetchencoding = require(\"../../../shared/lib/segment-cache/output-export-prefetch-encoding\");\nconst _types = require(\"./types\");\nconst _promisewithresolvers = require(\"../../../shared/lib/promise-with-resolvers\");\nfunction getStaleTimeMs(staleTimeSeconds) {\n    return Math.max(staleTimeSeconds, 30) * 1000;\n}\nvar EntryStatus = /*#__PURE__*/ function(EntryStatus) {\n    EntryStatus[EntryStatus[\"Empty\"] = 0] = \"Empty\";\n    EntryStatus[EntryStatus[\"Pending\"] = 1] = \"Pending\";\n    EntryStatus[EntryStatus[\"Fulfilled\"] = 2] = \"Fulfilled\";\n    EntryStatus[EntryStatus[\"Rejected\"] = 3] = \"Rejected\";\n    return EntryStatus;\n}({});\nconst isOutputExportMode = process.env.NODE_ENV === 'production' && process.env.__NEXT_CONFIG_OUTPUT === 'export';\nconst MetadataOnlyRequestTree = [\n    '',\n    {},\n    null,\n    'metadata-only'\n];\nlet routeCacheMap = (0, _cachemap.createCacheMap)();\nlet segmentCacheMap = (0, _cachemap.createCacheMap)();\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners = null;\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0;\nfunction getCurrentCacheVersion() {\n    return currentCacheVersion;\n}\nfunction revalidateEntireCache(nextUrl, tree) {\n    // Increment the current cache version. This does not eagerly evict anything\n    // from the cache, but because all the entries are versioned, and we check\n    // the version when reading from the cache, this effectively causes all\n    // entries to be evicted lazily. We do it lazily because in the future,\n    // actions like revalidateTag or refresh will not evict the entire cache,\n    // but rather some subset of the entries.\n    currentCacheVersion++;\n    // Start a cooldown before re-prefetching to allow CDN cache propagation.\n    (0, _scheduler.startRevalidationCooldown)();\n    // Prefetch all the currently visible links again, to re-fill the cache.\n    (0, _links.pingVisibleLinks)(nextUrl, tree);\n    // Similarly, notify all invalidation listeners (i.e. those passed to\n    // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n    // if needed.\n    pingInvalidationListeners(nextUrl, tree);\n}\nfunction attachInvalidationListener(task) {\n    // This function is called whenever a prefetch task reads a cache entry. If\n    // the task has an onInvalidate function associated with it  i.e. the one\n    // optionally passed to router.prefetch(onInvalidate)  then we attach that\n    // listener to the every cache entry that the task reads. Then, if an entry\n    // is invalidated, we call the function.\n    if (task.onInvalidate !== null) {\n        if (invalidationListeners === null) {\n            invalidationListeners = new Set([\n                task\n            ]);\n        } else {\n            invalidationListeners.add(task);\n        }\n    }\n}\nfunction notifyInvalidationListener(task) {\n    const onInvalidate = task.onInvalidate;\n    if (onInvalidate !== null) {\n        // Clear the callback from the task object to guarantee it's not called more\n        // than once.\n        task.onInvalidate = null;\n        // This is a user-space function, so we must wrap in try/catch.\n        try {\n            onInvalidate();\n        } catch (error) {\n            if (typeof reportError === 'function') {\n                reportError(error);\n            } else {\n                console.error(error);\n            }\n        }\n    }\n}\nfunction pingInvalidationListeners(nextUrl, tree) {\n    // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    if (invalidationListeners !== null) {\n        const tasks = invalidationListeners;\n        invalidationListeners = null;\n        for (const task of tasks){\n            if ((0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n                notifyInvalidationListener(task);\n            }\n        }\n    }\n}\nfunction readRouteCacheEntry(now, key) {\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), routeCacheMap, varyPath, isRevalidation);\n}\nfunction readSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction readRevalidatingSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = true;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction waitForSegmentCacheEntry(pendingEntry) {\n    // Because the entry is pending, there's already a in-progress request.\n    // Attach a promise to the entry that will resolve when the server responds.\n    let promiseWithResolvers = pendingEntry.promise;\n    if (promiseWithResolvers === null) {\n        promiseWithResolvers = pendingEntry.promise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n    } else {\n    // There's already a promise we can use\n    }\n    return promiseWithResolvers.promise;\n}\nfunction readOrCreateRouteCacheEntry(now, task, key) {\n    attachInvalidationListener(task);\n    const existingEntry = readRouteCacheEntry(now, key);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const pendingEntry = {\n        canonicalUrl: null,\n        status: 0,\n        blockedTasks: null,\n        tree: null,\n        metadata: null,\n        // This is initialized to true because we don't know yet whether the route\n        // could be intercepted. It's only set to false once we receive a response\n        // from the server.\n        couldBeIntercepted: true,\n        // Similarly, we don't yet know if the route supports PPR.\n        isPPREnabled: false,\n        renderedSearch: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        // Since this is an empty entry, there's no reason to ever evict it. It will\n        // be updated when the data is populated.\n        staleAt: Infinity,\n        version: getCurrentCacheVersion()\n    };\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(routeCacheMap, varyPath, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction requestOptimisticRouteCacheEntry(now, requestedUrl, nextUrl) {\n    // This function is called during a navigation when there was no matching\n    // route tree in the prefetch cache. Before de-opting to a blocking,\n    // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n    // route tree by checking the cache for similar routes.\n    //\n    // Check if there's a route with the same pathname, but with different\n    // search params. We can then base our optimistic route tree on this entry.\n    //\n    // Conceptually, we are simulating what would happen if we did perform a\n    // prefetch the requested URL, under the assumption that the server will\n    // not redirect or rewrite the request in a different manner than the\n    // base route tree. This assumption might not hold, in which case we'll have\n    // to recover when we perform the dynamic navigation request. However, this\n    // is what would happen if a route were dynamically rewritten/redirected\n    // in between the prefetch and the navigation. So the logic needs to exist\n    // to handle this case regardless.\n    // Look for a route with the same pathname, but with an empty search string.\n    // TODO: There's nothing inherently special about the empty search string;\n    // it's chosen somewhat arbitrarily, with the rationale that it's the most\n    // likely one to exist. But we should update this to match _any_ search\n    // string. The plan is to generalize this logic alongside other improvements\n    // related to \"fallback\" cache entries.\n    const requestedSearch = requestedUrl.search;\n    if (requestedSearch === '') {\n        // The caller would have already checked if a route with an empty search\n        // string is in the cache. So we can bail out here.\n        return null;\n    }\n    const urlWithoutSearchParams = new URL(requestedUrl);\n    urlWithoutSearchParams.search = '';\n    const routeWithNoSearchParams = readRouteCacheEntry(now, (0, _cachekey.createCacheKey)(urlWithoutSearchParams.href, nextUrl));\n    if (routeWithNoSearchParams === null || routeWithNoSearchParams.status !== 2) {\n        // Bail out of constructing an optimistic route tree. This will result in\n        // a blocking, unprefetched navigation.\n        return null;\n    }\n    // Now we have a base route tree we can \"patch\" with our optimistic values.\n    // Optimistically assume that redirects for the requested pathname do\n    // not vary on the search string. Therefore, if the base route was\n    // redirected to a different search string, then the optimistic route\n    // should be redirected to the same search string. Otherwise, we use\n    // the requested search string.\n    const canonicalUrlForRouteWithNoSearchParams = new URL(routeWithNoSearchParams.canonicalUrl, requestedUrl.origin);\n    const optimisticCanonicalSearch = canonicalUrlForRouteWithNoSearchParams.search !== '' ? canonicalUrlForRouteWithNoSearchParams.search : requestedSearch;\n    // Similarly, optimistically assume that rewrites for the requested\n    // pathname do not vary on the search string. Therefore, if the base\n    // route was rewritten to a different search string, then the optimistic\n    // route should be rewritten to the same search string. Otherwise, we use\n    // the requested search string.\n    const optimisticRenderedSearch = routeWithNoSearchParams.renderedSearch !== '' ? routeWithNoSearchParams.renderedSearch : requestedSearch;\n    const optimisticUrl = new URL(routeWithNoSearchParams.canonicalUrl, location.origin);\n    optimisticUrl.search = optimisticCanonicalSearch;\n    const optimisticCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(optimisticUrl);\n    const optimisticRouteTree = createOptimisticRouteTree(routeWithNoSearchParams.tree, optimisticRenderedSearch);\n    const optimisticMetadataTree = createOptimisticRouteTree(routeWithNoSearchParams.metadata, optimisticRenderedSearch);\n    // Clone the base route tree, and override the relevant fields with our\n    // optimistic values.\n    const optimisticEntry = {\n        canonicalUrl: optimisticCanonicalUrl,\n        status: 2,\n        // This isn't cloned because it's instance-specific\n        blockedTasks: null,\n        tree: optimisticRouteTree,\n        metadata: optimisticMetadataTree,\n        couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n        isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n        // Override the rendered search with the optimistic value.\n        renderedSearch: optimisticRenderedSearch,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt: routeWithNoSearchParams.staleAt,\n        version: routeWithNoSearchParams.version\n    };\n    // Do not insert this entry into the cache. It only exists so we can\n    // perform the current navigation. Just return it to the caller.\n    return optimisticEntry;\n}\nfunction createOptimisticRouteTree(tree, newRenderedSearch) {\n    // Create a new route tree that identical to the original one except for\n    // the rendered search string, which is contained in the vary path.\n    let clonedSlots = null;\n    const originalSlots = tree.slots;\n    if (originalSlots !== null) {\n        clonedSlots = {};\n        for(const parallelRouteKey in originalSlots){\n            const childTree = originalSlots[parallelRouteKey];\n            clonedSlots[parallelRouteKey] = createOptimisticRouteTree(childTree, newRenderedSearch);\n        }\n    }\n    // We only need to clone the vary path if the route is a page.\n    if (tree.isPage) {\n        return {\n            requestKey: tree.requestKey,\n            segment: tree.segment,\n            varyPath: (0, _varypath.clonePageVaryPathWithNewSearchParams)(tree.varyPath, newRenderedSearch),\n            isPage: true,\n            slots: clonedSlots,\n            isRootLayout: tree.isRootLayout,\n            hasLoadingBoundary: tree.hasLoadingBoundary,\n            hasRuntimePrefetch: tree.hasRuntimePrefetch\n        };\n    }\n    return {\n        requestKey: tree.requestKey,\n        segment: tree.segment,\n        varyPath: tree.varyPath,\n        isPage: false,\n        slots: clonedSlots,\n        isRootLayout: tree.isRootLayout,\n        hasLoadingBoundary: tree.hasLoadingBoundary,\n        hasRuntimePrefetch: tree.hasRuntimePrefetch\n    };\n}\nfunction readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree) {\n    const existingEntry = readSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction readOrCreateRevalidatingSegmentEntry(now, fetchStrategy, route, tree) {\n    // This function is called when we've already confirmed that a particular\n    // segment is cached, but we want to perform another request anyway in case it\n    // returns more complete and/or fresher data than we already have. The logic\n    // for deciding whether to replace the existing entry is handled elsewhere;\n    // this function just handles retrieving a cache entry that we can use to\n    // track the revalidation.\n    //\n    // The reason revalidations are stored in the cache is because we need to be\n    // able to dedupe multiple revalidation requests. The reason they have to be\n    // handled specially is because we shouldn't overwrite a \"normal\" entry if\n    // one exists at the same keypath. So, for each internal cache location, there\n    // is a special \"revalidation\" slot that is used solely for this purpose.\n    //\n    // You can think of it as if all the revalidation entries were stored in a\n    // separate cache map from the canonical entries, and then transfered to the\n    // canonical cache map once the request is complete  this isn't how it's\n    // actually implemented, since it's more efficient to store them in the same\n    // data structure as the normal entries, but that's how it's modeled\n    // conceptually.\n    // TODO: Once we implement Fallback behavior for params, where an entry is\n    // re-keyed based on response information, we'll need to account for the\n    // possibility that the keypath of the previous entry is more generic than\n    // the keypath of the revalidating entry. In other words, the server could\n    // return a less generic entry upon revalidation. For now, though, this isn't\n    // a concern because the keypath is based solely on the prefetch strategy,\n    // not on data contained in the response.\n    const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction overwriteRevalidatingSegmentCacheEntry(fetchStrategy, route, tree) {\n    // This function is called when we've already decided to replace an existing\n    // revalidation entry. Create a new entry and write it into the cache,\n    // overwriting the previous value.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction upsertSegmentEntry(now, varyPath, candidateEntry) {\n    // We have a new entry that has not yet been inserted into the cache. Before\n    // we do so, we need to confirm whether it takes precedence over the existing\n    // entry (if one exists).\n    // TODO: We should not upsert an entry if its key was invalidated in the time\n    // since the request was made. We can do that by passing the \"owner\" entry to\n    // this function and confirming it's the same as `existingEntry`.\n    if ((0, _cachemap.isValueExpired)(now, getCurrentCacheVersion(), candidateEntry)) {\n        // The entry is expired. We cannot upsert it.\n        return null;\n    }\n    const existingEntry = readSegmentCacheEntry(now, varyPath);\n    if (existingEntry !== null) {\n        // Don't replace a more specific segment with a less-specific one. A case where this\n        // might happen is if the existing segment was fetched via\n        // `<Link prefetch={true}>`.\n        if (// We fetched the new segment using a different, less specific fetch strategy\n        // than the segment we already have in the cache, so it can't have more content.\n        candidateEntry.fetchStrategy !== existingEntry.fetchStrategy && !canNewFetchStrategyProvideMoreContent(existingEntry.fetchStrategy, candidateEntry.fetchStrategy) || // The existing entry isn't partial, but the new one is.\n        // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n        !existingEntry.isPartial && candidateEntry.isPartial) {\n            // We're going to leave revalidating entry in the cache so that it doesn't\n            // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n            // Rejected and null out the data so it can be garbage collected. We leave\n            // `staleAt` intact to prevent subsequent revalidation attempts only until\n            // the entry expires.\n            const rejectedEntry = candidateEntry;\n            rejectedEntry.status = 3;\n            rejectedEntry.loading = null;\n            rejectedEntry.rsc = null;\n            return null;\n        }\n        // Evict the existing entry from the cache.\n        (0, _cachemap.deleteFromCacheMap)(existingEntry);\n    }\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPath, candidateEntry, isRevalidation);\n    return candidateEntry;\n}\nfunction createDetachedSegmentCacheEntry(staleAt) {\n    const emptyEntry = {\n        status: 0,\n        // Default to assuming the fetch strategy will be PPR. This will be updated\n        // when a fetch is actually initiated.\n        fetchStrategy: _types.FetchStrategy.PPR,\n        rsc: null,\n        loading: null,\n        isPartial: true,\n        promise: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt,\n        version: 0\n    };\n    return emptyEntry;\n}\nfunction upgradeToPendingSegment(emptyEntry, fetchStrategy) {\n    const pendingEntry = emptyEntry;\n    pendingEntry.status = 1;\n    pendingEntry.fetchStrategy = fetchStrategy;\n    // Set the version here, since this is right before the request is initiated.\n    // The next time the global cache version is incremented, the entry will\n    // effectively be evicted. This happens before initiating the request, rather\n    // than when receiving the response, because it's guaranteed to happen\n    // before the data is read on the server.\n    pendingEntry.version = getCurrentCacheVersion();\n    return pendingEntry;\n}\nfunction pingBlockedTasks(entry) {\n    const blockedTasks = entry.blockedTasks;\n    if (blockedTasks !== null) {\n        for (const task of blockedTasks){\n            (0, _scheduler.pingPrefetchTask)(task);\n        }\n        entry.blockedTasks = null;\n    }\n}\nfunction fulfillRouteCacheEntry(entry, tree, metadataVaryPath, staleAt, couldBeIntercepted, canonicalUrl, renderedSearch, isPPREnabled) {\n    // The Head is not actually part of the route tree, but other than that, it's\n    // fetched and cached like a segment. Some functions expect a RouteTree\n    // object, so rather than fork the logic in all those places, we use this\n    // \"fake\" one.\n    const metadata = {\n        requestKey: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        segment: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        varyPath: metadataVaryPath,\n        // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n        // either) but for the purposes of how this field is used, it behaves like\n        // one. If this logic ever gets more complex we can change this to an enum.\n        isPage: true,\n        slots: null,\n        isRootLayout: false,\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        hasRuntimePrefetch: false\n    };\n    const fulfilledEntry = entry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.tree = tree;\n    fulfilledEntry.metadata = metadata;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.couldBeIntercepted = couldBeIntercepted;\n    fulfilledEntry.canonicalUrl = canonicalUrl;\n    fulfilledEntry.renderedSearch = renderedSearch;\n    fulfilledEntry.isPPREnabled = isPPREnabled;\n    pingBlockedTasks(entry);\n    return fulfilledEntry;\n}\nfunction fulfillSegmentCacheEntry(segmentCacheEntry, rsc, loading, staleAt, isPartial) {\n    const fulfilledEntry = segmentCacheEntry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.rsc = rsc;\n    fulfilledEntry.loading = loading;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.isPartial = isPartial;\n    // Resolve any listeners that were waiting for this data.\n    if (segmentCacheEntry.promise !== null) {\n        segmentCacheEntry.promise.resolve(fulfilledEntry);\n        // Free the promise for garbage collection.\n        fulfilledEntry.promise = null;\n    }\n    return fulfilledEntry;\n}\nfunction rejectRouteCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    pingBlockedTasks(entry);\n}\nfunction rejectSegmentCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    if (entry.promise !== null) {\n        // NOTE: We don't currently propagate the reason the prefetch was canceled\n        // but we could by accepting a `reason` argument.\n        entry.promise.resolve(null);\n        entry.promise = null;\n    }\n}\nfunction convertRootTreePrefetchToRouteTree(rootTree, renderedPathname, renderedSearch, acc) {\n    // Remove trailing and leading slashes\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    const rootSegment = _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY;\n    return convertTreePrefetchToRouteTree(rootTree.tree, rootSegment, null, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, pathnameParts, index, renderedSearch, acc);\n}\nfunction convertTreePrefetchToRouteTree(prefetch, segment, partialVaryPath, requestKey, pathnameParts, pathnamePartsIndex, renderedSearch, acc) {\n    // Converts the route tree sent by the server into the format used by the\n    // cache. The cached version of the tree includes additional fields, such as a\n    // cache key for each segment. Since this is frequently accessed, we compute\n    // it once instead of on every access. This same cache key is also used to\n    // request the segment from the server.\n    let slots = null;\n    let isPage;\n    let varyPath;\n    const prefetchSlots = prefetch.slots;\n    if (prefetchSlots !== null) {\n        isPage = false;\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        slots = {};\n        for(let parallelRouteKey in prefetchSlots){\n            const childPrefetch = prefetchSlots[parallelRouteKey];\n            const childParamName = childPrefetch.name;\n            const childParamType = childPrefetch.paramType;\n            const childServerSentParamKey = childPrefetch.paramKey;\n            let childDoesAppearInURL;\n            let childSegment;\n            let childPartialVaryPath;\n            if (childParamType !== null) {\n                // This segment is parameterized. Get the param from the pathname.\n                const childParamValue = (0, _routeparams.parseDynamicParamFromURLPart)(childParamType, pathnameParts, pathnamePartsIndex);\n                // Assign a cache key to the segment, based on the param value. In the\n                // pre-Segment Cache implementation, the server computes this and sends\n                // it in the body of the response. In the Segment Cache implementation,\n                // the server sends an empty string and we fill it in here.\n                // TODO: We're intentionally not adding the search param to page\n                // segments here; it's tracked separately and added back during a read.\n                // This would clearer if we waited to construct the segment until it's\n                // read from the cache, since that's effectively what we're\n                // doing anyway.\n                const childParamKey = // The server omits this field from the prefetch response when\n                // cacheComponents is enabled.\n                childServerSentParamKey !== null ? childServerSentParamKey : (0, _routeparams.getCacheKeyForDynamicParam)(childParamValue, '');\n                childPartialVaryPath = (0, _varypath.appendLayoutVaryPath)(partialVaryPath, childParamKey);\n                childSegment = [\n                    childParamName,\n                    childParamKey,\n                    childParamType\n                ];\n                childDoesAppearInURL = true;\n            } else {\n                // This segment does not have a param. Inherit the partial vary path of\n                // the parent.\n                childPartialVaryPath = partialVaryPath;\n                childSegment = childParamName;\n                childDoesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(childParamName);\n            }\n            // Only increment the index if the segment appears in the URL. If it's a\n            // \"virtual\" segment, like a route group, it remains the same.\n            const childPathnamePartsIndex = childDoesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n            const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n            const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n            slots[parallelRouteKey] = convertTreePrefetchToRouteTree(childPrefetch, childSegment, childPartialVaryPath, childRequestKey, pathnameParts, childPathnamePartsIndex, renderedSearch, acc);\n        }\n    } else {\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: prefetch.isRootLayout,\n        // This field is only relevant to dynamic routes. For a PPR/static route,\n        // there's always some partial loading state we can fetch.\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary,\n        hasRuntimePrefetch: prefetch.hasRuntimePrefetch\n    };\n}\nfunction convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc) {\n    return convertFlightRouterStateToRouteTree(flightRouterState, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, null, renderedSearch, acc);\n}\nfunction convertFlightRouterStateToRouteTree(flightRouterState, requestKey, parentPartialVaryPath, renderedSearch, acc) {\n    const originalSegment = flightRouterState[0];\n    let segment;\n    let partialVaryPath;\n    let isPage;\n    let varyPath;\n    if (Array.isArray(originalSegment)) {\n        isPage = false;\n        const paramCacheKey = originalSegment[1];\n        partialVaryPath = (0, _varypath.appendLayoutVaryPath)(parentPartialVaryPath, paramCacheKey);\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        segment = originalSegment;\n    } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        partialVaryPath = parentPartialVaryPath;\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            // The navigation implementation expects the search params to be included\n            // in the segment. However, in the case of a static response, the search\n            // params are omitted. So the client needs to add them back in when reading\n            // from the Segment Cache.\n            //\n            // For consistency, we'll do this for dynamic responses, too.\n            //\n            // TODO: We should move search params out of FlightRouterState and handle\n            // them entirely on the client, similar to our plan for dynamic params.\n            segment = _segment.PAGE_SEGMENT_KEY;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            segment = originalSegment;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    let slots = null;\n    const parallelRoutes = flightRouterState[1];\n    for(let parallelRouteKey in parallelRoutes){\n        const childRouterState = parallelRoutes[parallelRouteKey];\n        const childSegment = childRouterState[0];\n        // TODO: Eventually, the param values will not be included in the response\n        // from the server. We'll instead fill them in on the client by parsing\n        // the URL. This is where we'll do that.\n        const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n        const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n        const childTree = convertFlightRouterStateToRouteTree(childRouterState, childRequestKey, partialVaryPath, renderedSearch, acc);\n        if (slots === null) {\n            slots = {\n                [parallelRouteKey]: childTree\n            };\n        } else {\n            slots[parallelRouteKey] = childTree;\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: flightRouterState[4] === true,\n        hasLoadingBoundary: flightRouterState[5] !== undefined ? flightRouterState[5] : _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        // Non-static tree responses are only used by apps that haven't adopted\n        // Cache Components. So this is always false.\n        hasRuntimePrefetch: false\n    };\n}\nfunction convertRouteTreeToFlightRouterState(routeTree) {\n    const parallelRoutes = {};\n    if (routeTree.slots !== null) {\n        for(const parallelRouteKey in routeTree.slots){\n            parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(routeTree.slots[parallelRouteKey]);\n        }\n    }\n    const flightRouterState = [\n        routeTree.segment,\n        parallelRoutes,\n        null,\n        null,\n        routeTree.isRootLayout\n    ];\n    return flightRouterState;\n}\nasync function fetchRouteOnCacheMiss(entry, task, key) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    const pathname = key.pathname;\n    const search = key.search;\n    const nextUrl = key.nextUrl;\n    const segmentPath = '/_tree';\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        const url = new URL(pathname + search, location.origin);\n        let response;\n        let urlAfterRedirects;\n        if (isOutputExportMode) {\n            // In output: \"export\" mode, we can't use headers to request a particular\n            // segment. Instead, we encode the extra request information into the URL.\n            // This is not part of the \"public\" interface of the app; it's an internal\n            // Next.js implementation detail that the app developer should not need to\n            // concern themselves with.\n            //\n            // For example, to request a segment:\n            //\n            //   Path passed to <Link>:   /path/to/page\n            //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n            //\n            //   (This is not the exact protocol, just an illustration.)\n            //\n            // Before we do that, though, we need to account for redirects. Even in\n            // output: \"export\" mode, a proxy might redirect the page to a different\n            // location, but we shouldn't assume or expect that they also redirect all\n            // the segment files, too.\n            //\n            // To check whether the page is redirected, we perform a range request of\n            // the first N bytes of the HTML document. The canonical URL is determined\n            // from the response.\n            //\n            // Then we can use the canonical URL to request the route tree.\n            //\n            // NOTE: We could embed the route tree into the HTML document, to avoid\n            // a second request. We're not doing that currently because it would make\n            // the HTML document larger and affect normal page loads.\n            const htmlResponse = await fetch(url, {\n                headers: {\n                    Range: _outputexportprefetchencoding.DOC_PREFETCH_RANGE_HEADER_VALUE\n                }\n            });\n            const partialHtml = await htmlResponse.text();\n            if (!(0, _outputexportprefetchencoding.doesExportedHtmlMatchBuildId)(partialHtml, (0, _appbuildid.getAppBuildId)())) {\n                // The target page is not part of this app, or it belongs to a\n                // different build.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            urlAfterRedirects = htmlResponse.redirected ? new URL(htmlResponse.url) : url;\n            response = await fetchPrefetchResponse(addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath), headers);\n        } else {\n            // \"Server\" mode. We can use request headers instead of the pathname.\n            // TODO: The eventual plan is to get rid of our custom request headers and\n            // encode everything into the URL, using a similar strategy to the\n            // \"output: export\" block above.\n            response = await fetchPrefetchResponse(url, headers);\n            urlAfterRedirects = response !== null && response.redirected ? new URL(response.url) : url;\n        }\n        if (!response || !response.ok || // 204 is a Cache miss. Though theoretically this shouldn't happen when\n        // PPR is enabled, because we always respond to route tree requests, even\n        // if it needs to be blockingly generated on demand.\n        response.status === 204 || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // TODO: The canonical URL is the href without the origin. I think\n        // historically the reason for this is because the initial canonical URL\n        // gets passed as a prop to the top-level React component, which means it\n        // needs to be computed during SSR. If it were to include the origin, it\n        // would need to always be same as location.origin on the client, to prevent\n        // a hydration mismatch. To sidestep this complexity, we omit the origin.\n        //\n        // However, since this is neither a native URL object nor a fully qualified\n        // URL string, we need to be careful about how we use it. To prevent subtle\n        // mistakes, we should create a special type for it, instead of just string.\n        // Or, we should just use a (readonly) URL object instead. The type of the\n        // prop that we pass to seed the initial state does not need to be the same\n        // type as the state itself.\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(urlAfterRedirects);\n        // Check whether the response varies based on the Next-Url header.\n        const varyHeader = response.headers.get('vary');\n        const couldBeIntercepted = varyHeader !== null && varyHeader.includes(_approuterheaders.NEXT_URL);\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route.\n        const routeIsPPREnabled = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '2' || // In output: \"export\" mode, we can't rely on response headers. But if we\n        // receive a well-formed response, we can assume it's a static response,\n        // because all data is static in this mode.\n        isOutputExportMode;\n        if (routeIsPPREnabled) {\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            // Get the params that were used to render the target page. These may\n            // be different from the params in the request URL, if the page\n            // was rewritten.\n            const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n            const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n            // Convert the server-sent data into the RouteTree format used by the\n            // client cache.\n            //\n            // During this traversal, we accumulate additional data into this\n            // \"accumulator\" object.\n            const acc = {\n                metadataVaryPath: null\n            };\n            const routeTree = convertRootTreePrefetchToRouteTree(serverData, renderedPathname, renderedSearch, acc);\n            const metadataVaryPath = acc.metadataVaryPath;\n            if (metadataVaryPath === null) {\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            const staleTimeMs = getStaleTimeMs(serverData.staleTime);\n            fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, Date.now() + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n        } else {\n            // PPR is not enabled for this route. The server responds with a\n            // different format (FlightRouterState) that we need to convert.\n            // TODO: We will unify the responses eventually. I'm keeping the types\n            // separate for now because FlightRouterState has so many\n            // overloaded concerns.\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            writeDynamicTreeResponseIntoCache(Date.now(), task, // The non-PPR response format is what we'd get if we prefetched these segments\n            // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n            _types.FetchStrategy.LoadingBoundary, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled);\n        }\n        if (!couldBeIntercepted) {\n            // This route will never be intercepted. So we can use this entry for all\n            // requests to this route, regardless of the Next-Url header. This works\n            // because when reading the cache we always check for a valid\n            // non-intercepted entry first.\n            // Re-key the entry. The `set` implementation handles removing it from\n            // its previous position in the cache. We don't need to do anything to\n            // update the LRU, because the entry is already in it.\n            // TODO: Treat this as an upsert  should check if an entry already\n            // exists at the new keypath, and if so, whether we should keep that\n            // one instead.\n            const fulfilledVaryPath = (0, _varypath.getFulfilledRouteVaryPath)(pathname, search, nextUrl, couldBeIntercepted);\n            const isRevalidation = false;\n            (0, _cachemap.setInCacheMap)(routeCacheMap, fulfilledVaryPath, entry, isRevalidation);\n        }\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentOnCacheMiss(route, segmentCacheEntry, routeKey, tree) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    //\n    // Segment fetches are non-blocking so we don't need to ping the scheduler\n    // on completion.\n    // Use the canonical URL to request the segment, not the original URL. These\n    // are usually the same, but the canonical URL will be different if the route\n    // tree response was redirected. To avoid an extra waterfall on every segment\n    // request, we pass the redirected URL instead of the original one.\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = routeKey.nextUrl;\n    const requestKey = tree.requestKey;\n    const normalizedRequestKey = requestKey === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY ? // handling of these requests, we encode the root segment path as\n    // `_index` instead of as an empty string. This should be treated as\n    // an implementation detail and not as a stable part of the protocol.\n    // It just needs to match the equivalent logic that happens when\n    // prerendering the responses. It should not leak outside of Next.js.\n    '/_index' : requestKey;\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    const requestUrl = isOutputExportMode ? addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey) : url;\n    try {\n        const response = await fetchPrefetchResponse(requestUrl, headers);\n        if (!response || !response.ok || response.status === 204 || // Cache miss\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route. Theoretically this should never happen\n        // because we only issue requests for segments once we've verified that\n        // the route supports PPR.\n        response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) !== '2' && // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // Wrap the original stream in a new stream that never closes. That way the\n        // Flight client doesn't error if there's a hanging promise.\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n            (0, _cachemap.setSizeInCacheMap)(segmentCacheEntry, size);\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n            // The server build does not match the client. Treat as a 404. During\n            // an actual navigation, the router will trigger an MPA navigation.\n            // TODO: Consider moving the build ID to a response header so we can check\n            // it before decoding the response, and so there's one way of checking\n            // across all response types.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        return {\n            value: fulfillSegmentCacheEntry(segmentCacheEntry, serverData.rsc, serverData.loading, // TODO: The server does not currently provide per-segment stale time.\n            // So we use the stale time of the route.\n            route.staleAt, serverData.isPartial),\n            // Return a promise that resolves when the network connection closes, so\n            // the scheduler can track the number of concurrent network connections.\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentPrefetchesUsingDynamicRequest(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries) {\n    const key = task.key;\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = key.nextUrl;\n    if (spawnedEntries.size === 1 && spawnedEntries.has(route.metadata.requestKey)) {\n        // The only thing pending is the head. Instruct the server to\n        // skip over everything else.\n        dynamicRequestTree = MetadataOnlyRequestTree;\n    }\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(dynamicRequestTree)\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    switch(fetchStrategy){\n        case _types.FetchStrategy.Full:\n            {\n                break;\n            }\n        case _types.FetchStrategy.PPRRuntime:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '2';\n                break;\n            }\n        case _types.FetchStrategy.LoadingBoundary:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n                break;\n            }\n        default:\n            {\n                fetchStrategy;\n            }\n    }\n    try {\n        const response = await fetchPrefetchResponse(url, headers);\n        if (!response || !response.ok || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n        if (renderedSearch !== route.renderedSearch) {\n            // The search params that were used to render the target page are\n            // different from the search params in the request URL. This only happens\n            // when there's a dynamic rewrite in between the tree prefetch and the\n            // data prefetch.\n            // TODO: For now, since this is an edge case, we reject the prefetch, but\n            // the proper way to handle this is to evict the stale route tree entry\n            // then fill the cache with the new response.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        let fulfilledEntries = null;\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n            // When processing a dynamic response, we don't know how large each\n            // individual segment is, so approximate by assiging each segment\n            // the average of the total response size.\n            if (fulfilledEntries === null) {\n                // Haven't received enough data yet to know which segments\n                // were included.\n                return;\n            }\n            const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length;\n            for (const entry of fulfilledEntries){\n                (0, _cachemap.setSizeInCacheMap)(entry, averageSize);\n            }\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        const isResponsePartial = fetchStrategy === _types.FetchStrategy.PPRRuntime ? serverData.rp?.[0] === true : // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n        false;\n        // Aside from writing the data into the cache, this function also returns\n        // the entries that were fulfilled, so we can streamingly update their sizes\n        // in the LRU as more data comes in.\n        fulfilledEntries = writeDynamicRenderResponseIntoCache(Date.now(), task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries);\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nfunction writeDynamicTreeResponseIntoCache(now, task, fetchStrategy, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled) {\n    // Get the URL that was used to render the target page. This may be different\n    // from the URL in the request URL, if the page was rewritten.\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const normalizedFlightDataResult = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (// A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' || normalizedFlightDataResult.length !== 1) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightData = normalizedFlightDataResult[0];\n    if (!flightData.isRootRender) {\n        // Unexpected response format.\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightRouterState = flightData.tree;\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    // If the response contains dynamic holes, then we must conservatively assume\n    // that any individual segment might contain dynamic holes, and also the\n    // head. If it did not contain dynamic holes, then we can assume every segment\n    // and the head is completely static.\n    const isResponsePartial = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '1';\n    // Convert the server-sent data into the RouteTree format used by the\n    // client cache.\n    //\n    // During this traversal, we accumulate additional data into this\n    // \"accumulator\" object.\n    const acc = {\n        metadataVaryPath: null\n    };\n    const routeTree = convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc);\n    const metadataVaryPath = acc.metadataVaryPath;\n    if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const fulfilledEntry = fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, now + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n    // If the server sent segment data as part of the response, we should write\n    // it into the cache to prevent a second, redundant prefetch request.\n    //\n    // TODO: When `clientSegmentCache` is enabled, the server does not include\n    // segment data when responding to a route tree prefetch request. However,\n    // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n    // the page is fully static), the normal check is bypassed and the server\n    // responds with the full page. This is a temporary situation until we can\n    // remove the \"client-only\" option. Then, we can delete this function call.\n    writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, fulfilledEntry, null);\n}\nfunction rejectSegmentEntriesIfStillPending(entries, staleAt) {\n    const fulfilledEntries = [];\n    for (const entry of entries.values()){\n        if (entry.status === 1) {\n            rejectSegmentCacheEntry(entry, staleAt);\n        } else if (entry.status === 2) {\n            fulfilledEntries.push(entry);\n        }\n    }\n    return fulfilledEntries;\n}\nfunction writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries) {\n    if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        }\n        return null;\n    }\n    const flightDatas = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (typeof flightDatas === 'string') {\n        // This means navigating to this route will result in an MPA navigation.\n        // TODO: We should cache this, too, so that the MPA navigation is immediate.\n        return null;\n    }\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    const staleAt = now + staleTimeMs;\n    for (const flightData of flightDatas){\n        const seedData = flightData.seedData;\n        if (seedData !== null) {\n            // The data sent by the server represents only a subtree of the app. We\n            // need to find the part of the task tree that matches the response.\n            //\n            // segmentPath represents the parent path of subtree. It's a repeating\n            // pattern of parallel route key and segment:\n            //\n            //   [string, Segment, string, Segment, string, Segment, ...]\n            const segmentPath = flightData.segmentPath;\n            let tree = route.tree;\n            for(let i = 0; i < segmentPath.length; i += 2){\n                const parallelRouteKey = segmentPath[i];\n                if (tree?.slots?.[parallelRouteKey] !== undefined) {\n                    tree = tree.slots[parallelRouteKey];\n                } else {\n                    if (spawnedEntries !== null) {\n                        rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n                    }\n                    return null;\n                }\n            }\n            writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, spawnedEntries);\n        }\n        const head = flightData.head;\n        if (head !== null) {\n            fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, head, null, flightData.isHeadPartial, staleAt, route.metadata, spawnedEntries);\n        }\n    }\n    // Any entry that's still pending was intentionally not rendered by the\n    // server, because it was inside the loading boundary. Mark them as rejected\n    // so we know not to fetch them again.\n    // TODO: If PPR is enabled on some routes but not others, then it's possible\n    // that a different page is able to do a per-segment prefetch of one of the\n    // segments we're marking as rejected here. We should mark on the segment\n    // somehow that the reason for the rejection is because of a non-PPR prefetch.\n    // That way a per-segment prefetch knows to disregard the rejection.\n    if (spawnedEntries !== null) {\n        const fulfilledEntries = rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        return fulfilledEntries;\n    }\n    return null;\n}\nfunction writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, entriesOwnedByCurrentTask) {\n    // This function is used to write the result of a runtime server request\n    // (CacheNodeSeedData) into the prefetch cache.\n    const rsc = seedData[0];\n    const loading = seedData[2];\n    const isPartial = rsc === null || isResponsePartial;\n    fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask);\n    // Recursively write the child data into the cache.\n    const slots = tree.slots;\n    if (slots !== null) {\n        const seedDataChildren = seedData[1];\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childSeedData = seedDataChildren[parallelRouteKey];\n            if (childSeedData !== null && childSeedData !== undefined) {\n                writeSeedDataIntoCache(now, task, fetchStrategy, route, childTree, staleAt, childSeedData, isResponsePartial, entriesOwnedByCurrentTask);\n            }\n        }\n    }\n}\nfunction fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask) {\n    // We should only write into cache entries that are owned by us. Or create\n    // a new one and write into that. We must never write over an entry that was\n    // created by a different task, because that causes data races.\n    const ownedEntry = entriesOwnedByCurrentTask !== null ? entriesOwnedByCurrentTask.get(tree.requestKey) : undefined;\n    if (ownedEntry !== undefined) {\n        fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial);\n    } else {\n        // There's no matching entry. Attempt to create a new one.\n        const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree);\n        if (possiblyNewEntry.status === 0) {\n            // Confirmed this is a new entry. We can fulfill it.\n            const newEntry = possiblyNewEntry;\n            fulfillSegmentCacheEntry(upgradeToPendingSegment(newEntry, fetchStrategy), rsc, loading, staleAt, isPartial);\n        } else {\n            // There was already an entry in the cache. But we may be able to\n            // replace it with the new one from the server.\n            const newEntry = fulfillSegmentCacheEntry(upgradeToPendingSegment(createDetachedSegmentCacheEntry(staleAt), fetchStrategy), rsc, loading, staleAt, isPartial);\n            upsertSegmentEntry(now, (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree), newEntry);\n        }\n    }\n}\nasync function fetchPrefetchResponse(url, headers) {\n    const fetchPriority = 'low';\n    // When issuing a prefetch request, don't immediately decode the response; we\n    // use the lower level `createFromResponse` API instead because we need to do\n    // some extra processing of the response stream. See\n    // `createPrefetchResponseStream` for more details.\n    const shouldImmediatelyDecode = false;\n    const response = await (0, _fetchserverresponse.createFetch)(url, headers, fetchPriority, shouldImmediatelyDecode);\n    if (!response.ok) {\n        return null;\n    }\n    // Check the content type\n    if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n    } else {\n        const contentType = response.headers.get('content-type');\n        const isFlightResponse = contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (!isFlightResponse) {\n            return null;\n        }\n    }\n    return response;\n}\nfunction createPrefetchResponseStream(originalFlightStream, onStreamClose, onResponseSizeUpdate) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    //\n    // While processing the original stream, we also incrementally update the size\n    // of the cache entry in the LRU.\n    let totalByteLength = 0;\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    // Incrementally update the size of the cache entry in the LRU.\n                    // NOTE: Since prefetch responses are delivered in a single chunk,\n                    // it's not really necessary to do this streamingly, but I'm doing it\n                    // anyway in case this changes in the future.\n                    totalByteLength += value.byteLength;\n                    onResponseSizeUpdate(totalByteLength);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream. We do notify the caller, though.\n                onStreamClose();\n                return;\n            }\n        }\n    });\n}\nfunction addSegmentPathToUrlInOutputExportMode(url, segmentPath) {\n    if (isOutputExportMode) {\n        // In output: \"export\" mode, we cannot use a header to encode the segment\n        // path. Instead, we append it to the end of the pathname.\n        const staticUrl = new URL(url);\n        const routeDir = staticUrl.pathname.endsWith('/') ? staticUrl.pathname.slice(0, -1) : staticUrl.pathname;\n        const staticExportFilename = (0, _segmentvalueencoding.convertSegmentPathToStaticExportFilename)(segmentPath);\n        staticUrl.pathname = `${routeDir}/${staticExportFilename}`;\n        return staticUrl;\n    }\n    return url;\n}\nfunction canNewFetchStrategyProvideMoreContent(currentStrategy, newStrategy) {\n    return currentStrategy < newStrategy;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=cache.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7338, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/navigation.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"navigate\", {\n    enumerable: true,\n    get: function() {\n        return navigate;\n    }\n});\nconst _fetchserverresponse = require(\"../router-reducer/fetch-server-response\");\nconst _pprnavigations = require(\"../router-reducer/ppr-navigations\");\nconst _createhreffromurl = require(\"../router-reducer/create-href-from-url\");\nconst _cache = require(\"./cache\");\nconst _cachekey = require(\"./cache-key\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _types = require(\"./types\");\nfunction navigate(url, currentUrl, currentCacheNode, currentFlightRouterState, nextUrl, shouldScroll, accumulation) {\n    const now = Date.now();\n    const href = url.href;\n    // We special case navigations to the exact same URL as the current location.\n    // It's a common UI pattern for apps to refresh when you click a link to the\n    // current page. So when this happens, we refresh the dynamic data in the page\n    // segments.\n    //\n    // Note that this does not apply if the any part of the hash or search query\n    // has changed. This might feel a bit weird but it makes more sense when you\n    // consider that the way to trigger this behavior is to click the same link\n    // multiple times.\n    //\n    // TODO: We should probably refresh the *entire* route when this case occurs,\n    // not just the page segments. Essentially treating it the same as a refresh()\n    // triggered by an action, which is the more explicit way of modeling the UI\n    // pattern described above.\n    //\n    // Also note that this only refreshes the dynamic data, not static/ cached\n    // data. If the page segment is fully static and prefetched, the request is\n    // skipped. (This is also how refresh() works.)\n    const isSamePageNavigation = // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href;\n    const cacheKey = (0, _cachekey.createCacheKey)(href, nextUrl);\n    const route = (0, _cache.readRouteCacheEntry)(now, cacheKey);\n    if (route !== null && route.status === _cache.EntryStatus.Fulfilled) {\n        // We have a matching prefetch.\n        const snapshot = readRenderSnapshotFromCache(now, route, route.tree);\n        const prefetchFlightRouterState = snapshot.flightRouterState;\n        const prefetchSeedData = snapshot.seedData;\n        const headSnapshot = readHeadSnapshotFromCache(now, route);\n        const prefetchHead = headSnapshot.rsc;\n        const isPrefetchHeadPartial = headSnapshot.isPartial;\n        // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n        // because hash entries do not vary by hash fragment. However, the one\n        // we set in the router state *does* include the hash, and it's used to\n        // sync with the actual browser location. To make this less of a refactor\n        // hazard, we should always track the hash separately from the rest of\n        // the URL.\n        const newCanonicalUrl = route.canonicalUrl + url.hash;\n        const renderedSearch = route.renderedSearch;\n        return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, renderedSearch, shouldScroll, url.hash);\n    }\n    // There was no matching route tree in the cache. Let's see if we can\n    // construct an \"optimistic\" route tree.\n    //\n    // Do not construct an optimistic route tree if there was a cache hit, but\n    // the entry has a rejected status, since it may have been rejected due to a\n    // rewrite or redirect based on the search params.\n    //\n    // TODO: There are multiple reasons a prefetch might be rejected; we should\n    // track them explicitly and choose what to do here based on that.\n    if (route === null || route.status !== _cache.EntryStatus.Rejected) {\n        const optimisticRoute = (0, _cache.requestOptimisticRouteCacheEntry)(now, url, nextUrl);\n        if (optimisticRoute !== null) {\n            // We have an optimistic route tree. Proceed with the normal flow.\n            const snapshot = readRenderSnapshotFromCache(now, optimisticRoute, optimisticRoute.tree);\n            const prefetchFlightRouterState = snapshot.flightRouterState;\n            const prefetchSeedData = snapshot.seedData;\n            const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute);\n            const prefetchHead = headSnapshot.rsc;\n            const isPrefetchHeadPartial = headSnapshot.isPartial;\n            const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash;\n            const newRenderedSearch = optimisticRoute.renderedSearch;\n            return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, newRenderedSearch, shouldScroll, url.hash);\n        }\n    }\n    // There's no matching prefetch for this route in the cache.\n    let collectedDebugInfo = accumulation.collectedDebugInfo ?? [];\n    if (accumulation.collectedDebugInfo === undefined) {\n        collectedDebugInfo = accumulation.collectedDebugInfo = [];\n    }\n    return {\n        tag: _types.NavigationResultTag.Async,\n        data: navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, shouldScroll, url.hash, collectedDebugInfo)\n    };\n}\nfunction navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, canonicalUrl, renderedSearch, shouldScroll, hash) {\n    // Recursively construct a prefetch tree by reading from the Segment Cache. To\n    // maintain compatibility, we output the same data structures as the old\n    // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n    // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n    // read from the Segment Cache directly. It's only structured this way for now\n    // so we can share code with the old prefetching implementation.\n    const scrollableSegments = [];\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegments);\n    if (task !== null) {\n        const dynamicRequestTree = task.dynamicRequestTree;\n        if (dynamicRequestTree !== null) {\n            const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(new URL(canonicalUrl, url.origin), {\n                flightRouterState: dynamicRequestTree,\n                nextUrl\n            });\n            (0, _pprnavigations.listenForDynamicRequest)(task, promiseForDynamicServerResponse);\n        } else {\n        // The prefetched tree does not contain dynamic holes  it's\n        // fully static. We can skip the dynamic request.\n        }\n        return navigationTaskToResult(task, currentCacheNode, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash);\n    }\n    // The server sent back an empty tree patch. There's nothing to update, except\n    // possibly the URL.\n    return {\n        tag: _types.NavigationResultTag.NoOp,\n        data: {\n            canonicalUrl,\n            shouldScroll\n        }\n    };\n}\nfunction navigationTaskToResult(task, currentCacheNode, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash) {\n    const flightRouterState = task.route;\n    if (flightRouterState === null) {\n        // When no router state is provided, it signals that we should perform an\n        // MPA navigation.\n        return {\n            tag: _types.NavigationResultTag.MPA,\n            data: canonicalUrl\n        };\n    }\n    const newCacheNode = task.node;\n    return {\n        tag: _types.NavigationResultTag.Success,\n        data: {\n            flightRouterState,\n            cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n            canonicalUrl,\n            renderedSearch,\n            scrollableSegments,\n            shouldScroll,\n            hash\n        }\n    };\n}\nfunction readRenderSnapshotFromCache(now, route, tree) {\n    let childRouterStates = {};\n    let childSeedDatas = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childResult = readRenderSnapshotFromCache(now, route, childTree);\n            childRouterStates[parallelRouteKey] = childResult.flightRouterState;\n            childSeedDatas[parallelRouteKey] = childResult.seedData;\n        }\n    }\n    let rsc = null;\n    let loading = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, tree.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    // Happy path: a cache hit\n                    rsc = segmentEntry.rsc;\n                    loading = segmentEntry.loading;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    // We haven't received data for this segment yet, but there's already\n                    // an in-progress request. Since it's extremely likely to arrive\n                    // before the dynamic data response, we might as well use it.\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    loading = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.loading : null);\n                    // Since we don't know yet whether the segment is partial or fully\n                    // static, we must assume it's partial; we can't skip the\n                    // dynamic request.\n                    isPartial = true;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    // The navigation implementation expects the search params to be\n    // included in the segment. However, the Segment Cache tracks search\n    // params separately from the rest of the segment key. So we need to\n    // add them back here.\n    //\n    // See corresponding comment in convertFlightRouterStateToTree.\n    //\n    // TODO: What we should do instead is update the navigation diffing\n    // logic to compare search params explicitly. This is a temporary\n    // solution until more of the Segment Cache implementation has settled.\n    const segment = (0, _segment.addSearchParamsIfPageSegment)(tree.segment, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    // We don't need this information in a render snapshot, so this can just be a placeholder.\n    const hasRuntimePrefetch = false;\n    return {\n        flightRouterState: [\n            segment,\n            childRouterStates,\n            null,\n            null,\n            tree.isRootLayout\n        ],\n        seedData: [\n            rsc,\n            childSeedDatas,\n            loading,\n            isPartial,\n            hasRuntimePrefetch\n        ]\n    };\n}\nfunction readHeadSnapshotFromCache(now, route) {\n    // Same as readRenderSnapshotFromCache, but for the head\n    let rsc = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, route.metadata.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    rsc = segmentEntry.rsc;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    isPartial = true;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    return {\n        rsc,\n        isPartial\n    };\n}\nasync function navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, shouldScroll, hash, collectedDebugInfo) {\n    // Runs when a navigation happens but there's no cached prefetch we can use.\n    // Don't bother to wait for a prefetch response; go straight to a full\n    // navigation that contains both static and dynamic data in a single stream.\n    // (This is unlike the old navigation implementation, which instead blocks\n    // the dynamic request until a prefetch request is received.)\n    //\n    // To avoid duplication of logic, we're going to pretend that the tree\n    // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n    // use the same server response to write the actual data into the CacheNode\n    // tree. So it's the same flow as the \"happy path\" (prefetch, then\n    // navigation), except we use a single server response for both stages.\n    const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(url, {\n        flightRouterState: currentFlightRouterState,\n        nextUrl\n    });\n    const result = await promiseForDynamicServerResponse;\n    if (typeof result === 'string') {\n        // This is an MPA navigation.\n        const newUrl = result;\n        return {\n            tag: _types.NavigationResultTag.MPA,\n            data: newUrl\n        };\n    }\n    const { flightData, canonicalUrl, renderedSearch, debugInfo: debugInfoFromResponse } = result;\n    if (debugInfoFromResponse !== null) {\n        collectedDebugInfo.push(...debugInfoFromResponse);\n    }\n    // Since the response format of dynamic requests and prefetches is slightly\n    // different, we'll need to massage the data a bit. Create FlightRouterState\n    // tree that simulates what we'd receive as the result of a prefetch.\n    const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(currentFlightRouterState, flightData);\n    // In our simulated prefetch payload, we pretend that there's no seed data\n    // nor a prefetch head.\n    const prefetchSeedData = null;\n    const prefetchHead = null;\n    const isPrefetchHeadPartial = true;\n    // Now we proceed exactly as we would for normal navigation.\n    const scrollableSegments = [];\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegments);\n    if (task !== null) {\n        // In this case, we've already sent the dynamic request, so we don't\n        // actually use the request tree created by `startPPRNavigation`,\n        // except to check if it contains dynamic holes.\n        //\n        // This is almost always true, but it could be false if all the segment data\n        // was present in the cache, but the route tree was not. E.g. navigating\n        // to a URL that was not prefetched but rewrites to a different URL\n        // that was.\n        const hasDynamicHoles = task.dynamicRequestTree !== null;\n        if (hasDynamicHoles) {\n            (0, _pprnavigations.listenForDynamicRequest)(task, promiseForDynamicServerResponse);\n        } else {\n        // The prefetched tree does not contain dynamic holes  it's\n        // fully static. We don't need to process the server response further.\n        }\n        return navigationTaskToResult(task, currentCacheNode, (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl), renderedSearch, scrollableSegments, shouldScroll, hash);\n    }\n    // The server sent back an empty tree patch. There's nothing to update, except\n    // possibly the URL.\n    return {\n        tag: _types.NavigationResultTag.NoOp,\n        data: {\n            canonicalUrl: (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl),\n            shouldScroll\n        }\n    };\n}\nfunction simulatePrefetchTreeUsingDynamicTreePatch(currentTree, flightData) {\n    // Takes the current FlightRouterState and applies the router state patch\n    // received from the server, to create a full FlightRouterState tree that we\n    // can pretend was returned by a prefetch.\n    //\n    // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n    // to handle stuff like interception routes or diffing since that will be\n    // handled later.)\n    let baseTree = currentTree;\n    for (const { segmentPath, tree: treePatch } of flightData){\n        // If the server sends us multiple tree patches, we only need to clone the\n        // base tree when applying the first patch. After the first patch, we can\n        // apply the remaining patches in place without copying.\n        const canMutateInPlace = baseTree !== currentTree;\n        baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(baseTree, treePatch, segmentPath, canMutateInPlace, 0);\n    }\n    return baseTree;\n}\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(baseRouterState, patch, segmentPath, canMutateInPlace, index) {\n    if (index === segmentPath.length) {\n        // We reached the part of the tree that we need to patch.\n        return patch;\n    }\n    // segmentPath represents the parent path of subtree. It's a repeating\n    // pattern of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // This path tells us which part of the base tree to apply the tree patch.\n    //\n    // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n    // the FlightRouterState patch in the same request as the dynamic data.\n    // Therefore we don't need to worry about diffing the segment values; we can\n    // assume the server sent us a correct result.\n    const updatedParallelRouteKey = segmentPath[index];\n    // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n    const baseChildren = baseRouterState[1];\n    const newChildren = {};\n    for(const parallelRouteKey in baseChildren){\n        if (parallelRouteKey === updatedParallelRouteKey) {\n            const childBaseRouterState = baseChildren[parallelRouteKey];\n            newChildren[parallelRouteKey] = simulatePrefetchTreeUsingDynamicTreePatchImpl(childBaseRouterState, patch, segmentPath, canMutateInPlace, // Advance the index by two and keep cloning until we reach\n            // the end of the segment path.\n            index + 2);\n        } else {\n            // This child is not being patched. Copy it over as-is.\n            newChildren[parallelRouteKey] = baseChildren[parallelRouteKey];\n        }\n    }\n    if (canMutateInPlace) {\n        // We can mutate the base tree in place, because the base tree is already\n        // a clone.\n        baseRouterState[1] = newChildren;\n        return baseRouterState;\n    }\n    // Clone all the fields except the children.\n    //\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7754, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DYNAMIC_STALETIME_MS: null,\n    STATIC_STALETIME_MS: null,\n    generateSegmentsFromPatch: null,\n    handleExternalUrl: null,\n    navigateReducer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    generateSegmentsFromPatch: function() {\n        return generateSegmentsFromPatch;\n    },\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _navigation = require(\"../../segment-cache/navigation\");\nconst _types = require(\"../../segment-cache/types\");\nconst _cache = require(\"../../segment-cache/cache\");\nconst DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000;\nconst STATIC_STALETIME_MS = (0, _cache.getStaleTimeMs)(Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME));\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _types.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _types.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // We don't need to compare the origins, because client-driven\n                // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _types.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.renderedSearch = result.data.renderedSearch;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _types.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // If the navigation failed, return the current state.\n                // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    const result = (0, _navigation.navigate)(url, currentUrl, state.cache, state.tree, state.nextUrl, shouldScroll, mutable);\n    return handleNavigationResult(url, state, mutable, pendingPush, result);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigate-reducer.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7921, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"fillLazyItemsTillLeafWithHead\", {\n    enumerable: true,\n    get: function() {\n        return fillLazyItemsTillLeafWithHead;\n    }\n});\nconst _createroutercachekey = require(\"./create-router-cache-key\");\nfunction fillLazyItemsTillLeafWithHead(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData, head) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n        // state tree. Ideally, they would always be the same shape, but because of\n        // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n        // partial tree. That's why this node is sometimes null. Once PPR lands,\n        // loading.js will no longer have special behavior and we can traverse the\n        // data tree instead.\n        //\n        // We should also consider merging the router state tree and the data tree\n        // in the response format, so that we don't have to send the keys twice.\n        // Then the client can convert them into separate representations.\n        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined ? cacheNodeSeedData[1][key] : null;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                let newCacheNode;\n                if (parallelSeedData !== null) {\n                    // New data was sent from the server.\n                    const seedNode = parallelSeedData[0];\n                    const loading = parallelSeedData[2];\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: seedNode,\n                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n                        // this path during a navigation, but until PPR is fully implemented\n                        // yet it's possible the existing node does have a non-null\n                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n                        // old behavior  no PPR value.\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        loading,\n                        parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n                        navigatedAt\n                    };\n                } else {\n                    // No data available for this node. This will trigger a lazy fetch\n                    // during render.\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: null,\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n                        loading: null,\n                        navigatedAt\n                    };\n                }\n                // Overrides the cache key with the new cache node.\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                // Traverse deeper to apply the head / fill lazy items till the head.\n                fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        let newCacheNode;\n        if (parallelSeedData !== null) {\n            // New data was sent from the server.\n            const seedNode = parallelSeedData[0];\n            const loading = parallelSeedData[2];\n            newCacheNode = {\n                lazyData: null,\n                rsc: seedNode,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading,\n                navigatedAt\n            };\n        } else {\n            // No data available for this node. This will trigger a lazy fetch\n            // during render.\n            newCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt\n            };\n        }\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, undefined, parallelRouteState, parallelSeedData, head);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8054, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"invalidateCacheByRouterState\", {\n    enumerable: true,\n    get: function() {\n        return invalidateCacheByRouterState;\n    }\n});\nconst _createroutercachekey = require(\"./create-router-cache-key\");\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=invalidate-cache-by-router-state.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,gCAAgC;IAC3D,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,6BAA6B,QAAQ,EAAE,aAAa,EAAE,WAAW;IACtE,uFAAuF;IACvF,IAAI,MAAM,OAAO,WAAW,CAAC,EAAE,CAAC;QAC5B,MAAM,0BAA0B,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;QACtD,MAAM,WAAW,CAAC,GAAG,sBAAsB,oBAAoB,EAAE;QACjE,MAAM,kCAAkC,cAAc,cAAc,CAAC,GAAG,CAAC;QACzE,IAAI,iCAAiC;YACjC,IAAI,yBAAyB,IAAI,IAAI;YACrC,uBAAuB,MAAM,CAAC;YAC9B,SAAS,cAAc,CAAC,GAAG,CAAC,KAAK;QACrC;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4DAA4D","ignoreList":[0]}},
    {"offset": {"line": 8088, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    fillCacheWithNewSubTreeData: null,\n    fillCacheWithNewSubTreeDataButOnlyLoading: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    fillCacheWithNewSubTreeData: function() {\n        return fillCacheWithNewSubTreeData;\n    },\n    fillCacheWithNewSubTreeDataButOnlyLoading: function() {\n        return fillCacheWithNewSubTreeDataButOnlyLoading;\n    }\n});\nconst _invalidatecachebyrouterstate = require(\"./invalidate-cache-by-router-state\");\nconst _filllazyitemstillleafwithhead = require(\"./fill-lazy-items-till-leaf-with-head\");\nconst _createroutercachekey = require(\"./create-router-cache-key\");\nconst _segment = require(\"../../../shared/lib/segment\");\n/**\n * Common logic for filling cache with new sub tree data.\n */ function fillCacheHelper(navigatedAt, newCache, existingCache, flightData, fillLazyItems) {\n    const { segmentPath, seedData: cacheNodeSeedData, tree: treePatch, head } = flightData;\n    let newCacheNode = newCache;\n    let existingCacheNode = existingCache;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        // segmentPath is a repeating tuple of parallelRouteKey and segment\n        // we know we've hit the last entry we've reached our final pair\n        const isLastEntry = i === segmentPath.length - 2;\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const existingChildSegmentMap = existingCacheNode.parallelRoutes.get(parallelRouteKey);\n        if (!existingChildSegmentMap) {\n            continue;\n        }\n        let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey);\n        if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n            childSegmentMap = new Map(existingChildSegmentMap);\n            newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n        }\n        const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n        let childCacheNode = childSegmentMap.get(cacheKey);\n        if (isLastEntry) {\n            if (cacheNodeSeedData && (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode)) {\n                const rsc = cacheNodeSeedData[0];\n                const loading = cacheNodeSeedData[2];\n                childCacheNode = {\n                    lazyData: null,\n                    // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n                    // not the page segment.\n                    rsc: fillLazyItems || segment !== _segment.PAGE_SEGMENT_KEY ? rsc : null,\n                    prefetchRsc: null,\n                    head: null,\n                    prefetchHead: null,\n                    loading,\n                    parallelRoutes: fillLazyItems && existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),\n                    navigatedAt\n                };\n                if (existingChildCacheNode && fillLazyItems) {\n                    (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, treePatch);\n                }\n                if (fillLazyItems) {\n                    (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, childCacheNode, existingChildCacheNode, treePatch, cacheNodeSeedData, head);\n                }\n                childSegmentMap.set(cacheKey, childCacheNode);\n            }\n            continue;\n        }\n        if (!childCacheNode || !existingChildCacheNode) {\n            continue;\n        }\n        if (childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                lazyData: childCacheNode.lazyData,\n                rsc: childCacheNode.rsc,\n                prefetchRsc: childCacheNode.prefetchRsc,\n                head: childCacheNode.head,\n                prefetchHead: childCacheNode.prefetchHead,\n                parallelRoutes: new Map(childCacheNode.parallelRoutes),\n                loading: childCacheNode.loading\n            };\n            childSegmentMap.set(cacheKey, childCacheNode);\n        }\n        // Move deeper into the cache nodes\n        newCacheNode = childCacheNode;\n        existingCacheNode = existingChildCacheNode;\n    }\n}\nfunction fillCacheWithNewSubTreeData(navigatedAt, newCache, existingCache, flightData) {\n    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, true);\n}\nfunction fillCacheWithNewSubTreeDataButOnlyLoading(navigatedAt, newCache, existingCache, flightData) {\n    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, false);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=fill-cache-with-new-subtree-data.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,6BAA6B;IAC7B,2CAA2C;AAC/C,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,6BAA6B;QACzB,OAAO;IACX;IACA,2CAA2C;QACvC,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN;;CAEC,GAAG,SAAS,gBAAgB,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAE,UAAU,EAAE,aAAa;IACxF,MAAM,EAAE,WAAW,EAAE,UAAU,iBAAiB,EAAE,MAAM,SAAS,EAAE,IAAI,EAAE,GAAG;IAC5E,IAAI,eAAe;IACnB,IAAI,oBAAoB;IACxB,IAAI,IAAI,IAAI,GAAG,IAAI,YAAY,MAAM,EAAE,KAAK,EAAE;QAC1C,MAAM,mBAAmB,WAAW,CAAC,EAAE;QACvC,MAAM,UAAU,WAAW,CAAC,IAAI,EAAE;QAClC,mEAAmE;QACnE,gEAAgE;QAChE,MAAM,cAAc,MAAM,YAAY,MAAM,GAAG;QAC/C,MAAM,WAAW,CAAC,GAAG,sBAAsB,oBAAoB,EAAE;QACjE,MAAM,0BAA0B,kBAAkB,cAAc,CAAC,GAAG,CAAC;QACrE,IAAI,CAAC,yBAAyB;YAC1B;QACJ;QACA,IAAI,kBAAkB,aAAa,cAAc,CAAC,GAAG,CAAC;QACtD,IAAI,CAAC,mBAAmB,oBAAoB,yBAAyB;YACjE,kBAAkB,IAAI,IAAI;YAC1B,aAAa,cAAc,CAAC,GAAG,CAAC,kBAAkB;QACtD;QACA,MAAM,yBAAyB,wBAAwB,GAAG,CAAC;QAC3D,IAAI,iBAAiB,gBAAgB,GAAG,CAAC;QACzC,IAAI,aAAa;YACb,IAAI,qBAAqB,CAAC,CAAC,kBAAkB,CAAC,eAAe,QAAQ,IAAI,mBAAmB,sBAAsB,GAAG;gBACjH,MAAM,MAAM,iBAAiB,CAAC,EAAE;gBAChC,MAAM,UAAU,iBAAiB,CAAC,EAAE;gBACpC,iBAAiB;oBACb,UAAU;oBACV,mFAAmF;oBACnF,wBAAwB;oBACxB,KAAK,iBAAiB,YAAY,SAAS,gBAAgB,GAAG,MAAM;oBACpE,aAAa;oBACb,MAAM;oBACN,cAAc;oBACd;oBACA,gBAAgB,iBAAiB,yBAAyB,IAAI,IAAI,uBAAuB,cAAc,IAAI,IAAI;oBAC/G;gBACJ;gBACA,IAAI,0BAA0B,eAAe;oBACzC,CAAC,GAAG,8BAA8B,4BAA4B,EAAE,gBAAgB,wBAAwB;gBAC5G;gBACA,IAAI,eAAe;oBACf,CAAC,GAAG,+BAA+B,6BAA6B,EAAE,aAAa,gBAAgB,wBAAwB,WAAW,mBAAmB;gBACzJ;gBACA,gBAAgB,GAAG,CAAC,UAAU;YAClC;YACA;QACJ;QACA,IAAI,CAAC,kBAAkB,CAAC,wBAAwB;YAC5C;QACJ;QACA,IAAI,mBAAmB,wBAAwB;YAC3C,iBAAiB;gBACb,UAAU,eAAe,QAAQ;gBACjC,KAAK,eAAe,GAAG;gBACvB,aAAa,eAAe,WAAW;gBACvC,MAAM,eAAe,IAAI;gBACzB,cAAc,eAAe,YAAY;gBACzC,gBAAgB,IAAI,IAAI,eAAe,cAAc;gBACrD,SAAS,eAAe,OAAO;YACnC;YACA,gBAAgB,GAAG,CAAC,UAAU;QAClC;QACA,mCAAmC;QACnC,eAAe;QACf,oBAAoB;IACxB;AACJ;AACA,SAAS,4BAA4B,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAE,UAAU;IACjF,gBAAgB,aAAa,UAAU,eAAe,YAAY;AACtE;AACA,SAAS,0CAA0C,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAE,UAAU;IAC/F,gBAAgB,aAAa,UAAU,eAAe,YAAY;AACtE;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4DAA4D","ignoreList":[0]}},
    {"offset": {"line": 8200, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"applyFlightData\", {\n    enumerable: true,\n    get: function() {\n        return applyFlightData;\n    }\n});\nconst _filllazyitemstillleafwithhead = require(\"./fill-lazy-items-till-leaf-with-head\");\nconst _fillcachewithnewsubtreedata = require(\"./fill-cache-with-new-subtree-data\");\nfunction applyFlightData(navigatedAt, existingCache, cache, flightData) {\n    // The one before last item is the router state tree patch\n    const { tree: treePatch, seedData, head, isRootRender } = flightData;\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (seedData === null) {\n        return false;\n    }\n    if (isRootRender) {\n        const rsc = seedData[0];\n        const loading = seedData[2];\n        cache.loading = loading;\n        cache.rsc = rsc;\n        // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n        // this path during a navigation, but until PPR is fully implemented\n        // yet it's possible the existing node does have a non-null\n        // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n        // old behavior  no PPR value.\n        cache.prefetchRsc = null;\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, existingCache, treePatch, seedData, head);\n    } else {\n        // Copy rsc for the root node of the cache.\n        cache.rsc = existingCache.rsc;\n        // This is a PPR-only field. Unlike the previous branch, since we're\n        // just cloning the existing cache node, we might as well keep the\n        // PPR value, if it exists.\n        cache.prefetchRsc = existingCache.prefetchRsc;\n        cache.parallelRoutes = new Map(existingCache.parallelRoutes);\n        cache.loading = existingCache.loading;\n        // Create a copy of the existing cache with the rsc applied.\n        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(navigatedAt, cache, existingCache, flightData);\n    }\n    return true;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=apply-flight-data.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,mBAAmB;IAC9C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,gBAAgB,WAAW,EAAE,aAAa,EAAE,KAAK,EAAE,UAAU;IAClE,0DAA0D;IAC1D,MAAM,EAAE,MAAM,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAE,YAAY,EAAE,GAAG;IAC1D,8FAA8F;IAC9F,IAAI,aAAa,MAAM;QACnB,OAAO;IACX;IACA,IAAI,cAAc;QACd,MAAM,MAAM,QAAQ,CAAC,EAAE;QACvB,MAAM,UAAU,QAAQ,CAAC,EAAE;QAC3B,MAAM,OAAO,GAAG;QAChB,MAAM,GAAG,GAAG;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/B,MAAM,WAAW,GAAG;QACpB,CAAC,GAAG,+BAA+B,6BAA6B,EAAE,aAAa,OAAO,eAAe,WAAW,UAAU;IAC9H,OAAO;QACH,2CAA2C;QAC3C,MAAM,GAAG,GAAG,cAAc,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3B,MAAM,WAAW,GAAG,cAAc,WAAW;QAC7C,MAAM,cAAc,GAAG,IAAI,IAAI,cAAc,cAAc;QAC3D,MAAM,OAAO,GAAG,cAAc,OAAO;QACrC,4DAA4D;QAC5D,CAAC,GAAG,6BAA6B,2BAA2B,EAAE,aAAa,OAAO,eAAe;IACrG;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 8255, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    addRefreshMarkerToActiveParallelSegments: null,\n    refreshInactiveParallelSegments: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = require(\"./apply-flight-data\");\nconst _fetchserverresponse = require(\"./fetch-server-response\");\nconst _segment = require(\"../../../shared/lib/segment\");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl({ navigatedAt, state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl }) {\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {\n            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n            flightRouterState: [\n                rootTree[0],\n                rootTree[1],\n                rootTree[2],\n                'refetch'\n            ],\n            nextUrl: includeNextUrl ? state.nextUrl : null\n        }).then((result)=>{\n            if (typeof result !== 'string') {\n                const { flightData } = result;\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(navigatedAt, updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When result is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            navigatedAt,\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n        tree[2] = path;\n        tree[3] = 'refresh';\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=refetch-inactive-parallel-segments.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8361, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"applyRouterStatePatchToTree\", {\n    enumerable: true,\n    get: function() {\n        return applyRouterStatePatchToTree;\n    }\n});\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nconst _matchsegments = require(\"../match-segments\");\nconst _refetchinactiveparallelsegments = require(\"./refetch-inactive-parallel-segments\");\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */ function applyPatch(initialTree, patchTree) {\n    const [initialSegment, initialParallelRoutes] = initialTree;\n    const [patchSegment, patchParallelRoutes] = patchTree;\n    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n    // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n    if (patchSegment === _segment.DEFAULT_SEGMENT_KEY && initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {\n        return initialTree;\n    }\n    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {\n        const newParallelRoutes = {};\n        for(const key in initialParallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== 'undefined';\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);\n            } else {\n                newParallelRoutes[key] = initialParallelRoutes[key];\n            }\n        }\n        for(const key in patchParallelRoutes){\n            if (newParallelRoutes[key]) {\n                continue;\n            }\n            newParallelRoutes[key] = patchParallelRoutes[key];\n        }\n        const tree = [\n            initialSegment,\n            newParallelRoutes\n        ];\n        // Copy over the existing tree\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {\n    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch);\n        (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey], treePatch, path);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        {\n            ...parallelRoutes,\n            [parallelRouteKey]: parallelRoutePatch\n        },\n        url,\n        refetch\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n    return tree;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=apply-router-state-patch-to-tree.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8468, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/app-router-announcer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"AppRouterAnnouncer\", {\n    enumerable: true,\n    get: function() {\n        return AppRouterAnnouncer;\n    }\n});\nconst _react = require(\"react\");\nconst _reactdom = require(\"react-dom\");\nconst ANNOUNCER_TYPE = 'next-route-announcer';\nconst ANNOUNCER_ID = '__next-route-announcer__';\nfunction getAnnouncerNode() {\n    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];\n    if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n        return existingAnnouncer.shadowRoot.childNodes[0];\n    } else {\n        const container = document.createElement(ANNOUNCER_TYPE);\n        container.style.cssText = 'position:absolute';\n        const announcer = document.createElement('div');\n        announcer.ariaLive = 'assertive';\n        announcer.id = ANNOUNCER_ID;\n        announcer.role = 'alert';\n        announcer.style.cssText = 'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal';\n        // Use shadow DOM here to avoid any potential CSS bleed\n        const shadow = container.attachShadow({\n            mode: 'open'\n        });\n        shadow.appendChild(announcer);\n        document.body.appendChild(container);\n        return announcer;\n    }\n}\nfunction AppRouterAnnouncer({ tree }) {\n    const [portalNode, setPortalNode] = (0, _react.useState)(null);\n    (0, _react.useEffect)(()=>{\n        const announcer = getAnnouncerNode();\n        setPortalNode(announcer);\n        return ()=>{\n            const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0];\n            if (container?.isConnected) {\n                document.body.removeChild(container);\n            }\n        };\n    }, []);\n    const [routeAnnouncement, setRouteAnnouncement] = (0, _react.useState)('');\n    const previousTitle = (0, _react.useRef)(undefined);\n    (0, _react.useEffect)(()=>{\n        let currentTitle = '';\n        if (document.title) {\n            currentTitle = document.title;\n        } else {\n            const pageHeader = document.querySelector('h1');\n            if (pageHeader) {\n                currentTitle = pageHeader.innerText || pageHeader.textContent || '';\n            }\n        }\n        // Only announce the title change, but not for the first load because screen\n        // readers do that automatically.\n        if (previousTitle.current !== undefined && previousTitle.current !== currentTitle) {\n            setRouteAnnouncement(currentTitle);\n        }\n        previousTitle.current = currentTitle;\n    }, [\n        tree\n    ]);\n    return portalNode ? /*#__PURE__*/ (0, _reactdom.createPortal)(routeAnnouncement, portalNode) : null;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-router-announcer.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,iBAAiB;AACvB,MAAM,eAAe;AACrB,SAAS;IACL,MAAM,oBAAoB,SAAS,iBAAiB,CAAC,eAAe,CAAC,EAAE;IACvE,IAAI,mBAAmB,YAAY,UAAU,CAAC,EAAE,EAAE;QAC9C,OAAO,kBAAkB,UAAU,CAAC,UAAU,CAAC,EAAE;IACrD,OAAO;QACH,MAAM,YAAY,SAAS,aAAa,CAAC;QACzC,UAAU,KAAK,CAAC,OAAO,GAAG;QAC1B,MAAM,YAAY,SAAS,aAAa,CAAC;QACzC,UAAU,QAAQ,GAAG;QACrB,UAAU,EAAE,GAAG;QACf,UAAU,IAAI,GAAG;QACjB,UAAU,KAAK,CAAC,OAAO,GAAG;QAC1B,uDAAuD;QACvD,MAAM,SAAS,UAAU,YAAY,CAAC;YAClC,MAAM;QACV;QACA,OAAO,WAAW,CAAC;QACnB,SAAS,IAAI,CAAC,WAAW,CAAC;QAC1B,OAAO;IACX;AACJ;AACA,SAAS,mBAAmB,EAAE,IAAI,EAAE;IAChC,MAAM,CAAC,YAAY,cAAc,GAAG,CAAC,GAAG,OAAO,QAAQ,EAAE;IACzD,CAAC,GAAG,OAAO,SAAS,EAAE;QAClB,MAAM,YAAY;QAClB,cAAc;QACd,OAAO;YACH,MAAM,YAAY,SAAS,oBAAoB,CAAC,eAAe,CAAC,EAAE;YAClE,IAAI,WAAW,aAAa;gBACxB,SAAS,IAAI,CAAC,WAAW,CAAC;YAC9B;QACJ;IACJ,GAAG,EAAE;IACL,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,CAAC,GAAG,OAAO,QAAQ,EAAE;IACvE,MAAM,gBAAgB,CAAC,GAAG,OAAO,MAAM,EAAE;IACzC,CAAC,GAAG,OAAO,SAAS,EAAE;QAClB,IAAI,eAAe;QACnB,IAAI,SAAS,KAAK,EAAE;YAChB,eAAe,SAAS,KAAK;QACjC,OAAO;YACH,MAAM,aAAa,SAAS,aAAa,CAAC;YAC1C,IAAI,YAAY;gBACZ,eAAe,WAAW,SAAS,IAAI,WAAW,WAAW,IAAI;YACrE;QACJ;QACA,4EAA4E;QAC5E,iCAAiC;QACjC,IAAI,cAAc,OAAO,KAAK,aAAa,cAAc,OAAO,KAAK,cAAc;YAC/E,qBAAqB;QACzB;QACA,cAAc,OAAO,GAAG;IAC5B,GAAG;QACC;KACH;IACD,OAAO,aAAa,WAAW,GAAG,CAAC,GAAG,UAAU,YAAY,EAAE,mBAAmB,cAAc;AACnG;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8548, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/readonly-url-search-params.js"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */ /** @internal */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ReadonlyURLSearchParams\", {\n    enumerable: true,\n    get: function() {\n        return ReadonlyURLSearchParams;\n    }\n});\nclass ReadonlyURLSearchParamsError extends Error {\n    constructor(){\n        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');\n    }\n}\nclass ReadonlyURLSearchParams extends URLSearchParams {\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {\n        throw new ReadonlyURLSearchParamsError();\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=readonly-url-search-params.js.map"],"names":[],"mappings":"AAAA;;;;CAIC,GAAG,cAAc,GAClB,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,2BAA2B;IACtD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,qCAAqC;IACvC,aAAa;QACT,KAAK,CAAC;IACV;AACJ;AACA,MAAM,gCAAgC;IAClC,wKAAwK,GAAG,SAAS;QAChL,MAAM,IAAI;IACd;IACA,wKAAwK,GAAG,SAAS;QAChL,MAAM,IAAI;IACd;IACA,wKAAwK,GAAG,MAAM;QAC7K,MAAM,IAAI;IACd;IACA,wKAAwK,GAAG,OAAO;QAC9K,MAAM,IAAI;IACd;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,sDAAsD","ignoreList":[0]}},
    {"offset": {"line": 8591, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/unrecognized-action-error.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    UnrecognizedActionError: null,\n    unstable_isUnrecognizedActionError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    UnrecognizedActionError: function() {\n        return UnrecognizedActionError;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return unstable_isUnrecognizedActionError;\n    }\n});\nclass UnrecognizedActionError extends Error {\n    constructor(...args){\n        super(...args);\n        this.name = 'UnrecognizedActionError';\n    }\n}\nfunction unstable_isUnrecognizedActionError(error) {\n    return !!(error && typeof error === 'object' && error instanceof UnrecognizedActionError);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unrecognized-action-error.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,yBAAyB;IACzB,oCAAoC;AACxC,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,yBAAyB;QACrB,OAAO;IACX;IACA,oCAAoC;QAChC,OAAO;IACX;AACJ;AACA,MAAM,gCAAgC;IAClC,YAAY,GAAG,IAAI,CAAC;QAChB,KAAK,IAAI;QACT,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACA,SAAS,mCAAmC,KAAK;IAC7C,OAAO,CAAC,CAAC,CAAC,SAAS,OAAO,UAAU,YAAY,iBAAiB,uBAAuB;AAC5F;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 8632, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getRedirectError: null,\n    getRedirectStatusCodeFromError: null,\n    getRedirectTypeFromError: null,\n    getURLFromRedirectError: null,\n    permanentRedirect: null,\n    redirect: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRedirectError: function() {\n        return getRedirectError;\n    },\n    getRedirectStatusCodeFromError: function() {\n        return getRedirectStatusCodeFromError;\n    },\n    getRedirectTypeFromError: function() {\n        return getRedirectTypeFromError;\n    },\n    getURLFromRedirectError: function() {\n        return getURLFromRedirectError;\n    },\n    permanentRedirect: function() {\n        return permanentRedirect;\n    },\n    redirect: function() {\n        return redirect;\n    }\n});\nconst _redirectstatuscode = require(\"./redirect-status-code\");\nconst _redirecterror = require(\"./redirect-error\");\nconst actionAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/action-async-storage.external').actionAsyncStorage : undefined;\nfunction getRedirectError(url, type, statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect) {\n    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = `${_redirecterror.REDIRECT_ERROR_CODE};${type};${url};${statusCode};`;\n    return error;\n}\nfunction redirect(/** The URL to redirect to */ url, type) {\n    type ??= actionAsyncStorage?.getStore()?.isAction ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;\n    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);\n}\nfunction permanentRedirect(/** The URL to redirect to */ url, type = _redirecterror.RedirectType.replace) {\n    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);\n}\nfunction getURLFromRedirectError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) return null;\n    // Slices off the beginning of the digest that contains the code and the\n    // separating ';'.\n    return error.digest.split(';').slice(2, -2).join(';');\n}\nfunction getRedirectTypeFromError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) {\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\n            value: \"E260\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return error.digest.split(';', 2)[1];\n}\nfunction getRedirectStatusCodeFromError(error) {\n    if (!(0, _redirecterror.isRedirectError)(error)) {\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\n            value: \"E260\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return Number(error.digest.split(';').at(-2));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8725, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/forbidden.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"forbidden\", {\n    enumerable: true,\n    get: function() {\n        return forbidden;\n    }\n});\nconst _httpaccessfallback = require(\"./http-access-fallback/http-access-fallback\");\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};403`;\nfunction forbidden() {\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n        throw Object.defineProperty(new Error(`\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E488\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=forbidden.js.map"],"names":[],"mappings":"AAyBS;AAzBT;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,aAAa;IACxC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAAG,MAAM,SAAS,GAAG,oBAAoB,8BAA8B,CAAC,IAAI,CAAC;AAC9E,SAAS;IACL,wCAAsD;QAClD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,+GAA+G,CAAC,GAAG,qBAAqB;YAC3K,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,SAAS,qBAAqB;QACxE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,MAAM,GAAG;IACf,MAAM;AACV;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 8777, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/unauthorized.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unauthorized\", {\n    enumerable: true,\n    get: function() {\n        return unauthorized;\n    }\n});\nconst _httpaccessfallback = require(\"./http-access-fallback/http-access-fallback\");\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */ const DIGEST = `${_httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE};401`;\nfunction unauthorized() {\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n        throw Object.defineProperty(new Error(`\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E411\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unauthorized.js.map"],"names":[],"mappings":"AA0BS;AA1BT;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,gBAAgB;IAC3C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAAG,MAAM,SAAS,GAAG,oBAAoB,8BAA8B,CAAC,IAAI,CAAC;AAC9E,SAAS;IACL,wCAAsD;QAClD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,+GAA+G,CAAC,GAAG,qBAAqB;YAC3K,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,SAAS,qBAAqB;QACxE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,MAAM,GAAG;IACf,MAAM;AACV;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 8830, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/unstable-rethrow.browser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_rethrow\", {\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n});\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _isnextroutererror = require(\"./is-next-router-error\");\nfunction unstable_rethrow(error) {\n    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error)) {\n        throw error;\n    }\n    if (error instanceof Error && 'cause' in error) {\n        unstable_rethrow(error.cause);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unstable-rethrow.browser.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,oBAAoB;IAC/C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,iBAAiB,KAAK;IAC3B,IAAI,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,UAAU,CAAC,GAAG,cAAc,mBAAmB,EAAE,QAAQ;QACnG,MAAM;IACV;IACA,IAAI,iBAAiB,SAAS,WAAW,OAAO;QAC5C,iBAAiB,MAAM,KAAK;IAChC;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 8860, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/hooks-server-context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DynamicServerError: null,\n    isDynamicServerError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DynamicServerError: function() {\n        return DynamicServerError;\n    },\n    isDynamicServerError: function() {\n        return isDynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\nclass DynamicServerError extends Error {\n    constructor(description){\n        super(`Dynamic server usage: ${description}`), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nfunction isDynamicServerError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=hooks-server-context.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,sBAAsB;AAC1B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,sBAAsB;QAClB,OAAO;IACX;AACJ;AACA,MAAM,qBAAqB;AAC3B,MAAM,2BAA2B;IAC7B,YAAY,WAAW,CAAC;QACpB,KAAK,CAAC,CAAC,sBAAsB,EAAE,aAAa,GAAG,IAAI,CAAC,WAAW,GAAG,aAAa,IAAI,CAAC,MAAM,GAAG;IACjG;AACJ;AACA,SAAS,qBAAqB,GAAG;IAC7B,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,KAAK,OAAO,IAAI,MAAM,KAAK,UAAU;QACjG,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 8904, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/static-generation-bailout.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    StaticGenBailoutError: null,\n    isStaticGenBailoutError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=static-generation-bailout.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,uBAAuB;IACvB,yBAAyB;AAC7B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,uBAAuB;QACnB,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;AACJ;AACA,MAAM,0BAA0B;AAChC,MAAM,8BAA8B;IAChC,YAAY,GAAG,IAAI,CAAC;QAChB,KAAK,IAAI,OAAO,IAAI,CAAC,IAAI,GAAG;IAChC;AACJ;AACA,SAAS,wBAAwB,KAAK;IAClC,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,CAAC,UAAU,KAAK,GAAG;QACnE,OAAO;IACX;IACA,OAAO,MAAM,IAAI,KAAK;AAC1B;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 8948, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/unstable-rethrow.server.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_rethrow\", {\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n});\nconst _dynamicrenderingutils = require(\"../../server/dynamic-rendering-utils\");\nconst _ispostpone = require(\"../../server/lib/router-utils/is-postpone\");\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _isnextroutererror = require(\"./is-next-router-error\");\nconst _dynamicrendering = require(\"../../server/app-render/dynamic-rendering\");\nconst _hooksservercontext = require(\"./hooks-server-context\");\nfunction unstable_rethrow(error) {\n    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error) || (0, _dynamicrendering.isPrerenderInterruptedError)(error)) {\n        throw error;\n    }\n    if (error instanceof Error && 'cause' in error) {\n        unstable_rethrow(error.cause);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unstable-rethrow.server.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,oBAAoB;IAC/C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,iBAAiB,KAAK;IAC3B,IAAI,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,UAAU,CAAC,GAAG,cAAc,mBAAmB,EAAE,UAAU,CAAC,GAAG,oBAAoB,oBAAoB,EAAE,UAAU,CAAC,GAAG,kBAAkB,iBAAiB,EAAE,UAAU,CAAC,GAAG,YAAY,UAAU,EAAE,UAAU,CAAC,GAAG,uBAAuB,8BAA8B,EAAE,UAAU,CAAC,GAAG,kBAAkB,2BAA2B,EAAE,QAAQ;QACtX,MAAM;IACV;IACA,IAAI,iBAAiB,SAAS,WAAW,OAAO;QAC5C,iBAAiB,MAAM,KAAK;IAChC;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 8982, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/unstable-rethrow.js"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_rethrow\", {\n    enumerable: true,\n    get: function() {\n        return unstable_rethrow;\n    }\n});\nconst unstable_rethrow = typeof window === 'undefined' ? require('./unstable-rethrow.server').unstable_rethrow : require('./unstable-rethrow.browser').unstable_rethrow;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unstable-rethrow.js.map"],"names":[],"mappings":"AAAA;;;;;;CAMC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,oBAAoB;IAC/C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,mBAAmB,OAAO,WAAW,cAAc,mJAAqC,gBAAgB,GAAG,oJAAsC,gBAAgB;AAEvK,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 9009, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/navigation.react-server.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ReadonlyURLSearchParams: null,\n    RedirectType: null,\n    forbidden: null,\n    notFound: null,\n    permanentRedirect: null,\n    redirect: null,\n    unauthorized: null,\n    unstable_isUnrecognizedActionError: null,\n    unstable_rethrow: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyURLSearchParams: function() {\n        return _readonlyurlsearchparams.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _redirecterror.RedirectType;\n    },\n    forbidden: function() {\n        return _forbidden.forbidden;\n    },\n    notFound: function() {\n        return _notfound.notFound;\n    },\n    permanentRedirect: function() {\n        return _redirect.permanentRedirect;\n    },\n    redirect: function() {\n        return _redirect.redirect;\n    },\n    unauthorized: function() {\n        return _unauthorized.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _unstablerethrow.unstable_rethrow;\n    }\n});\nconst _readonlyurlsearchparams = require(\"./readonly-url-search-params\");\nconst _redirect = require(\"./redirect\");\nconst _redirecterror = require(\"./redirect-error\");\nconst _notfound = require(\"./not-found\");\nconst _forbidden = require(\"./forbidden\");\nconst _unauthorized = require(\"./unauthorized\");\nconst _unstablerethrow = require(\"./unstable-rethrow\");\nfunction unstable_isUnrecognizedActionError() {\n    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E776\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.react-server.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,yBAAyB;IACzB,cAAc;IACd,WAAW;IACX,UAAU;IACV,mBAAmB;IACnB,UAAU;IACV,cAAc;IACd,oCAAoC;IACpC,kBAAkB;AACtB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,yBAAyB;QACrB,OAAO,yBAAyB,uBAAuB;IAC3D;IACA,cAAc;QACV,OAAO,eAAe,YAAY;IACtC;IACA,WAAW;QACP,OAAO,WAAW,SAAS;IAC/B;IACA,UAAU;QACN,OAAO,UAAU,QAAQ;IAC7B;IACA,mBAAmB;QACf,OAAO,UAAU,iBAAiB;IACtC;IACA,UAAU;QACN,OAAO,UAAU,QAAQ;IAC7B;IACA,cAAc;QACV,OAAO,cAAc,YAAY;IACrC;IACA,oCAAoC;QAChC,OAAO;IACX;IACA,kBAAkB;QACd,OAAO,iBAAiB,gBAAgB;IAC5C;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS;IACL,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,yEAAyE,qBAAqB;QAChI,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 9083, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/navigation.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ReadonlyURLSearchParams: null,\n    RedirectType: null,\n    ServerInsertedHTMLContext: null,\n    forbidden: null,\n    notFound: null,\n    permanentRedirect: null,\n    redirect: null,\n    unauthorized: null,\n    unstable_isUnrecognizedActionError: null,\n    unstable_rethrow: null,\n    useParams: null,\n    usePathname: null,\n    useRouter: null,\n    useSearchParams: null,\n    useSelectedLayoutSegment: null,\n    useSelectedLayoutSegments: null,\n    useServerInsertedHTML: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyURLSearchParams: function() {\n        return _navigationreactserver.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _navigationreactserver.RedirectType;\n    },\n    ServerInsertedHTMLContext: function() {\n        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;\n    },\n    forbidden: function() {\n        return _navigationreactserver.forbidden;\n    },\n    notFound: function() {\n        return _navigationreactserver.notFound;\n    },\n    permanentRedirect: function() {\n        return _navigationreactserver.permanentRedirect;\n    },\n    redirect: function() {\n        return _navigationreactserver.redirect;\n    },\n    unauthorized: function() {\n        return _navigationreactserver.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return _unrecognizedactionerror.unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _navigationreactserver.unstable_rethrow;\n    },\n    useParams: function() {\n        return useParams;\n    },\n    usePathname: function() {\n        return usePathname;\n    },\n    useRouter: function() {\n        return useRouter;\n    },\n    useSearchParams: function() {\n        return useSearchParams;\n    },\n    useSelectedLayoutSegment: function() {\n        return useSelectedLayoutSegment;\n    },\n    useSelectedLayoutSegments: function() {\n        return useSelectedLayoutSegments;\n    },\n    useServerInsertedHTML: function() {\n        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _approutercontextsharedruntime = require(\"../../shared/lib/app-router-context.shared-runtime\");\nconst _hooksclientcontextsharedruntime = require(\"../../shared/lib/hooks-client-context.shared-runtime\");\nconst _segment = require(\"../../shared/lib/segment\");\nconst _readonlyurlsearchparams = require(\"./readonly-url-search-params\");\nconst _serverinsertedhtmlsharedruntime = require(\"../../shared/lib/server-inserted-html.shared-runtime\");\nconst _unrecognizedactionerror = require(\"./unrecognized-action-error\");\nconst _navigationreactserver = require(\"./navigation.react-server\");\nconst useDynamicRouteParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicRouteParams : undefined;\nconst useDynamicSearchParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicSearchParams : undefined;\nfunction useSearchParams() {\n    useDynamicSearchParams?.('useSearchParams()');\n    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);\n    // In the case where this is `null`, the compat types added in\n    // `next-env.d.ts` will add a new overload that changes the return type to\n    // include `null`.\n    const readonlySearchParams = (0, _react.useMemo)(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new _readonlyurlsearchparams.ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.searchParams);\n        }\n    }\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    useDynamicRouteParams?.('usePathname()');\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\n    // will add a new overload that changes the return type to include `null`.\n    const pathname = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.pathname);\n        }\n    }\n    return pathname;\n}\nfunction useRouter() {\n    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);\n    if (router === null) {\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E238\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return router;\n}\nfunction useParams() {\n    useDynamicRouteParams?.('useParams()');\n    const params = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.params);\n        }\n    }\n    return params;\n}\nfunction useSelectedLayoutSegments(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegments()');\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n    if (!context) return null;\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            const promise = navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey);\n            if (promise) {\n                // We should always have a promise here, but if we don't, it's not worth erroring over.\n                // We just won't be able to instrument it, but can still provide the value.\n                return (0, _react.use)(promise);\n            }\n        }\n    }\n    return (0, _segment.getSelectedLayoutSegmentPath)(context.parentTree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegment()');\n    const navigationPromises = (0, _react.useContext)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    // Instrument with Suspense DevTools (dev-only)\n    if (process.env.NODE_ENV !== 'production' && navigationPromises && 'use' in _react.default) {\n        const promise = navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey);\n        if (promise) {\n            // We should always have a promise here, but if we don't, it's not worth erroring over.\n            // We just won't be able to instrument it, but can still provide the value.\n            return (0, _react.use)(promise);\n        }\n    }\n    return (0, _segment.computeSelectedLayoutSegment)(selectedLayoutSegments, parallelRouteKey);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9284, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/redirect-boundary.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    RedirectBoundary: null,\n    RedirectErrorBoundary: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    RedirectBoundary: function() {\n        return RedirectBoundary;\n    },\n    RedirectErrorBoundary: function() {\n        return RedirectErrorBoundary;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _navigation = require(\"./navigation\");\nconst _redirect = require(\"./redirect\");\nconst _redirecterror = require(\"./redirect-error\");\nfunction HandleRedirect({ redirect, reset, redirectType }) {\n    const router = (0, _navigation.useRouter)();\n    (0, _react.useEffect)(()=>{\n        _react.default.startTransition(()=>{\n            if (redirectType === _redirecterror.RedirectType.push) {\n                router.push(redirect, {});\n            } else {\n                router.replace(redirect, {});\n            }\n            reset();\n        });\n    }, [\n        redirect,\n        redirectType,\n        reset,\n        router\n    ]);\n    return null;\n}\nclass RedirectErrorBoundary extends _react.default.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            redirect: null,\n            redirectType: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _redirecterror.isRedirectError)(error)) {\n            const url = (0, _redirect.getURLFromRedirectError)(error);\n            const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n            if ('handled' in error) {\n                // The redirect was already handled. We'll still catch the redirect error\n                // so that we can remount the subtree, but we don't actually need to trigger the\n                // router.push.\n                return {\n                    redirect: null,\n                    redirectType: null\n                };\n            }\n            return {\n                redirect: url,\n                redirectType\n            };\n        }\n        // Re-throw if error is not for redirect\n        throw error;\n    }\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n    render() {\n        const { redirect, redirectType } = this.state;\n        if (redirect !== null && redirectType !== null) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleRedirect, {\n                redirect: redirect,\n                redirectType: redirectType,\n                reset: ()=>this.setState({\n                        redirect: null\n                    })\n            });\n        }\n        return this.props.children;\n    }\n}\nfunction RedirectBoundary({ children }) {\n    const router = (0, _navigation.useRouter)();\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(RedirectErrorBoundary, {\n        router: router,\n        children: children\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=redirect-boundary.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,kBAAkB;IAClB,uBAAuB;AAC3B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,kBAAkB;QACd,OAAO;IACX;IACA,uBAAuB;QACnB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,SAAS,WAAW,GAAG,0BAA0B,CAAC;AACxD,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,eAAe,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE;IACrD,MAAM,SAAS,CAAC,GAAG,YAAY,SAAS;IACxC,CAAC,GAAG,OAAO,SAAS,EAAE;QAClB,OAAO,OAAO,CAAC,eAAe,CAAC;YAC3B,IAAI,iBAAiB,eAAe,YAAY,CAAC,IAAI,EAAE;gBACnD,OAAO,IAAI,CAAC,UAAU,CAAC;YAC3B,OAAO;gBACH,OAAO,OAAO,CAAC,UAAU,CAAC;YAC9B;YACA;QACJ;IACJ,GAAG;QACC;QACA;QACA;QACA;KACH;IACD,OAAO;AACX;AACA,MAAM,8BAA8B,OAAO,OAAO,CAAC,SAAS;IACxD,YAAY,KAAK,CAAC;QACd,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;YACT,UAAU;YACV,cAAc;QAClB;IACJ;IACA,OAAO,yBAAyB,KAAK,EAAE;QACnC,IAAI,CAAC,GAAG,eAAe,eAAe,EAAE,QAAQ;YAC5C,MAAM,MAAM,CAAC,GAAG,UAAU,uBAAuB,EAAE;YACnD,MAAM,eAAe,CAAC,GAAG,UAAU,wBAAwB,EAAE;YAC7D,IAAI,aAAa,OAAO;gBACpB,yEAAyE;gBACzE,gFAAgF;gBAChF,eAAe;gBACf,OAAO;oBACH,UAAU;oBACV,cAAc;gBAClB;YACJ;YACA,OAAO;gBACH,UAAU;gBACV;YACJ;QACJ;QACA,wCAAwC;QACxC,MAAM;IACV;IACA,yIAAyI;IACzI,SAAS;QACL,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC,KAAK;QAC7C,IAAI,aAAa,QAAQ,iBAAiB,MAAM;YAC5C,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,gBAAgB;gBACtD,UAAU;gBACV,cAAc;gBACd,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC;wBACjB,UAAU;oBACd;YACR;QACJ;QACA,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAC9B;AACJ;AACA,SAAS,iBAAiB,EAAE,QAAQ,EAAE;IAClC,MAAM,SAAS,CAAC,GAAG,YAAY,SAAS;IACxC,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,uBAAuB;QAC7D,QAAQ;QACR,UAAU;IACd;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 9392, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"findHeadInCache\", {\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n});\nconst _segment = require(\"../../../../shared/lib/segment\");\nconst _createroutercachekey = require(\"../create-router-cache-key\");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, '', '');\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix, keyPrefixWithoutSearchParams) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix,\n            keyPrefixWithoutSearchParams\n        ];\n    }\n    // First try the 'children' parallel route if it exists\n    // when starting from the \"root\", this corresponds with the main page component\n    const parallelRoutesKeys = Object.keys(parallelRoutes).filter((key)=>key !== 'children');\n    // if we are at the root, we need to check the children slot first\n    if ('children' in parallelRoutes) {\n        parallelRoutesKeys.unshift('children');\n    }\n    for (const key of parallelRoutesKeys){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        // If the parallel is not matched and using the default segment,\n        // skip searching the head from it.\n        if (segment === _segment.DEFAULT_SEGMENT_KEY) {\n            continue;\n        }\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheKeyWithoutSearchParams = (0, _createroutercachekey.createRouterCacheKey)(segment, true);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey, keyPrefix + '/' + cacheKeyWithoutSearchParams);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=find-head-in-cache.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,mBAAmB;IAC9C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,gBAAgB,KAAK,EAAE,cAAc;IAC1C,OAAO,oBAAoB,OAAO,gBAAgB,IAAI;AAC1D;AACA,SAAS,oBAAoB,KAAK,EAAE,cAAc,EAAE,SAAS,EAAE,4BAA4B;IACvF,MAAM,aAAa,OAAO,IAAI,CAAC,gBAAgB,MAAM,KAAK;IAC1D,IAAI,YAAY;QACZ,0EAA0E;QAC1E,OAAO;YACH;YACA;YACA;SACH;IACL;IACA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAM,qBAAqB,OAAO,IAAI,CAAC,gBAAgB,MAAM,CAAC,CAAC,MAAM,QAAQ;IAC7E,kEAAkE;IAClE,IAAI,cAAc,gBAAgB;QAC9B,mBAAmB,OAAO,CAAC;IAC/B;IACA,KAAK,MAAM,OAAO,mBAAmB;QACjC,MAAM,CAAC,SAAS,oBAAoB,GAAG,cAAc,CAAC,IAAI;QAC1D,gEAAgE;QAChE,mCAAmC;QACnC,IAAI,YAAY,SAAS,mBAAmB,EAAE;YAC1C;QACJ;QACA,MAAM,kBAAkB,MAAM,cAAc,CAAC,GAAG,CAAC;QACjD,IAAI,CAAC,iBAAiB;YAClB;QACJ;QACA,MAAM,WAAW,CAAC,GAAG,sBAAsB,oBAAoB,EAAE;QACjE,MAAM,8BAA8B,CAAC,GAAG,sBAAsB,oBAAoB,EAAE,SAAS;QAC7F,MAAM,YAAY,gBAAgB,GAAG,CAAC;QACtC,IAAI,CAAC,WAAW;YACZ;QACJ;QACA,MAAM,OAAO,oBAAoB,WAAW,qBAAqB,YAAY,MAAM,UAAU,YAAY,MAAM;QAC/G,IAAI,MAAM;YACN,OAAO;QACX;IACJ;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 9458, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/unresolved-thenable.js"],"sourcesContent":["/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unresolvedThenable\", {\n    enumerable: true,\n    get: function() {\n        return unresolvedThenable;\n    }\n});\nconst unresolvedThenable = {\n    then: ()=>{}\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unresolved-thenable.js.map"],"names":[],"mappings":"AAAA;;CAEC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM,qBAAqB;IACvB,MAAM,KAAK;AACf;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 9483, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/has-base-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasBasePath\", {\n    enumerable: true,\n    get: function() {\n        return hasBasePath;\n    }\n});\nconst _pathhasprefix = require(\"../shared/lib/router/utils/path-has-prefix\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction hasBasePath(path) {\n    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=has-base-path.js.map"],"names":[],"mappings":"AAWiB;AAXjB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,eAAe;IAC1C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,WAAW,wCAAsC;AACvD,SAAS,YAAY,IAAI;IACrB,OAAO,CAAC,GAAG,eAAe,aAAa,EAAE,MAAM;AACnD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 9510, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/remove-base-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"removeBasePath\", {\n    enumerable: true,\n    get: function() {\n        return removeBasePath;\n    }\n});\nconst _hasbasepath = require(\"./has-base-path\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction removeBasePath(path) {\n    if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n        if (!(0, _hasbasepath.hasBasePath)(path)) {\n            return path;\n        }\n    }\n    // Can't trim the basePath if it has zero length!\n    if (basePath.length === 0) return path;\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = `/${path}`;\n    return path;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=remove-base-path.js.map"],"names":[],"mappings":"AAWiB;AAXjB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM,WAAW,wCAAsC;AACvD,SAAS,eAAe,IAAI;IACxB;;IAKA,iDAAiD;IACjD,IAAI,SAAS,MAAM,KAAK,GAAG,OAAO;IAClC,OAAO,KAAK,KAAK,CAAC,SAAS,MAAM;IACjC,IAAI,CAAC,KAAK,UAAU,CAAC,MAAM,OAAO,CAAC,CAAC,EAAE,MAAM;IAC5C,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 9543, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    GracefulDegradeBoundary: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    GracefulDegradeBoundary: function() {\n        return GracefulDegradeBoundary;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = require(\"react\");\nfunction getDomNodeAttributes(node) {\n    const result = {};\n    for(let i = 0; i < node.attributes.length; i++){\n        const attr = node.attributes[i];\n        result[attr.name] = attr.value;\n    }\n    return result;\n}\nclass GracefulDegradeBoundary extends _react.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            hasError: false\n        };\n        this.rootHtml = '';\n        this.htmlAttributes = {};\n        this.htmlRef = /*#__PURE__*/ (0, _react.createRef)();\n    }\n    static getDerivedStateFromError(_) {\n        return {\n            hasError: true\n        };\n    }\n    componentDidMount() {\n        const htmlNode = this.htmlRef.current;\n        if (this.state.hasError && htmlNode) {\n            // Reapply the cached HTML attributes to the root element\n            Object.entries(this.htmlAttributes).forEach(([key, value])=>{\n                htmlNode.setAttribute(key, value);\n            });\n        }\n    }\n    render() {\n        const { hasError } = this.state;\n        // Cache the root HTML content on the first render\n        if (typeof window !== 'undefined' && !this.rootHtml) {\n            this.rootHtml = document.documentElement.innerHTML;\n            this.htmlAttributes = getDomNodeAttributes(document.documentElement);\n        }\n        if (hasError) {\n            // Render the current HTML content without hydration\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"html\", {\n                ref: this.htmlRef,\n                suppressHydrationWarning: true,\n                dangerouslySetInnerHTML: {\n                    __html: this.rootHtml\n                }\n            });\n        }\n        return this.props.children;\n    }\n}\nconst _default = GracefulDegradeBoundary;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=graceful-degrade-boundary.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,yBAAyB;IACzB,SAAS;AACb,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,yBAAyB;QACrB,OAAO;IACX;IACA,SAAS;QACL,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS,qBAAqB,IAAI;IAC9B,MAAM,SAAS,CAAC;IAChB,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,UAAU,CAAC,MAAM,EAAE,IAAI;QAC3C,MAAM,OAAO,KAAK,UAAU,CAAC,EAAE;QAC/B,MAAM,CAAC,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK;IAClC;IACA,OAAO;AACX;AACA,MAAM,gCAAgC,OAAO,SAAS;IAClD,YAAY,KAAK,CAAC;QACd,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;YACT,UAAU;QACd;QACA,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,cAAc,GAAG,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,WAAW,GAAG,CAAC,GAAG,OAAO,SAAS;IACrD;IACA,OAAO,yBAAyB,CAAC,EAAE;QAC/B,OAAO;YACH,UAAU;QACd;IACJ;IACA,oBAAoB;QAChB,MAAM,WAAW,IAAI,CAAC,OAAO,CAAC,OAAO;QACrC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,UAAU;YACjC,yDAAyD;YACzD,OAAO,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;gBACrD,SAAS,YAAY,CAAC,KAAK;YAC/B;QACJ;IACJ;IACA,SAAS;QACL,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,KAAK;QAC/B,kDAAkD;QAClD,IAAI,OAAO,WAAW,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE;YACjD,IAAI,CAAC,QAAQ,GAAG,SAAS,eAAe,CAAC,SAAS;YAClD,IAAI,CAAC,cAAc,GAAG,qBAAqB,SAAS,eAAe;QACvE;QACA,IAAI,UAAU;YACV,oDAAoD;YACpD,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,QAAQ;gBAC9C,KAAK,IAAI,CAAC,OAAO;gBACjB,0BAA0B;gBAC1B,yBAAyB;oBACrB,QAAQ,IAAI,CAAC,QAAQ;gBACzB;YACJ;QACJ;QACA,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAC9B;AACJ;AACA,MAAM,WAAW;AAEjB,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 9630, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/errors/root-error-boundary.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return RootErrorBoundary;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_default._(require(\"react\"));\nconst _gracefuldegradeboundary = /*#__PURE__*/ _interop_require_default._(require(\"./graceful-degrade-boundary\"));\nconst _errorboundary = require(\"../error-boundary\");\nconst _isbot = require(\"../../../shared/lib/router/utils/is-bot\");\nconst isBotUserAgent = typeof window !== 'undefined' && (0, _isbot.isBot)(window.navigator.userAgent);\nfunction RootErrorBoundary({ children, errorComponent, errorStyles, errorScripts }) {\n    if (isBotUserAgent) {\n        // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n        // and to keep the original SSR output intact.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_gracefuldegradeboundary.default, {\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n        errorComponent: errorComponent,\n        errorStyles: errorStyles,\n        errorScripts: errorScripts,\n        children: children\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=root-error-boundary.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,WAAW;IACtC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,SAAS,WAAW,GAAG,yBAAyB,CAAC;AACvD,MAAM,2BAA2B,WAAW,GAAG,yBAAyB,CAAC;AACzE,MAAM;AACN,MAAM;AACN,MAAM,iBAAiB,OAAO,WAAW,eAAe,CAAC,GAAG,OAAO,KAAK,EAAE,OAAO,SAAS,CAAC,SAAS;AACpG,SAAS,kBAAkB,EAAE,QAAQ,EAAE,cAAc,EAAE,WAAW,EAAE,YAAY,EAAE;IAC9E,IAAI,gBAAgB;QAChB,kFAAkF;QAClF,8CAA8C;QAC9C,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,yBAAyB,OAAO,EAAE;YACxE,UAAU;QACd;IACJ;IACA,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,eAAe,aAAa,EAAE;QACpE,gBAAgB;QAChB,aAAa;QACb,cAAc;QACd,UAAU;IACd;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 9672, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/navigation-devtools.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createLayoutSegmentPromises: null,\n    createNestedLayoutNavigationPromises: null,\n    createRootNavigationPromises: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createLayoutSegmentPromises: function() {\n        return createLayoutSegmentPromises;\n    },\n    createNestedLayoutNavigationPromises: function() {\n        return createNestedLayoutNavigationPromises;\n    },\n    createRootNavigationPromises: function() {\n        return createRootNavigationPromises;\n    }\n});\nconst _hooksclientcontextsharedruntime = require(\"../../shared/lib/hooks-client-context.shared-runtime\");\nconst _segment = require(\"../../shared/lib/segment\");\nconst _readonlyurlsearchparams = require(\"./readonly-url-search-params\");\nconst layoutSegmentPromisesCache = new WeakMap();\nfunction createLayoutSegmentPromises(tree) {\n    if (process.env.NODE_ENV === 'production') {\n        return null;\n    }\n    // Check if we already have cached promises for this tree\n    const cached = layoutSegmentPromisesCache.get(tree);\n    if (cached) {\n        return cached;\n    }\n    // Create new promises and cache them\n    const segmentPromises = new Map();\n    const segmentsPromises = new Map();\n    const parallelRoutes = tree[1];\n    for (const parallelRouteKey of Object.keys(parallelRoutes)){\n        const segments = (0, _segment.getSelectedLayoutSegmentPath)(tree, parallelRouteKey);\n        // Use the shared logic to compute the segment value\n        const segment = (0, _segment.computeSelectedLayoutSegment)(segments, parallelRouteKey);\n        segmentPromises.set(parallelRouteKey, (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSelectedLayoutSegment', segment));\n        segmentsPromises.set(parallelRouteKey, (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSelectedLayoutSegments', segments));\n    }\n    const result = {\n        selectedLayoutSegmentPromises: segmentPromises,\n        selectedLayoutSegmentsPromises: segmentsPromises\n    };\n    // Cache the result for future renders\n    layoutSegmentPromisesCache.set(tree, result);\n    return result;\n}\nconst rootNavigationPromisesCache = new WeakMap();\nfunction createRootNavigationPromises(tree, pathname, searchParams, pathParams) {\n    if (process.env.NODE_ENV === 'production') {\n        return null;\n    }\n    // Create stable cache keys from the values\n    const searchParamsString = searchParams.toString();\n    const pathParamsString = JSON.stringify(pathParams);\n    const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`;\n    // Get or create the cache for this tree\n    let treeCache = rootNavigationPromisesCache.get(tree);\n    if (!treeCache) {\n        treeCache = new Map();\n        rootNavigationPromisesCache.set(tree, treeCache);\n    }\n    // Check if we have cached promises for this combination\n    const cached = treeCache.get(cacheKey);\n    if (cached) {\n        return cached;\n    }\n    const readonlySearchParams = new _readonlyurlsearchparams.ReadonlyURLSearchParams(searchParams);\n    const layoutSegmentPromises = createLayoutSegmentPromises(tree);\n    const promises = {\n        pathname: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('usePathname', pathname),\n        searchParams: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSearchParams', readonlySearchParams),\n        params: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useParams', pathParams),\n        ...layoutSegmentPromises\n    };\n    treeCache.set(cacheKey, promises);\n    return promises;\n}\nconst nestedLayoutPromisesCache = new WeakMap();\nfunction createNestedLayoutNavigationPromises(tree, parentNavPromises) {\n    if (process.env.NODE_ENV === 'production') {\n        return null;\n    }\n    const parallelRoutes = tree[1];\n    const parallelRouteKeys = Object.keys(parallelRoutes);\n    // Only create promises if there are parallel routes at this level\n    if (parallelRouteKeys.length === 0) {\n        return null;\n    }\n    // Get or create the cache for this tree\n    let treeCache = nestedLayoutPromisesCache.get(tree);\n    if (!treeCache) {\n        treeCache = new Map();\n        nestedLayoutPromisesCache.set(tree, treeCache);\n    }\n    // Check if we have cached promises for this parent combination\n    const cached = treeCache.get(parentNavPromises);\n    if (cached) {\n        return cached;\n    }\n    // Create merged promises\n    const layoutSegmentPromises = createLayoutSegmentPromises(tree);\n    const promises = {\n        ...parentNavPromises,\n        ...layoutSegmentPromises\n    };\n    treeCache.set(parentNavPromises, promises);\n    return promises;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation-devtools.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9801, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", {\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _navigationuntracked = require(\"../navigation-untracked\");\nconst _httpaccessfallback = require(\"./http-access-fallback\");\nconst _warnonce = require(\"../../../shared/lib/utils/warn-once\");\nconst _approutercontextsharedruntime = require(\"../../../shared/lib/app-router-context.shared-runtime\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n    componentDidCatch() {\n        if (process.env.NODE_ENV === 'development' && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>`@${slot}`).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                    process.env.NODE_ENV === 'development' && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n}\nfunction HTTPAccessFallbackBoundary({ notFound, forbidden, unauthorized, children }) {\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=error-boundary.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9934, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js"],"sourcesContent":["'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DevRootHTTPAccessFallbackBoundary: null,\n    bailOnRootNotFound: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DevRootHTTPAccessFallbackBoundary: function() {\n        return DevRootHTTPAccessFallbackBoundary;\n    },\n    bailOnRootNotFound: function() {\n        return bailOnRootNotFound;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_default._(require(\"react\"));\nconst _errorboundary = require(\"./http-access-fallback/error-boundary\");\nfunction bailOnRootNotFound() {\n    throw Object.defineProperty(new Error('notFound() is not allowed to use in root layout'), \"__NEXT_ERROR_CODE\", {\n        value: \"E192\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction NotAllowedRootHTTPFallbackError() {\n    bailOnRootNotFound();\n    return null;\n}\nfunction DevRootHTTPAccessFallbackBoundary({ children }) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.HTTPAccessFallbackBoundary, {\n        notFound: /*#__PURE__*/ (0, _jsxruntime.jsx)(NotAllowedRootHTTPFallbackError, {}),\n        children: children\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=dev-root-http-access-fallback-boundary.js.map"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,mCAAmC;IACnC,oBAAoB;AACxB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,mCAAmC;QAC/B,OAAO;IACX;IACA,oBAAoB;QAChB,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,SAAS,WAAW,GAAG,yBAAyB,CAAC;AACvD,MAAM;AACN,SAAS;IACL,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,oDAAoD,qBAAqB;QAC3G,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;AACJ;AACA,SAAS;IACL;IACA,OAAO;AACX;AACA,SAAS,kCAAkC,EAAE,QAAQ,EAAE;IACnD,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,eAAe,0BAA0B,EAAE;QACjF,UAAU,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,iCAAiC,CAAC;QAC/E,UAAU;IACd;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,kEAAkE","ignoreList":[0]}},
    {"offset": {"line": 9987, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/dev/hot-reloader/shared.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    REACT_REFRESH_FULL_RELOAD: null,\n    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: null,\n    reportInvalidHmrMessage: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    REACT_REFRESH_FULL_RELOAD: function() {\n        return REACT_REFRESH_FULL_RELOAD;\n    },\n    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: function() {\n        return REACT_REFRESH_FULL_RELOAD_FROM_ERROR;\n    },\n    reportInvalidHmrMessage: function() {\n        return reportInvalidHmrMessage;\n    }\n});\nconst REACT_REFRESH_FULL_RELOAD = '[Fast Refresh] performing full reload\\n\\n' + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' + 'Fast Refresh requires at least one parent function component in your React tree.';\nconst REACT_REFRESH_FULL_RELOAD_FROM_ERROR = '[Fast Refresh] performing full reload because your application had an unrecoverable error';\nfunction reportInvalidHmrMessage(message, err) {\n    console.warn('[HMR] Invalid message: ' + JSON.stringify(message) + '\\n' + (err instanceof Error && err?.stack || ''));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=shared.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,2BAA2B;IAC3B,sCAAsC;IACtC,yBAAyB;AAC7B,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,2BAA2B;QACvB,OAAO;IACX;IACA,sCAAsC;QAClC,OAAO;IACX;IACA,yBAAyB;QACrB,OAAO;IACX;AACJ;AACA,MAAM,4BAA4B,8CAA8C,mIAAmI,qIAAqI,+GAA+G,8HAA8H;AACrkB,MAAM,uCAAuC;AAC7C,SAAS,wBAAwB,OAAO,EAAE,GAAG;IACzC,QAAQ,IAAI,CAAC,4BAA4B,KAAK,SAAS,CAAC,WAAW,OAAO,CAAC,eAAe,SAAS,KAAK,SAAS,EAAE;AACvH;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 10028, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/dev/report-hmr-latency.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, /**\n * Logs information about a completed HMR to the console, the server (via a\n * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging\n * hook).\n *\n * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a\n *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by\n *   turbopack when we must report a message to the browser console (because we\n *   already logged a \"rebuilding\" message), but it's not a real HMR, so we\n *   don't want to impact our telemetry.\n */ \"default\", {\n    enumerable: true,\n    get: function() {\n        return reportHmrLatency;\n    }\n});\nfunction reportHmrLatency(sendMessage, updatedModules, startMsSinceEpoch, endMsSinceEpoch, hasUpdate = true) {\n    const latencyMs = endMsSinceEpoch - startMsSinceEpoch;\n    console.log(`[Fast Refresh] done in ${latencyMs}ms`);\n    if (!hasUpdate) {\n        return;\n    }\n    sendMessage(JSON.stringify({\n        event: 'client-hmr-latency',\n        id: window.__nextDevClientId,\n        startTime: startMsSinceEpoch,\n        endTime: endMsSinceEpoch,\n        page: window.location.pathname,\n        updatedModules,\n        // Whether the page (tab) was hidden at the time the event occurred.\n        // This can impact the accuracy of the event's timing.\n        isPageHidden: document.visibilityState === 'hidden'\n    }));\n    if (self.__NEXT_HMR_LATENCY_CB) {\n        self.__NEXT_HMR_LATENCY_CB(latencyMs);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=report-hmr-latency.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS;;;;;;;;;;CAU9B,GAAG,WAAW;IACX,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,iBAAiB,WAAW,EAAE,cAAc,EAAE,iBAAiB,EAAE,eAAe,EAAE,YAAY,IAAI;IACvG,MAAM,YAAY,kBAAkB;IACpC,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,UAAU,EAAE,CAAC;IACnD,IAAI,CAAC,WAAW;QACZ;IACJ;IACA,YAAY,KAAK,SAAS,CAAC;QACvB,OAAO;QACP,IAAI,OAAO,iBAAiB;QAC5B,WAAW;QACX,SAAS;QACT,MAAM,OAAO,QAAQ,CAAC,QAAQ;QAC9B;QACA,oEAAoE;QACpE,sDAAsD;QACtD,cAAc,SAAS,eAAe,KAAK;IAC/C;IACA,IAAI,KAAK,qBAAqB,EAAE;QAC5B,KAAK,qBAAqB,CAAC;IAC/B;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 10079, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"TurbopackHmr\", {\n    enumerable: true,\n    get: function() {\n        return TurbopackHmr;\n    }\n});\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100;\nclass TurbopackHmr {\n    #updatedModules;\n    #startMsSinceEpoch;\n    #lastUpdateMsSinceEpoch;\n    #deferredReportHmrStartId;\n    #reportedHmrStart;\n    constructor(){\n        this.#updatedModules = new Set();\n        this.#reportedHmrStart = false;\n    }\n    // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n    // as it reports *any* compilation, including fully no-op/cached compilations\n    // and those unrelated to HMR. Fixing this would require significant\n    // architectural changes.\n    //\n    // Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n    // a BUILT event within that threshold and nothing has changed, just suppress\n    // the message entirely.\n    #runDeferredReportHmrStart() {\n        if (this.#deferredReportHmrStartId != null) {\n            console.log('[Fast Refresh] rebuilding');\n            this.#reportedHmrStart = true;\n            this.#cancelDeferredReportHmrStart();\n        }\n    }\n    #cancelDeferredReportHmrStart() {\n        clearTimeout(this.#deferredReportHmrStartId);\n        this.#deferredReportHmrStartId = undefined;\n    }\n    onBuilding() {\n        this.#lastUpdateMsSinceEpoch = undefined;\n        this.#cancelDeferredReportHmrStart();\n        this.#startMsSinceEpoch = Date.now();\n        // report the HMR start after a short delay\n        this.#deferredReportHmrStartId = setTimeout(()=>this.#runDeferredReportHmrStart(), // debugging feature: don't defer/suppress noisy no-op HMR update messages\n        self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS ? 0 : TURBOPACK_HMR_START_DELAY_MS);\n    }\n    /** Helper for other `onEvent` methods. */ #onUpdate() {\n        this.#runDeferredReportHmrStart();\n        this.#lastUpdateMsSinceEpoch = Date.now();\n    }\n    onTurbopackMessage(msg) {\n        this.#onUpdate();\n        const updatedModules = extractModulesFromTurbopackMessage(msg.data);\n        for (const module of updatedModules){\n            this.#updatedModules.add(module);\n        }\n    }\n    onServerComponentChanges() {\n        this.#onUpdate();\n    }\n    onReloadPage() {\n        this.#onUpdate();\n    }\n    onPageAddRemove() {\n        this.#onUpdate();\n    }\n    /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */ onBuilt() {\n        // Check that we got *any* `TurbopackMessage`, even if\n        // `updatedModules` is empty (not everything gets recorded there).\n        //\n        // There's also a case where `onBuilt` gets called before `onBuilding`,\n        // which can happen during initial page load. Ignore that too!\n        const hasUpdates = this.#lastUpdateMsSinceEpoch != null && this.#startMsSinceEpoch != null;\n        if (!hasUpdates && !this.#reportedHmrStart) {\n            // suppress the update entirely\n            this.#cancelDeferredReportHmrStart();\n            return null;\n        }\n        this.#runDeferredReportHmrStart();\n        const result = {\n            hasUpdates,\n            updatedModules: this.#updatedModules,\n            startMsSinceEpoch: this.#startMsSinceEpoch,\n            endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now()\n        };\n        this.#updatedModules = new Set();\n        this.#reportedHmrStart = false;\n        return result;\n    }\n}\nfunction extractModulesFromTurbopackMessage(data) {\n    const updatedModules = new Set();\n    const updates = Array.isArray(data) ? data : [\n        data\n    ];\n    for (const update of updates){\n        // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n        if (update.type !== 'partial' || update.instruction.type !== 'ChunkListUpdate' || update.instruction.merged === undefined) {\n            continue;\n        }\n        for (const mergedUpdate of update.instruction.merged){\n            for (const name of Object.keys(mergedUpdate.entries)){\n                const res = /(.*)\\s+[([].*/.exec(name);\n                if (res === null) {\n                    continue;\n                }\n                updatedModules.add(res[1]);\n            }\n        }\n    }\n    return updatedModules;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=turbopack-hot-reloader-common.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/dev/debug-channel.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createDebugChannel: null,\n    getOrCreateDebugChannelReadableWriterPair: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDebugChannel: function() {\n        return createDebugChannel;\n    },\n    getOrCreateDebugChannelReadableWriterPair: function() {\n        return getOrCreateDebugChannelReadableWriterPair;\n    }\n});\nconst _approuterheaders = require(\"../components/app-router-headers\");\nconst _invarianterror = require(\"../../shared/lib/invariant-error\");\nconst pairs = new Map();\nfunction getOrCreateDebugChannelReadableWriterPair(requestId) {\n    let pair = pairs.get(requestId);\n    if (!pair) {\n        const { readable, writable } = new TransformStream();\n        pair = {\n            readable,\n            writer: writable.getWriter()\n        };\n        pairs.set(requestId, pair);\n        pair.writer.closed.finally(()=>pairs.delete(requestId));\n    }\n    return pair;\n}\nfunction createDebugChannel(requestHeaders) {\n    let requestId;\n    if (requestHeaders) {\n        requestId = requestHeaders[_approuterheaders.NEXT_REQUEST_ID_HEADER] ?? undefined;\n        if (!requestId) {\n            throw Object.defineProperty(new _invarianterror.InvariantError(`Expected a ${JSON.stringify(_approuterheaders.NEXT_REQUEST_ID_HEADER)} request header.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E854\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    } else {\n        requestId = self.__next_r;\n        if (!requestId) {\n            throw Object.defineProperty(new _invarianterror.InvariantError(`Expected a request ID to be defined for the document via self.__next_r.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E806\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    const { readable } = getOrCreateDebugChannelReadableWriterPair(requestId);\n    return {\n        readable\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=debug-channel.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,oBAAoB;IACpB,2CAA2C;AAC/C,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,oBAAoB;QAChB,OAAO;IACX;IACA,2CAA2C;QACvC,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM,QAAQ,IAAI;AAClB,SAAS,0CAA0C,SAAS;IACxD,IAAI,OAAO,MAAM,GAAG,CAAC;IACrB,IAAI,CAAC,MAAM;QACP,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,IAAI;QACnC,OAAO;YACH;YACA,QAAQ,SAAS,SAAS;QAC9B;QACA,MAAM,GAAG,CAAC,WAAW;QACrB,KAAK,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,MAAM,MAAM,CAAC;IAChD;IACA,OAAO;AACX;AACA,SAAS,mBAAmB,cAAc;IACtC,IAAI;IACJ,IAAI,gBAAgB;QAChB,YAAY,cAAc,CAAC,kBAAkB,sBAAsB,CAAC,IAAI;QACxE,IAAI,CAAC,WAAW;YACZ,MAAM,OAAO,cAAc,CAAC,IAAI,gBAAgB,cAAc,CAAC,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,kBAAkB,sBAAsB,EAAE,gBAAgB,CAAC,GAAG,qBAAqB;gBAC3K,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;IACJ,OAAO;QACH,YAAY,KAAK,QAAQ;QACzB,IAAI,CAAC,WAAW;YACZ,MAAM,OAAO,cAAc,CAAC,IAAI,gBAAgB,cAAc,CAAC,CAAC,uEAAuE,CAAC,GAAG,qBAAqB;gBAC5J,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;IACJ;IACA,MAAM,EAAE,QAAQ,EAAE,GAAG,0CAA0C;IAC/D,OAAO;QACH;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 10282, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js"],"sourcesContent":["/// <reference types=\"webpack/module.d.ts\" />\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    performFullReload: null,\n    processMessage: null,\n    waitForWebpackRuntimeHotUpdate: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return HotReload;\n    },\n    performFullReload: function() {\n        return performFullReload;\n    },\n    processMessage: function() {\n        return processMessage;\n    },\n    waitForWebpackRuntimeHotUpdate: function() {\n        return waitForWebpackRuntimeHotUpdate;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = require(\"react\");\nconst _stripansi = /*#__PURE__*/ _interop_require_default._(require(\"next/dist/compiled/strip-ansi\"));\nconst _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(require(\"../../../../shared/lib/format-webpack-messages\"));\nconst _shared = require(\"../shared\");\nconst _nextdevtools = require(\"next/dist/compiled/next-devtools\");\nconst _replayssronlyerrors = require(\"../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors\");\nconst _appdevoverlayerrorboundary = require(\"../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary\");\nconst _useerrorhandler = require(\"../../../../next-devtools/userspace/app/errors/use-error-handler\");\nconst _runtimeerrorhandler = require(\"../../runtime-error-handler\");\nconst _websocket = require(\"./web-socket\");\nconst _hotreloadertypes = require(\"../../../../server/dev/hot-reloader-types\");\nconst _navigationuntracked = require(\"../../../components/navigation-untracked\");\nconst _reporthmrlatency = /*#__PURE__*/ _interop_require_default._(require(\"../../report-hmr-latency\"));\nconst _turbopackhotreloadercommon = require(\"../turbopack-hot-reloader-common\");\nconst _approuterheaders = require(\"../../../components/app-router-headers\");\nconst _approuterinstance = require(\"../../../components/app-router-instance\");\nconst _invarianterror = require(\"../../../../shared/lib/invariant-error\");\nconst _debugchannel = require(\"../../debug-channel\");\nlet mostRecentCompilationHash = null;\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nlet reloading = false;\nlet webpackStartMsSinceEpoch = null;\nconst turbopackHmr = process.env.TURBOPACK ? new _turbopackhotreloadercommon.TurbopackHmr() : null;\nlet pendingHotUpdateWebpack = Promise.resolve();\nlet resolvePendingHotUpdateWebpack = ()=>{};\nfunction setPendingHotUpdateWebpack() {\n    pendingHotUpdateWebpack = new Promise((resolve)=>{\n        resolvePendingHotUpdateWebpack = ()=>{\n            resolve();\n        };\n    });\n}\nfunction waitForWebpackRuntimeHotUpdate() {\n    return pendingHotUpdateWebpack;\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */ function isUpdateAvailable() {\n    if (process.env.TURBOPACK) {\n        return true;\n    }\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_hash__;\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === 'idle';\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === 'idle') {\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        module.hot.addStatusHandler(handler);\n    }\n}\nfunction performFullReload(err, sendMessage) {\n    const stackTrace = err && (err.stack && err.stack.split('\\n').slice(0, 5).join('\\n') || err.message || err + '');\n    sendMessage(JSON.stringify({\n        event: 'client-full-reload',\n        stackTrace,\n        hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,\n        dependencyChain: err ? err.dependencyChain : undefined\n    }));\n    if (reloading) return;\n    reloading = true;\n    window.location.reload();\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage) {\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        resolvePendingHotUpdateWebpack();\n        _nextdevtools.dispatcher.onBuildOk();\n        (0, _reporthmrlatency.default)(sendMessage, [], webpackStartMsSinceEpoch, Date.now());\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n            if (err) {\n                console.warn(_shared.REACT_REFRESH_FULL_RELOAD);\n            } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n            }\n            performFullReload(err, sendMessage);\n            return;\n        }\n        _nextdevtools.dispatcher.onBuildOk();\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            tryApplyUpdatesWebpack(sendMessage);\n            return;\n        }\n        _nextdevtools.dispatcher.onRefresh();\n        resolvePendingHotUpdateWebpack();\n        (0, _reporthmrlatency.default)(sendMessage, updatedModules, webpackStartMsSinceEpoch, Date.now());\n        if (process.env.__NEXT_TEST_MODE) {\n            afterApplyUpdates(()=>{\n                if (self.__NEXT_HMR_CB) {\n                    self.__NEXT_HMR_CB();\n                    self.__NEXT_HMR_CB = null;\n                }\n            });\n        }\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (updatedModules == null) {\n            return null;\n        }\n        // We should always handle an update, even if updatedModules is empty (but\n        // non-null) for any reason. That's what webpack would normally do:\n        // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n        _nextdevtools.dispatcher.onBeforeRefresh();\n        // https://webpack.js.org/api/hot-module-replacement/#apply\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\nfunction processMessage(message, sendMessage, processTurbopackMessage, staticIndicatorState) {\n    function handleErrors(errors) {\n        // \"Massage\" webpack messages.\n        const formatted = (0, _formatwebpackmessages.default)({\n            errors: errors,\n            warnings: []\n        });\n        // Only show the first error.\n        _nextdevtools.dispatcher.onBuildError(formatted.errors[0]);\n        // Also log them to the console.\n        for(let i = 0; i < formatted.errors.length; i++){\n            console.error((0, _stripansi.default)(formatted.errors[i]));\n        }\n        // Do not attempt to reload now.\n        // We will reload on next success instead.\n        if (process.env.__NEXT_TEST_MODE) {\n            if (self.__NEXT_HMR_CB) {\n                self.__NEXT_HMR_CB(formatted.errors[0]);\n                self.__NEXT_HMR_CB = null;\n            }\n        }\n    }\n    function handleHotUpdate() {\n        if (process.env.TURBOPACK) {\n            const hmrUpdate = turbopackHmr.onBuilt();\n            if (hmrUpdate != null) {\n                (0, _reporthmrlatency.default)(sendMessage, [\n                    ...hmrUpdate.updatedModules\n                ], hmrUpdate.startMsSinceEpoch, hmrUpdate.endMsSinceEpoch, // suppress the `client-hmr-latency` event if the update was a no-op:\n                hmrUpdate.hasUpdates);\n            }\n            _nextdevtools.dispatcher.onBuildOk();\n        } else {\n            tryApplyUpdatesWebpack(sendMessage);\n        }\n    }\n    switch(message.type){\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST:\n            {\n                if (process.env.__NEXT_DEV_INDICATOR) {\n                    staticIndicatorState.appIsrManifest = message.data;\n                    // Handle the initial static indicator status on receiving the ISR\n                    // manifest. Navigation is handled in an effect inside HotReload for\n                    // pathname changes as we'll receive the updated manifest before\n                    // usePathname triggers for a new value.\n                    const isStatic = staticIndicatorState.pathname ? message.data[staticIndicatorState.pathname] : undefined;\n                    _nextdevtools.dispatcher.onStaticIndicator(isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic');\n                }\n                break;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.BUILDING:\n            {\n                _nextdevtools.dispatcher.buildingIndicatorShow();\n                if (process.env.TURBOPACK) {\n                    turbopackHmr.onBuilding();\n                } else {\n                    webpackStartMsSinceEpoch = Date.now();\n                    setPendingHotUpdateWebpack();\n                    console.log('[Fast Refresh] rebuilding');\n                }\n                break;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SYNC:\n            {\n                _nextdevtools.dispatcher.buildingIndicatorHide();\n                if (message.hash) {\n                    handleAvailableHash(message.hash);\n                }\n                const { errors, warnings } = message;\n                // Is undefined when it's a 'built' event\n                if ('versionInfo' in message) _nextdevtools.dispatcher.onVersionInfo(message.versionInfo);\n                if ('debug' in message && message.debug) _nextdevtools.dispatcher.onDebugInfo(message.debug);\n                if ('devIndicator' in message) _nextdevtools.dispatcher.onDevIndicator(message.devIndicator);\n                if ('devToolsConfig' in message) _nextdevtools.dispatcher.onDevToolsConfig(message.devToolsConfig);\n                const hasErrors = Boolean(errors && errors.length);\n                // Compilation with errors (e.g. syntax error or missing modules).\n                if (hasErrors) {\n                    sendMessage(JSON.stringify({\n                        event: 'client-error',\n                        errorCount: errors.length,\n                        clientId: __nextDevClientId\n                    }));\n                    handleErrors(errors);\n                    return;\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    sendMessage(JSON.stringify({\n                        event: 'client-warning',\n                        warningCount: warnings.length,\n                        clientId: __nextDevClientId\n                    }));\n                    // Print warnings to the console.\n                    const formattedMessages = (0, _formatwebpackmessages.default)({\n                        warnings: warnings,\n                        errors: []\n                    });\n                    for(let i = 0; i < formattedMessages.warnings.length; i++){\n                        if (i === 5) {\n                            console.warn('There were more warnings in other files.\\n' + 'You can find a complete log in the terminal.');\n                            break;\n                        }\n                        console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));\n                    }\n                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n                }\n                sendMessage(JSON.stringify({\n                    event: 'client-success',\n                    clientId: __nextDevClientId\n                }));\n                if (message.type === _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n                    handleHotUpdate();\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED:\n            {\n                processTurbopackMessage({\n                    type: _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n                    data: {\n                        sessionId: message.data.sessionId\n                    }\n                });\n                break;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE:\n            {\n                turbopackHmr.onTurbopackMessage(message);\n                _nextdevtools.dispatcher.onBeforeRefresh();\n                processTurbopackMessage({\n                    type: _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n                    data: message.data\n                });\n                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n                    console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n                    performFullReload(null, sendMessage);\n                }\n                _nextdevtools.dispatcher.onRefresh();\n                break;\n            }\n        // TODO-APP: make server component change more granular\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:\n            {\n                turbopackHmr?.onServerComponentChanges();\n                sendMessage(JSON.stringify({\n                    event: 'server-component-reload-page',\n                    clientId: __nextDevClientId,\n                    hash: message.hash\n                }));\n                // Store the latest hash in a session cookie so that it's sent back to the\n                // server with any subsequent requests.\n                document.cookie = `${_approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`;\n                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || document.documentElement.id === '__next_error__') {\n                    if (reloading) return;\n                    reloading = true;\n                    return window.location.reload();\n                }\n                (0, _react.startTransition)(()=>{\n                    _approuterinstance.publicAppRouterInstance.hmrRefresh();\n                    _nextdevtools.dispatcher.onRefresh();\n                });\n                if (process.env.__NEXT_TEST_MODE) {\n                    if (self.__NEXT_HMR_CB) {\n                        self.__NEXT_HMR_CB();\n                        self.__NEXT_HMR_CB = null;\n                    }\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE:\n            {\n                turbopackHmr?.onReloadPage();\n                sendMessage(JSON.stringify({\n                    event: 'client-reload-page',\n                    clientId: __nextDevClientId\n                }));\n                if (reloading) return;\n                reloading = true;\n                return window.location.reload();\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE:\n            {\n                turbopackHmr?.onPageAddRemove();\n                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n                return _approuterinstance.publicAppRouterInstance.hmrRefresh();\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR:\n            {\n                const { errorJSON } = message;\n                if (errorJSON) {\n                    const errorObject = JSON.parse(errorJSON);\n                    const error = Object.defineProperty(new Error(errorObject.message), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    error.stack = errorObject.stack;\n                    handleErrors([\n                        error\n                    ]);\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:\n            {\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG:\n            {\n                _nextdevtools.dispatcher.onDevToolsConfig(message.data);\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK:\n            {\n                const { requestId, chunk } = message;\n                const { writer } = (0, _debugchannel.getOrCreateDebugChannelReadableWriterPair)(requestId);\n                if (chunk) {\n                    writer.ready.then(()=>writer.write(chunk)).catch(console.error);\n                } else {\n                    // A null chunk signals that no more chunks will be sent, which allows\n                    // us to close the writer.\n                    // TODO: Revisit this cleanup logic when we integrate the return channel\n                    // that keeps the connection open to be able to lazily retrieve debug\n                    // objects.\n                    writer.ready.then(()=>writer.close()).catch(console.error);\n                }\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE:\n            {\n                const errorState = (0, _nextdevtools.getSerializedOverlayState)();\n                const response = {\n                    event: _hotreloadertypes.HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n                    requestId: message.requestId,\n                    errorState,\n                    url: window.location.href\n                };\n                sendMessage(JSON.stringify(response));\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA:\n            {\n                const segmentTrieData = (0, _nextdevtools.getSegmentTrieData)();\n                const response = {\n                    event: _hotreloadertypes.HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n                    requestId: message.requestId,\n                    segmentTrieData,\n                    url: window.location.href\n                };\n                sendMessage(JSON.stringify(response));\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR:\n            {\n                _nextdevtools.dispatcher.onCacheIndicator(message.state);\n                return;\n            }\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n        case _hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n            break;\n        default:\n            {\n                message;\n            }\n    }\n}\nfunction HotReload({ children, globalError, webSocket, staticIndicatorState }) {\n    (0, _useerrorhandler.useErrorHandler)(_nextdevtools.dispatcher.onUnhandledError, _nextdevtools.dispatcher.onUnhandledRejection);\n    (0, _websocket.useWebSocketPing)(webSocket);\n    // We don't want access of the pathname for the dev tools to trigger a dynamic\n    // access (as the dev overlay will never be present in production).\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    if (process.env.__NEXT_DEV_INDICATOR) {\n        // this conditional is only for dead-code elimination which\n        // isn't a runtime conditional only build-time so ignore hooks rule\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            if (!staticIndicatorState) {\n                throw Object.defineProperty(new _invarianterror.InvariantError('Expected staticIndicatorState to be defined in dev mode.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E786\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            staticIndicatorState.pathname = pathname;\n            if (staticIndicatorState.appIsrManifest) {\n                const isStatic = pathname ? staticIndicatorState.appIsrManifest[pathname] : undefined;\n                _nextdevtools.dispatcher.onStaticIndicator(isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic');\n            }\n        }, [\n            pathname,\n            staticIndicatorState\n        ]);\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {\n        globalError: globalError,\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_replayssronlyerrors.ReplaySsrOnlyErrors, {\n                onBlockingError: _nextdevtools.dispatcher.openErrorOverlay\n            }),\n            children\n        ]\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=hot-reloader-app.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/app-router.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createEmptyCacheNode: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEmptyCacheNode: function() {\n        return createEmptyCacheNode;\n    },\n    default: function() {\n        return AppRouter;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _approutercontextsharedruntime = require(\"../../shared/lib/app-router-context.shared-runtime\");\nconst _routerreducertypes = require(\"./router-reducer/router-reducer-types\");\nconst _createhreffromurl = require(\"./router-reducer/create-href-from-url\");\nconst _hooksclientcontextsharedruntime = require(\"../../shared/lib/hooks-client-context.shared-runtime\");\nconst _useactionqueue = require(\"./use-action-queue\");\nconst _approuterannouncer = require(\"./app-router-announcer\");\nconst _redirectboundary = require(\"./redirect-boundary\");\nconst _findheadincache = require(\"./router-reducer/reducers/find-head-in-cache\");\nconst _unresolvedthenable = require(\"./unresolved-thenable\");\nconst _removebasepath = require(\"../remove-base-path\");\nconst _hasbasepath = require(\"../has-base-path\");\nconst _computechangedpath = require(\"./router-reducer/compute-changed-path\");\nconst _navfailurehandler = require(\"./nav-failure-handler\");\nconst _approuterinstance = require(\"./app-router-instance\");\nconst _redirect = require(\"./redirect\");\nconst _redirecterror = require(\"./redirect-error\");\nconst _links = require(\"./links\");\nconst _rooterrorboundary = /*#__PURE__*/ _interop_require_default._(require(\"./errors/root-error-boundary\"));\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(require(\"./builtin/global-error\"));\nconst _boundarycomponents = require(\"../../lib/framework/boundary-components\");\nconst globalMutable = {};\nfunction HistoryUpdater({ appRouterState }) {\n    (0, _react.useInsertionEffect)(()=>{\n        if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n            // clear pending URL as navigation is no longer\n            // in flight\n            window.next.__pendingUrl = undefined;\n        }\n        const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState;\n        const appHistoryState = {\n            tree,\n            renderedSearch\n        };\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        (0, _links.pingVisibleLinks)(appRouterState.nextUrl, appRouterState.tree);\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\nfunction createEmptyCacheNode() {\n    return {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1\n    };\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState?.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head({ headCacheNode }) {\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n/**\n * The global router that wraps the application components.\n */ function Router({ actionQueue, globalError, webSocket, staticIndicatorState }) {\n    const state = (0, _useactionqueue.useActionQueue)(actionQueue);\n    const { canonicalUrl } = state;\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl, typeof window === 'undefined' ? 'http://n' : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    if (process.env.NODE_ENV !== 'production') {\n        const { cache, tree } = state;\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: _approuterinstance.publicAppRouterInstance,\n                cache,\n                tree\n            };\n        }, [\n            cache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            if (!event.persisted || !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, []);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                // TODO: This should access the router methods directly, rather than\n                // go through the public interface.\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    _approuterinstance.publicAppRouterInstance.push(url, {});\n                } else {\n                    _approuterinstance.publicAppRouterInstance.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, []);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = state;\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location = window.location;\n            if (pushRef.pendingPush) {\n                location.assign(canonicalUrl);\n            } else {\n                location.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        // NOTE: This is intentionally using `throw` instead of `use` because we're\n        // inside an externally mutable condition (pushRef.mpaNavigation), which\n        // violates the rules of hooks.\n        throw _unresolvedthenable.unresolvedThenable;\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            const href = window.location.href;\n            const appHistoryState = window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url ?? href, href),\n                    historyState: appHistoryState\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, []);\n    const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state;\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    // Create instrumented promises for navigation hooks (dev-only)\n    // These are specially instrumented promises to show in the Suspense DevTools\n    // Promises are cached outside of render to survive suspense retries.\n    let instrumentedNavigationPromises = null;\n    if (process.env.NODE_ENV !== 'production') {\n        const { createRootNavigationPromises } = require('./navigation-devtools');\n        instrumentedNavigationPromises = createRootNavigationPromises(tree, pathname, searchParams, pathParams);\n    }\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            parentParams: {},\n            // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n            // It represents the root of the app.\n            debugNameContext: '/',\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            // Root segment is always active\n            isActive: true\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            tree,\n            focusAndScrollRef,\n            nextUrl,\n            previousNextUrl\n        };\n    }, [\n        tree,\n        focusAndScrollRef,\n        nextUrl,\n        previousNextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        }, // Necessary for PPR: omit search params from the key to match prerendered keys\n        typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {\n                children: cache.rsc\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (typeof window !== 'undefined') {\n            const { DevRootHTTPAccessFallbackBoundary } = require('./dev-root-http-access-fallback-boundary');\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = require('../dev/hot-reloader/app/hot-reloader-app').default;\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            globalError: globalError,\n            webSocket: webSocket,\n            staticIndicatorState: staticIndicatorState,\n            children: content\n        });\n    } else {\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n            errorComponent: globalError[0],\n            errorStyles: globalError[1],\n            children: content\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: state\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.NavigationPromisesContext.Provider, {\n                value: instrumentedNavigationPromises,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                    value: pathParams,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                        value: pathname,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                            value: searchParams,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                                value: globalLayoutRouterContext,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                    value: _approuterinstance.publicAppRouterInstance,\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                        value: layoutRouterContext,\n                                        children: content\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\nfunction AppRouter({ actionQueue, globalErrorState, webSocket, staticIndicatorState }) {\n    (0, _navfailurehandler.useNavFailureHandler)();\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n        actionQueue: actionQueue,\n        globalError: globalErrorState,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    // At the very top level, use the default GlobalError component as the final fallback.\n    // When the app router itself fails, which means the framework itself fails, we show the default error.\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n        errorComponent: _globalerror.default,\n        children: router\n    });\n}\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId = process.env.NEXT_DEPLOYMENT_ID ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}` : '';\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: `${href}${dplId}`,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-router.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11262, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"serverPatchReducer\", {\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n});\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _applyrouterstatepatchtotree = require(\"../apply-router-state-patch-to-tree\");\nconst _isnavigatingtonewrootlayout = require(\"../is-navigating-to-new-root-layout\");\nconst _navigatereducer = require(\"./navigate-reducer\");\nconst _applyflightdata = require(\"../apply-flight-data\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _approuter = require(\"../../app-router\");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse, navigatedAt } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof serverResponse === 'string') {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, serverResponse, state.pushRef.pendingPush);\n    }\n    const { flightData, canonicalUrl, renderedSearch } = serverResponse;\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const normalizedFlightData of flightData){\n        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(// TODO-APP: remove ''\n        [\n            '',\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n        // the entire page to reload.\n        if (newTree === null) {\n            return state;\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        mutable.canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl);\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n        mutable.patchedTree = newTree;\n        mutable.renderedSearch = renderedSearch;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=server-patch-reducer.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,mBAAmB,KAAK,EAAE,MAAM;IACrC,MAAM,EAAE,cAAc,EAAE,WAAW,EAAE,GAAG;IACxC,MAAM,UAAU,CAAC;IACjB,QAAQ,0BAA0B,GAAG;IACrC,4DAA4D;IAC5D,IAAI,OAAO,mBAAmB,UAAU;QACpC,OAAO,CAAC,GAAG,iBAAiB,iBAAiB,EAAE,OAAO,SAAS,gBAAgB,MAAM,OAAO,CAAC,WAAW;IAC5G;IACA,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,cAAc,EAAE,GAAG;IACrD,IAAI,cAAc,MAAM,IAAI;IAC5B,IAAI,eAAe,MAAM,KAAK;IAC9B,KAAK,MAAM,wBAAwB,WAAW;QAC1C,MAAM,EAAE,aAAa,iBAAiB,EAAE,MAAM,SAAS,EAAE,GAAG;QAC5D,MAAM,UAAU,CAAC,GAAG,6BAA6B,2BAA2B,EAC5E;YACI;eACG;SACN,EAAE,aAAa,WAAW,MAAM,YAAY;QAC7C,kIAAkI;QAClI,8GAA8G;QAC9G,oIAAoI;QACpI,mIAAmI;QACnI,6BAA6B;QAC7B,IAAI,YAAY,MAAM;YAClB,OAAO;QACX;QACA,IAAI,CAAC,GAAG,6BAA6B,2BAA2B,EAAE,aAAa,UAAU;YACrF,OAAO,CAAC,GAAG,iBAAiB,iBAAiB,EAAE,OAAO,SAAS,MAAM,YAAY,EAAE,MAAM,OAAO,CAAC,WAAW;QAChH;QACA,QAAQ,YAAY,GAAG,CAAC,GAAG,mBAAmB,iBAAiB,EAAE;QACjE,MAAM,QAAQ,CAAC,GAAG,WAAW,oBAAoB;QACjD,CAAC,GAAG,iBAAiB,eAAe,EAAE,aAAa,cAAc,OAAO;QACxE,QAAQ,WAAW,GAAG;QACtB,QAAQ,cAAc,GAAG;QACzB,QAAQ,KAAK,GAAG;QAChB,eAAe;QACf,cAAc;IAClB;IACA,OAAO,CAAC,GAAG,eAAe,aAAa,EAAE,OAAO;AACpD;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 11328, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"restoreReducer\", {\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n});\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _computechangedpath = require(\"../compute-changed-path\");\nconst _pprnavigations = require(\"../ppr-navigations\");\nfunction restoreReducer(state, action) {\n    const { url, historyState } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    let treeToRestore;\n    let renderedSearch;\n    if (historyState) {\n        treeToRestore = historyState.tree;\n        renderedSearch = historyState.renderedSearch;\n    } else {\n        treeToRestore = state.tree;\n        renderedSearch = state.renderedSearch;\n    }\n    const oldCache = state.cache;\n    const newCache = process.env.__NEXT_PPR ? // data for any segment whose dynamic data was already received. This\n    // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    (0, _pprnavigations.updateCacheNodeOnPopstateRestoration)(oldCache, treeToRestore) : oldCache;\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        renderedSearch,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore) ?? url.pathname,\n        previousNextUrl: null,\n        debugInfo: null\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=restore-reducer.js.map"],"names":[],"mappings":"AAgCqB;AAhCrB;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,eAAe,KAAK,EAAE,MAAM;IACjC,MAAM,EAAE,GAAG,EAAE,YAAY,EAAE,GAAG;IAC9B,MAAM,OAAO,CAAC,GAAG,mBAAmB,iBAAiB,EAAE;IACvD,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAI;IACJ,IAAI;IACJ,IAAI,cAAc;QACd,gBAAgB,aAAa,IAAI;QACjC,iBAAiB,aAAa,cAAc;IAChD,OAAO;QACH,gBAAgB,MAAM,IAAI;QAC1B,iBAAiB,MAAM,cAAc;IACzC;IACA,MAAM,WAAW,MAAM,KAAK;IAC5B,MAAM,WAAW,sCACjB,2DAA2D;IAC3D,2BAA2B;IAC3B,0BAAqF;IACrF,OAAO;QACH,oBAAoB;QACpB,cAAc;QACd;QACA,SAAS;YACL,aAAa;YACb,eAAe;YACf,6FAA6F;YAC7F,4BAA4B;QAChC;QACA,mBAAmB,MAAM,iBAAiB;QAC1C,OAAO;QACP,wBAAwB;QACxB,MAAM;QACN,SAAS,CAAC,GAAG,oBAAoB,gCAAgC,EAAE,kBAAkB,IAAI,QAAQ;QACjG,iBAAiB;QACjB,WAAW;IACf;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 11394, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"handleSegmentMismatch\", {\n    enumerable: true,\n    get: function() {\n        return handleSegmentMismatch;\n    }\n});\nconst _navigatereducer = require(\"./reducers/navigate-reducer\");\nfunction handleSegmentMismatch(state, action, treePatch) {\n    if (process.env.NODE_ENV === 'development') {\n        console.warn('Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' + 'Reason: Segment mismatch\\n' + `Last Action: ${action.type}\\n\\n` + `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` + `Tree Patch Payload: ${JSON.stringify(treePatch)}`);\n    }\n    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=handle-segment-mismatch.js.map"],"names":[],"mappings":"AAYQ;AAZR;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,yBAAyB;IACpD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,sBAAsB,KAAK,EAAE,MAAM,EAAE,SAAS;IACnD,wCAA4C;QACxC,QAAQ,IAAI,CAAC,sJAAsJ,+BAA+B,CAAC,aAAa,EAAE,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,KAAK,SAAS,CAAC,MAAM,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,oBAAoB,EAAE,KAAK,SAAS,CAAC,YAAY;IAChV;IACA,OAAO,CAAC,GAAG,iBAAiB,iBAAiB,EAAE,OAAO,CAAC,GAAG,MAAM,YAAY,EAAE;AAClF;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,mDAAmD","ignoreList":[0]}},
    {"offset": {"line": 11423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", {\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n});\nconst _interceptionroutes = require(\"../../../../shared/lib/router/utils/interception-routes\");\nfunction hasInterceptionRouteInCurrentTree([segment, parallelRoutes]) {\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === 'di(..)(..)' || segment[2] === 'ci(..)(..)' || segment[2] === 'di(.)' || segment[2] === 'ci(.)' || segment[2] === 'di(..)' || segment[2] === 'ci(..)' || segment[2] === 'di(...)' || segment[2] === 'ci(...)')) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=has-interception-route-in-current-tree.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,qCAAqC;IAChE,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,kCAAkC,CAAC,SAAS,eAAe;IAChE,wGAAwG;IACxG,IAAI,MAAM,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,KAAK,gBAAgB,OAAO,CAAC,EAAE,KAAK,gBAAgB,OAAO,CAAC,EAAE,KAAK,WAAW,OAAO,CAAC,EAAE,KAAK,WAAW,OAAO,CAAC,EAAE,KAAK,YAAY,OAAO,CAAC,EAAE,KAAK,YAAY,OAAO,CAAC,EAAE,KAAK,aAAa,OAAO,CAAC,EAAE,KAAK,SAAS,GAAG;QAC1P,OAAO;IACX;IACA,oEAAoE;IACpE,IAAI,OAAO,YAAY,YAAY,CAAC,GAAG,oBAAoB,0BAA0B,EAAE,UAAU;QAC7F,OAAO;IACX;IACA,+CAA+C;IAC/C,IAAI,gBAAgB;QAChB,IAAI,MAAM,OAAO,eAAe;YAC5B,IAAI,kCAAkC,cAAc,CAAC,IAAI,GAAG;gBACxD,OAAO;YACX;QACJ;IACJ;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,kEAAkE","ignoreList":[0]}},
    {"offset": {"line": 11463, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"refreshReducer\", {\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n});\nconst _fetchserverresponse = require(\"../fetch-server-response\");\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _applyrouterstatepatchtotree = require(\"../apply-router-state-patch-to-tree\");\nconst _isnavigatingtonewrootlayout = require(\"../is-navigating-to-new-root-layout\");\nconst _navigatereducer = require(\"./navigate-reducer\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _filllazyitemstillleafwithhead = require(\"../fill-lazy-items-till-leaf-with-head\");\nconst _approuter = require(\"../../app-router\");\nconst _handlesegmentmismatch = require(\"../handle-segment-mismatch\");\nconst _hasinterceptionrouteincurrenttree = require(\"./has-interception-route-in-current-tree\");\nconst _refetchinactiveparallelsegments = require(\"../refetch-inactive-parallel-segments\");\nconst _cache = require(\"../../segment-cache/cache\");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null\n    });\n    const navigatedAt = Date.now();\n    return cache.lazyData.then(async (result)=>{\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof result === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, result, state.pushRef.pendingPush);\n        }\n        const { flightData, canonicalUrl, renderedSearch } = result;\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(// TODO-APP: remove ''\n            [\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            mutable.canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl);\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[0];\n                const loading = cacheNodeSeedData[2];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = loading;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n                undefined, treePatch, cacheNodeSeedData, head);\n                (0, _cache.revalidateEntireCache)(state.nextUrl, newTree);\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                navigatedAt,\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            mutable.renderedSearch = renderedSearch;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=refresh-reducer.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11568, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hmrRefreshReducer\", {\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n});\nconst _fetchserverresponse = require(\"../fetch-server-response\");\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _applyrouterstatepatchtotree = require(\"../apply-router-state-patch-to-tree\");\nconst _isnavigatingtonewrootlayout = require(\"../is-navigating-to-new-root-layout\");\nconst _navigatereducer = require(\"./navigate-reducer\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _applyflightdata = require(\"../apply-flight-data\");\nconst _approuter = require(\"../../app-router\");\nconst _handlesegmentmismatch = require(\"../handle-segment-mismatch\");\nconst _hasinterceptionrouteincurrenttree = require(\"./has-interception-route-in-current-tree\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    const navigatedAt = Date.now();\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((result)=>{\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof result === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, result, state.pushRef.pendingPush);\n        }\n        const { flightData, canonicalUrl, renderedSearch } = result;\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(// TODO-APP: remove ''\n            [\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.renderedSearch = renderedSearch;\n            mutable.canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl);\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer = process.env.NODE_ENV === 'production' ? hmrRefreshReducerNoop : hmrRefreshReducerImpl;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=hmr-refresh-reducer.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11666, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/assign-location.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"assignLocation\", {\n    enumerable: true,\n    get: function() {\n        return assignLocation;\n    }\n});\nconst _addbasepath = require(\"./add-base-path\");\nfunction assignLocation(location, url) {\n    if (location.startsWith('.')) {\n        const urlBase = url.origin + url.pathname;\n        return new URL(// In order for a relative path to be added to the current url correctly, the current url must end with a slash\n        // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n        // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n        (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location);\n    }\n    return new URL((0, _addbasepath.addBasePath)(location), url.href);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=assign-location.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAC7C,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,SAAS,eAAe,QAAQ,EAAE,GAAG;IACjC,IAAI,SAAS,UAAU,CAAC,MAAM;QAC1B,MAAM,UAAU,IAAI,MAAM,GAAG,IAAI,QAAQ;QACzC,OAAO,IAAI,IACX,6FAA6F;QAC7F,qGAAqG;QACrG,CAAC,QAAQ,QAAQ,CAAC,OAAO,UAAU,UAAU,GAAG,IAAI;IACxD;IACA,OAAO,IAAI,IAAI,CAAC,GAAG,aAAa,WAAW,EAAE,WAAW,IAAI,IAAI;AACpE;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 11696, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"serverActionReducer\", {\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n});\nconst _appcallserver = require(\"../../../app-call-server\");\nconst _appfindsourcemapurl = require(\"../../../app-find-source-map-url\");\nconst _approuterheaders = require(\"../../app-router-headers\");\nconst _unrecognizedactionerror = require(\"../../unrecognized-action-error\");\nconst _client = require(\"react-server-dom-webpack/client\");\nconst _assignlocation = require(\"../../../assign-location\");\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _navigatereducer = require(\"./navigate-reducer\");\nconst _applyrouterstatepatchtotree = require(\"../apply-router-state-patch-to-tree\");\nconst _isnavigatingtonewrootlayout = require(\"../is-navigating-to-new-root-layout\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _filllazyitemstillleafwithhead = require(\"../fill-lazy-items-till-leaf-with-head\");\nconst _approuter = require(\"../../app-router\");\nconst _hasinterceptionrouteincurrenttree = require(\"./has-interception-route-in-current-tree\");\nconst _handlesegmentmismatch = require(\"../handle-segment-mismatch\");\nconst _refetchinactiveparallelsegments = require(\"../refetch-inactive-parallel-segments\");\nconst _flightdatahelpers = require(\"../../../flight-data-helpers\");\nconst _redirect = require(\"../../redirect\");\nconst _redirecterror = require(\"../../redirect-error\");\nconst _removebasepath = require(\"../../../remove-base-path\");\nconst _hasbasepath = require(\"../../../has-base-path\");\nconst _serverreferenceinfo = require(\"../../../../shared/lib/server-reference-info\");\nconst _cache = require(\"../../segment-cache/cache\");\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL) {\n    createDebugChannel = require('../../../dev/debug-channel').createDebugChannel;\n}\nasync function fetchServerAction(state, nextUrl, { actionId, actionArgs }) {\n    const temporaryReferences = (0, _client.createTemporaryReferenceSet)();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await (0, _client.encodeReply)(usedArgs, {\n        temporaryReferences\n    });\n    const headers = {\n        Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n        [_approuterheaders.ACTION_HEADER]: actionId,\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree)\n    };\n    if (process.env.NEXT_DEPLOYMENT_ID) {\n        headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID;\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const res = await fetch(state.canonicalUrl, {\n        method: 'POST',\n        headers,\n        body\n    });\n    // Handle server actions that the server didn't recognize.\n    const unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);\n    if (unrecognizedActionHeader === '1') {\n        throw Object.defineProperty(new _unrecognizedactionerror.UnrecognizedActionError(`Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`), \"__NEXT_ERROR_CODE\", {\n            value: \"E715\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location, _redirectType] = redirectHeader?.split(';') || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = NO_REVALIDATED_PARTS;\n    }\n    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    const isRscResponse = !!(contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));\n    // Handle invalid server action responses.\n    // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n    // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n    if (!isRscResponse && !redirectLocation) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const message = res.status >= 400 && contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let actionResult;\n    let actionFlightData;\n    if (isRscResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences,\n            debugChannel: createDebugChannel && createDebugChannel(headers)\n        });\n        // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n        actionResult = redirectLocation ? undefined : response.a;\n        actionFlightData = (0, _flightdatahelpers.normalizeFlightData)(response.f);\n    } else {\n        // An external redirect doesn't contain RSC data.\n        actionResult = undefined;\n        actionFlightData = undefined;\n    }\n    return {\n        actionResult,\n        actionFlightData,\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender\n    };\n}\nconst NO_REVALIDATED_PARTS = {\n    paths: [],\n    tag: false,\n    cookie: false\n};\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.previousNextUrl || state.nextUrl : null;\n    const navigatedAt = Date.now();\n    return fetchServerAction(state, nextUrl, action).then(async ({ actionResult, actionFlightData: flightData, redirectLocation, redirectType, revalidatedParts })=>{\n        let redirectHref;\n        // honor the redirect type instead of defaulting to push in case of server actions.\n        if (redirectLocation) {\n            if (redirectType === _redirecterror.RedirectType.replace) {\n                state.pushRef.pendingPush = false;\n                mutable.pendingPush = false;\n            } else {\n                state.pushRef.pendingPush = true;\n                mutable.pendingPush = true;\n            }\n            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = redirectHref;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === 'string') {\n            // Handle case when navigating to page in `pages` from `app`\n            resolve(actionResult);\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;\n        // Store whether this action triggered any revalidation\n        // The action queue will use this information to potentially\n        // trigger a refresh action if the action was discarded\n        // (ie, due to a navigation, before the action completed)\n        if (actionRevalidated) {\n            action.didRevalidate = true;\n        }\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('SERVER ACTION APPLY FAILED');\n                resolve(actionResult);\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(// TODO-APP: remove ''\n            [\n                ''\n            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);\n            if (newTree === null) {\n                resolve(actionResult);\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                resolve(actionResult);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);\n            }\n            // The server sent back RSC data for the server action, so we need to apply it to the cache.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[0];\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = cacheNodeSeedData[2];\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, // Existing cache is not passed in as server actions have to invalidate the entire cache.\n                undefined, treePatch, cacheNodeSeedData, head);\n                mutable.cache = cache;\n                (0, _cache.revalidateEntireCache)(state.nextUrl, newTree);\n                if (actionRevalidated) {\n                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                        navigatedAt,\n                        state,\n                        updatedTree: newTree,\n                        updatedCache: cache,\n                        includeNextUrl: Boolean(nextUrl),\n                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                    });\n                }\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        if (redirectLocation && redirectHref) {\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            const redirectError = (0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push);\n            redirectError.handled = true;\n            reject(redirectError);\n        } else {\n            resolve(actionResult);\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=server-action-reducer.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11974, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/router-reducer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"reducer\", {\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n});\nconst _routerreducertypes = require(\"./router-reducer-types\");\nconst _navigatereducer = require(\"./reducers/navigate-reducer\");\nconst _serverpatchreducer = require(\"./reducers/server-patch-reducer\");\nconst _restorereducer = require(\"./reducers/restore-reducer\");\nconst _refreshreducer = require(\"./reducers/refresh-reducer\");\nconst _hmrrefreshreducer = require(\"./reducers/hmr-refresh-reducer\");\nconst _serveractionreducer = require(\"./reducers/server-action-reducer\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_HMR_REFRESH:\n            {\n                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw Object.defineProperty(new Error('Unknown action'), \"__NEXT_ERROR_CODE\", {\n                value: \"E295\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer = typeof window === 'undefined' ? serverReducer : clientReducer;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=router-reducer.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,WAAW;IACtC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN;;CAEC,GAAG,SAAS,cAAc,KAAK,EAAE,MAAM;IACpC,OAAO,OAAO,IAAI;QACd,KAAK,oBAAoB,eAAe;YACpC;gBACI,OAAO,CAAC,GAAG,iBAAiB,eAAe,EAAE,OAAO;YACxD;QACJ,KAAK,oBAAoB,mBAAmB;YACxC;gBACI,OAAO,CAAC,GAAG,oBAAoB,kBAAkB,EAAE,OAAO;YAC9D;QACJ,KAAK,oBAAoB,cAAc;YACnC;gBACI,OAAO,CAAC,GAAG,gBAAgB,cAAc,EAAE,OAAO;YACtD;QACJ,KAAK,oBAAoB,cAAc;YACnC;gBACI,OAAO,CAAC,GAAG,gBAAgB,cAAc,EAAE,OAAO;YACtD;QACJ,KAAK,oBAAoB,kBAAkB;YACvC;gBACI,OAAO,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,OAAO;YAC5D;QACJ,KAAK,oBAAoB,oBAAoB;YACzC;gBACI,OAAO,CAAC,GAAG,qBAAqB,mBAAmB,EAAE,OAAO;YAChE;QACJ,+DAA+D;QAC/D;YACI,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,mBAAmB,qBAAqB;gBAC1E,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;IACR;AACJ;AACA,SAAS,cAAc,KAAK,EAAE,OAAO;IACjC,OAAO;AACX;AACA,MAAM,UAAU,OAAO,WAAW,cAAc,gBAAgB;AAEhE,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 12042, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/segment-cache/prefetch.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"prefetch\", {\n    enumerable: true,\n    get: function() {\n        return prefetch;\n    }\n});\nconst _approuterutils = require(\"../app-router-utils\");\nconst _cachekey = require(\"./cache-key\");\nconst _scheduler = require(\"./scheduler\");\nconst _types = require(\"./types\");\nfunction prefetch(href, nextUrl, treeAtTimeOfPrefetch, fetchStrategy, onInvalidate) {\n    const url = (0, _approuterutils.createPrefetchURL)(href);\n    if (url === null) {\n        // This href should not be prefetched.\n        return;\n    }\n    const cacheKey = (0, _cachekey.createCacheKey)(url.href, nextUrl);\n    (0, _scheduler.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, fetchStrategy, _types.PrefetchPriority.Default, onInvalidate);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=prefetch.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,YAAY;IACvC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,SAAS,IAAI,EAAE,OAAO,EAAE,oBAAoB,EAAE,aAAa,EAAE,YAAY;IAC9E,MAAM,MAAM,CAAC,GAAG,gBAAgB,iBAAiB,EAAE;IACnD,IAAI,QAAQ,MAAM;QACd,sCAAsC;QACtC;IACJ;IACA,MAAM,WAAW,CAAC,GAAG,UAAU,cAAc,EAAE,IAAI,IAAI,EAAE;IACzD,CAAC,GAAG,WAAW,oBAAoB,EAAE,UAAU,sBAAsB,eAAe,OAAO,gBAAgB,CAAC,OAAO,EAAE;AACzH;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 12075, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/app-router-instance.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createMutableActionQueue: null,\n    dispatchNavigateAction: null,\n    dispatchTraverseAction: null,\n    getCurrentAppRouterState: null,\n    publicAppRouterInstance: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMutableActionQueue: function() {\n        return createMutableActionQueue;\n    },\n    dispatchNavigateAction: function() {\n        return dispatchNavigateAction;\n    },\n    dispatchTraverseAction: function() {\n        return dispatchTraverseAction;\n    },\n    getCurrentAppRouterState: function() {\n        return getCurrentAppRouterState;\n    },\n    publicAppRouterInstance: function() {\n        return publicAppRouterInstance;\n    }\n});\nconst _routerreducertypes = require(\"./router-reducer/router-reducer-types\");\nconst _routerreducer = require(\"./router-reducer/router-reducer\");\nconst _react = require(\"react\");\nconst _isthenable = require(\"../../shared/lib/is-thenable\");\nconst _types = require(\"./segment-cache/types\");\nconst _prefetch = require(\"./segment-cache/prefetch\");\nconst _useactionqueue = require(\"./use-action-queue\");\nconst _addbasepath = require(\"../add-base-path\");\nconst _approuterutils = require(\"./app-router-utils\");\nconst _links = require(\"./links\");\nfunction runRemainingActions(actionQueue, setState) {\n    if (actionQueue.pending !== null) {\n        actionQueue.pending = actionQueue.pending.next;\n        if (actionQueue.pending !== null) {\n            runAction({\n                actionQueue,\n                action: actionQueue.pending,\n                setState\n            });\n        }\n    } else {\n        // Check for refresh when pending is already null\n        // This handles the case where a discarded server action completes\n        // after the navigation has already finished and the queue is empty\n        if (actionQueue.needsRefresh) {\n            actionQueue.needsRefresh = false;\n            actionQueue.dispatch({\n                type: _routerreducertypes.ACTION_REFRESH,\n                origin: window.location.origin\n            }, setState);\n        }\n    }\n}\nasync function runAction({ actionQueue, action, setState }) {\n    const prevState = actionQueue.state;\n    actionQueue.pending = action;\n    const payload = action.payload;\n    const actionResult = actionQueue.action(prevState, payload);\n    function handleResult(nextState) {\n        // if we discarded this action, the state should also be discarded\n        if (action.discarded) {\n            // Check if the discarded server action revalidated data\n            if (action.payload.type === _routerreducertypes.ACTION_SERVER_ACTION && action.payload.didRevalidate) {\n                // The server action was discarded but it revalidated data,\n                // mark that we need to refresh after all actions complete\n                actionQueue.needsRefresh = true;\n            }\n            // Still need to run remaining actions even for discarded actions\n            // to potentially trigger the refresh\n            runRemainingActions(actionQueue, setState);\n            return;\n        }\n        actionQueue.state = nextState;\n        runRemainingActions(actionQueue, setState);\n        action.resolve(nextState);\n    }\n    // if the action is a promise, set up a callback to resolve it\n    if ((0, _isthenable.isThenable)(actionResult)) {\n        actionResult.then(handleResult, (err)=>{\n            runRemainingActions(actionQueue, setState);\n            action.reject(err);\n        });\n    } else {\n        handleResult(actionResult);\n    }\n}\nfunction dispatchAction(actionQueue, payload, setState) {\n    let resolvers = {\n        resolve: setState,\n        reject: ()=>{}\n    };\n    // most of the action types are async with the exception of restore\n    // it's important that restore is handled quickly since it's fired on the popstate event\n    // and we don't want to add any delay on a back/forward nav\n    // this only creates a promise for the async actions\n    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {\n        // Create the promise and assign the resolvers to the object.\n        const deferredPromise = new Promise((resolve, reject)=>{\n            resolvers = {\n                resolve,\n                reject\n            };\n        });\n        (0, _react.startTransition)(()=>{\n            // we immediately notify React of the pending promise -- the resolver is attached to the action node\n            // and will be called when the associated action promise resolves\n            setState(deferredPromise);\n        });\n    }\n    const newAction = {\n        payload,\n        next: null,\n        resolve: resolvers.resolve,\n        reject: resolvers.reject\n    };\n    // Check if the queue is empty\n    if (actionQueue.pending === null) {\n        // The queue is empty, so add the action and start it immediately\n        // Mark this action as the last in the queue\n        actionQueue.last = newAction;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {\n        // Navigations (including back/forward) take priority over any pending actions.\n        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n        actionQueue.pending.discarded = true;\n        // The rest of the current queue should still execute after this navigation.\n        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n        newAction.next = actionQueue.pending.next;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else {\n        // The queue is not empty, so add the action to the end of the queue\n        // It will be started by runRemainingActions after the previous action finishes\n        if (actionQueue.last !== null) {\n            actionQueue.last.next = newAction;\n        }\n        actionQueue.last = newAction;\n    }\n}\nlet globalActionQueue = null;\nfunction createMutableActionQueue(initialState, instrumentationHooks) {\n    const actionQueue = {\n        state: initialState,\n        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),\n        action: async (state, action)=>{\n            const result = (0, _routerreducer.reducer)(state, action);\n            return result;\n        },\n        pending: null,\n        last: null,\n        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null\n    };\n    if (typeof window !== 'undefined') {\n        // The action queue is lazily created on hydration, but after that point\n        // it doesn't change. So we can store it in a global rather than pass\n        // it around everywhere via props/context.\n        if (globalActionQueue !== null) {\n            throw Object.defineProperty(new Error('Internal Next.js Error: createMutableActionQueue was called more ' + 'than once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E624\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        globalActionQueue = actionQueue;\n    }\n    return actionQueue;\n}\nfunction getCurrentAppRouterState() {\n    return globalActionQueue !== null ? globalActionQueue.state : null;\n}\nfunction getAppRouterActionQueue() {\n    if (globalActionQueue === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return globalActionQueue;\n}\nfunction getProfilingHookForOnNavigationStart() {\n    if (globalActionQueue !== null) {\n        return globalActionQueue.onRouterTransitionStart;\n    }\n    return null;\n}\nfunction dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {\n    // TODO: This stuff could just go into the reducer. Leaving as-is for now\n    // since we're about to rewrite all the router reducer stuff anyway.\n    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n        window.next.__pendingUrl = url;\n    }\n    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, navigateType);\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_NAVIGATE,\n        url,\n        isExternalUrl: (0, _approuterutils.isExternalURL)(url),\n        locationSearch: location.search,\n        shouldScroll,\n        navigateType\n    });\n}\nfunction dispatchTraverseAction(href, historyState) {\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, 'traverse');\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_RESTORE,\n        url: new URL(href),\n        historyState\n    });\n}\nconst publicAppRouterInstance = {\n    back: ()=>window.history.back(),\n    forward: ()=>window.history.forward(),\n    prefetch: // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href, options)=>{\n        const actionQueue = getAppRouterActionQueue();\n        const prefetchKind = options?.kind ?? _routerreducertypes.PrefetchKind.AUTO;\n        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n        // This will be possible when we update its API to not take a PrefetchKind.\n        let fetchStrategy;\n        switch(prefetchKind){\n            case _routerreducertypes.PrefetchKind.AUTO:\n                {\n                    // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                    break;\n                }\n            case _routerreducertypes.PrefetchKind.FULL:\n                {\n                    fetchStrategy = _types.FetchStrategy.Full;\n                    break;\n                }\n            case _routerreducertypes.PrefetchKind.TEMPORARY:\n                {\n                    // This concept doesn't exist in the segment cache implementation.\n                    return;\n                }\n            default:\n                {\n                    prefetchKind;\n                    // Despite typescript thinking that this can't happen,\n                    // we might get an unexpected value from user code.\n                    // We don't know what they want, but we know they want a prefetch,\n                    // so use the default.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                }\n        }\n        (0, _prefetch.prefetch)(href, actionQueue.state.nextUrl, actionQueue.state.tree, fetchStrategy, options?.onInvalidate ?? null);\n    },\n    replace: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null);\n        });\n    },\n    push: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'push', options?.scroll ?? true, null);\n        });\n    },\n    refresh: ()=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_REFRESH,\n                origin: window.location.origin\n            });\n        });\n    },\n    hmrRefresh: ()=>{\n        if (process.env.NODE_ENV !== 'development') {\n            throw Object.defineProperty(new Error('hmrRefresh can only be used in development mode. Please use refresh instead.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E485\",\n                enumerable: false,\n                configurable: true\n            });\n        } else {\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_HMR_REFRESH,\n                    origin: window.location.origin\n                });\n            });\n        }\n    }\n};\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n    window.next.router = publicAppRouterInstance;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-router-instance.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12400, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createInitialRouterState\", {\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n});\nconst _createhreffromurl = require(\"./create-href-from-url\");\nconst _filllazyitemstillleafwithhead = require(\"./fill-lazy-items-till-leaf-with-head\");\nconst _computechangedpath = require(\"./compute-changed-path\");\nconst _refetchinactiveparallelsegments = require(\"./refetch-inactive-parallel-segments\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nfunction createInitialRouterState({ navigatedAt, initialFlightData, initialCanonicalUrlParts, initialRenderedSearch, initialParallelRoutes, location }) {\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const rsc = initialSeedData?.[0];\n    const loading = initialSeedData?.[2] ?? null;\n    const cache = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: initialParallelRoutes,\n        loading,\n        navigatedAt\n    };\n    const canonicalUrl = // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, initialTree, initialSeedData, initialHead);\n    }\n    const initialState = {\n        tree: initialTree,\n        cache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        renderedSearch: initialRenderedSearch,\n        nextUrl: // the || operator is intentional, the pathname can be an empty string\n        ((0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || location?.pathname) ?? null,\n        previousNextUrl: null,\n        debugInfo: null\n    };\n    return initialState;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=create-initial-router-state.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,4BAA4B;IACvD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,yBAAyB,EAAE,WAAW,EAAE,iBAAiB,EAAE,wBAAwB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,QAAQ,EAAE;IAClJ,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAM,sBAAsB,yBAAyB,IAAI,CAAC;IAC1D,MAAM,uBAAuB,CAAC,GAAG,mBAAmB,0BAA0B,EAAE,iBAAiB,CAAC,EAAE;IACpG,MAAM,EAAE,MAAM,WAAW,EAAE,UAAU,eAAe,EAAE,MAAM,WAAW,EAAE,GAAG;IAC5E,gGAAgG;IAChG,gDAAgD;IAChD,MAAM,MAAM,iBAAiB,CAAC,EAAE;IAChC,MAAM,UAAU,iBAAiB,CAAC,EAAE,IAAI;IACxC,MAAM,QAAQ;QACV,UAAU;QACV;QACA,aAAa;QACb,MAAM;QACN,cAAc;QACd,oJAAoJ;QACpJ,gBAAgB;QAChB;QACA;IACJ;IACA,MAAM,eACN,kJAAkJ;IAClJ,WAAW,CAAC,GAAG,mBAAmB,iBAAiB,EAAE,YAAY;IACjE,CAAC,GAAG,iCAAiC,wCAAwC,EAAE,aAAa;IAC5F,yEAAyE;IACzE,IAAI,0BAA0B,QAAQ,sBAAsB,IAAI,KAAK,GAAG;QACpE,CAAC,GAAG,+BAA+B,6BAA6B,EAAE,aAAa,OAAO,WAAW,aAAa,iBAAiB;IACnI;IACA,MAAM,eAAe;QACjB,MAAM;QACN;QACA,SAAS;YACL,aAAa;YACb,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChF,4BAA4B;QAChC;QACA,mBAAmB;YACf,OAAO;YACP,gBAAgB;YAChB,cAAc;YACd,cAAc,EAAE;QACpB;QACA;QACA,gBAAgB;QAChB,SACA,CAAC,CAAC,GAAG,oBAAoB,gCAAgC,EAAE,gBAAgB,UAAU,QAAQ,KAAK;QAClG,iBAAiB;QACjB,WAAW;IACf;IACA,OAAO;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,uDAAuD","ignoreList":[0]}},
    {"offset": {"line": 12478, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-link-gc.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"linkGc\", {\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n});\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (process.env.NODE_ENV !== 'production') {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            const link = node;\n                            if (link.dataset.precedence?.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            if (otherLink.dataset.precedence?.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector(`link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`);\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-link-gc.js.map"],"names":[],"mappings":"AAYQ;AAZR;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,UAAU;IACrC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS;IACL,yEAAyE;IACzE,wCAA2C;QACvC,MAAM,WAAW,CAAC;YACd,KAAK,MAAM,YAAY,aAAa;gBAChC,IAAI,SAAS,IAAI,KAAK,aAAa;oBAC/B,KAAK,MAAM,QAAQ,SAAS,UAAU,CAAC;wBACnC,IAAI,aAAa,QAAQ,KAAK,OAAO,KAAK,QAAQ;4BAC9C,MAAM,OAAO;4BACb,IAAI,KAAK,OAAO,CAAC,UAAU,EAAE,WAAW,SAAS;gCAC7C,MAAM,OAAO,KAAK,YAAY,CAAC;gCAC/B,IAAI,MAAM;oCACN,MAAM,CAAC,UAAU,QAAQ,GAAG,KAAK,KAAK,CAAC,OAAO;oCAC9C,IAAI,SAAS;wCACT,MAAM,gBAAgB,OAAO,QAAQ,CAAC,MAAM;wCAC5C,MAAM,WAAW;+CACV,SAAS,gBAAgB,CAAC,iBAAiB,WAAW;4CACzD,kEAAkE;4CAClE,qDAAqD;+CAClD,SAAS,gBAAgB,CAAC,iBAAiB,CAAC,SAAS,UAAU,CAAC,iBAAiB,SAAS,KAAK,CAAC,cAAc,MAAM,IAAI,gBAAgB,QAAQ,IAAI;yCAC1J;wCACD,KAAK,MAAM,aAAa,SAAS;4CAC7B,IAAI,UAAU,OAAO,CAAC,UAAU,EAAE,WAAW,SAAS;gDAClD,MAAM,YAAY,UAAU,YAAY,CAAC;gDACzC,IAAI,WAAW;oDACX,MAAM,GAAG,aAAa,GAAG,UAAU,KAAK,CAAC,OAAO;oDAChD,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,SAAS;wDAC3C,oDAAoD;wDACpD,mDAAmD;wDACnD,oDAAoD;wDACpD,mDAAmD;wDACnD,WAAW;4DACP,UAAU,MAAM;wDACpB,GAAG;wDACH,MAAM,cAAc,SAAS,aAAa,CAAC,CAAC,sCAAsC,EAAE,UAAU,EAAE,CAAC;wDACjG,IAAI,aAAa;4DACb,YAAY,MAAM;wDACtB;oDACJ;gDACJ;4CACJ;wCACJ;oCACJ;gCACJ;4BACJ;wBACJ;oBACJ;gBACJ;YACJ;QACJ;QACA,8DAA8D;QAC9D,MAAM,WAAW,IAAI,iBAAiB;QACtC,SAAS,OAAO,CAAC,SAAS,IAAI,EAAE;YAC5B,WAAW;QACf;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 12557, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hydrate\", {\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nrequire(\"./app-globals\");\nconst _client = /*#__PURE__*/ _interop_require_default._(require(\"react-dom/client\"));\nconst _react = /*#__PURE__*/ _interop_require_default._(require(\"react\"));\nconst _client1 = require(\"react-server-dom-webpack/client\");\nconst _headmanagercontextsharedruntime = require(\"../shared/lib/head-manager-context.shared-runtime\");\nconst _onrecoverableerror = require(\"./react-client-callbacks/on-recoverable-error\");\nconst _errorboundarycallbacks = require(\"./react-client-callbacks/error-boundary-callbacks\");\nconst _appcallserver = require(\"./app-call-server\");\nconst _appfindsourcemapurl = require(\"./app-find-source-map-url\");\nconst _approuterinstance = require(\"./components/app-router-instance\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(require(\"./components/app-router\"));\nconst _createinitialrouterstate = require(\"./components/router-reducer/create-initial-router-state\");\nconst _approutercontextsharedruntime = require(\"../shared/lib/app-router-context.shared-runtime\");\nconst _appbuildid = require(\"./app-build-id\");\nconst _flightdatahelpers = require(\"./flight-data-helpers\");\n/// <reference types=\"react-dom/experimental\" />\nconst createFromReadableStream = _client1.createFromReadableStream;\nconst createFromFetch = _client1.createFromFetch;\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.length = 0;\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nif (process.env.NODE_ENV !== 'production') {\n    // @ts-expect-error\n    readable.name = 'hydration';\n}\nlet debugChannel;\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL && typeof window !== 'undefined') {\n    const { createDebugChannel } = require('./dev/debug-channel');\n    debugChannel = createDebugChannel(undefined);\n}\nconst clientResumeFetch = // @ts-expect-error\nwindow.__NEXT_CLIENT_RESUME;\nlet initialServerResponse;\nif (clientResumeFetch) {\n    initialServerResponse = Promise.resolve(createFromFetch(clientResumeFetch, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel\n    })).then(async (fallbackInitialRSCPayload)=>(0, _flightdatahelpers.createInitialRSCPayloadFromFallbackPrerender)(await clientResumeFetch, fallbackInitialRSCPayload));\n} else {\n    initialServerResponse = createFromReadableStream(readable, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel,\n        // @ts-expect-error This is not yet part of the React types\n        startTime: 0\n    });\n}\nfunction ServerRoot({ initialRSCPayload, actionQueue, webSocket, staticIndicatorState }) {\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorState: initialRSCPayload.G,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    if (process.env.NODE_ENV === 'development' && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\nconst StrictModeIfEnabled = process.env.__NEXT_STRICT_MODE_APP ? _react.default.StrictMode : _react.default.Fragment;\nfunction Root({ children }) {\n    if (process.env.__NEXT_TEST_MODE) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        _react.default.useEffect(()=>{\n            window.__NEXT_HYDRATED = true;\n            window.__NEXT_HYDRATED_AT = performance.now();\n            window.__NEXT_HYDRATED_CB?.();\n        }, []);\n    }\n    return children;\n}\nfunction onDefaultTransitionIndicator() {\n    // TODO: Compose default with user-configureable (e.g. nprogress)\n    // TODO: Use React's default once we figure out hanging indicators: https://codesandbox.io/p/sandbox/charming-moon-hktkp6?file=%2Fsrc%2Findex.js%3A106%2C30\n    return ()=>{};\n}\nconst reactRootOptions = {\n    onDefaultTransitionIndicator: onDefaultTransitionIndicator,\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nasync function hydrate(instrumentationHooks, assetPrefix) {\n    let staticIndicatorState;\n    let webSocket;\n    if (process.env.NODE_ENV !== 'production') {\n        const { createWebSocket } = require('./dev/hot-reloader/app/web-socket');\n        staticIndicatorState = {\n            pathname: null,\n            appIsrManifest: null\n        };\n        webSocket = createWebSocket(assetPrefix, staticIndicatorState);\n    }\n    const initialRSCPayload = await initialServerResponse;\n    // setAppBuildId should be called only once, during JS initialization\n    // and before any components have hydrated.\n    (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n    const initialTimestamp = Date.now();\n    const actionQueue = (0, _approuterinstance.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n        navigatedAt: initialTimestamp,\n        initialFlightData: initialRSCPayload.f,\n        initialCanonicalUrlParts: initialRSCPayload.c,\n        initialRenderedSearch: initialRSCPayload.q,\n        initialParallelRoutes: new Map(),\n        location: window.location\n    }), instrumentationHooks);\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {\n                    initialRSCPayload: initialRSCPayload,\n                    actionQueue: actionQueue,\n                    webSocket: webSocket,\n                    staticIndicatorState: staticIndicatorState\n                })\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__') {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if (process.env.NODE_ENV !== 'production') {\n            const { RootLevelDevOverlayElement } = require('../next-devtools/userspace/app/client-entry');\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = /*#__PURE__*/ (0, _jsxruntime.jsx)(RootLevelDevOverlayElement, {\n                children: element\n            });\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (process.env.NODE_ENV !== 'production') {\n        const { linkGc } = require('./app-link-gc');\n        linkGc();\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-index.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12828, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SHAIK%20SHAFIYA/Desktop/medical/node_modules/next/dist/client/app-next-turbopack.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nconst _appbootstrap = require(\"./app-bootstrap\");\nconst _onrecoverableerror = require(\"./react-client-callbacks/on-recoverable-error\");\nwindow.next.turbopack = true;\nself.__webpack_hash__ = '';\n// eslint-disable-next-line @next/internal/typechecked-require\nconst instrumentationHooks = require('../lib/require-instrumentation-client');\n(0, _appbootstrap.appBootstrap)((assetPrefix)=>{\n    const { hydrate } = require('./app-index');\n    try {\n        hydrate(instrumentationHooks, assetPrefix);\n    } finally{\n        if (process.env.NODE_ENV !== 'production') {\n            const enableCacheIndicator = process.env.__NEXT_CACHE_COMPONENTS;\n            const { getOwnerStack } = require('../next-devtools/userspace/app/errors/stitched-error');\n            const { renderAppDevOverlay } = require('next/dist/compiled/next-devtools');\n            renderAppDevOverlay(getOwnerStack, _onrecoverableerror.isRecoverableError, enableCacheIndicator);\n        }\n    }\n});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=app-next-turbopack.js.map"],"names":[],"mappings":"AAeY;AAfZ;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,MAAM;AACN,MAAM;AACN,OAAO,IAAI,CAAC,SAAS,GAAG;AACxB,KAAK,gBAAgB,GAAG;AACxB,8DAA8D;AAC9D,MAAM;AACN,CAAC,GAAG,cAAc,YAAY,EAAE,CAAC;IAC7B,MAAM,EAAE,OAAO,EAAE;IACjB,IAAI;QACA,QAAQ,sBAAsB;IAClC,SAAS;QACL,wCAA2C;YACvC,MAAM;YACN,MAAM,EAAE,aAAa,EAAE;YACvB,MAAM,EAAE,mBAAmB,EAAE;YAC7B,oBAAoB,eAAe,oBAAoB,kBAAkB,EAAE;QAC/E;IACJ;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,8CAA8C","ignoreList":[0]}}]
}